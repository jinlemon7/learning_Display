# 根类Object成员（Java中所有类的共同方法）
  - protected Object clone()      ————创建并返回一个对象的拷贝（Java17无该方法）
  - boolean equals(Object obj)    ————比较两个对象是否相等(默认比较地址，比较存储内容需重写)
  - protected void finalize()     ————GC回收垃圾时，调用此方法，处理一些内存外的清理工作（高版本Java已不支持该方法）
  - Class<?> getClass()           ————获取对象的类
  - int hashCode()                ————获取对象的hash值
  - void notify()                 ————唤醒在该对象上等待的某个线程
  - void notifyAll()              ————唤醒在该对象上等待的全部线程
  - void wait()                            ————当前线程进入等待状态,直到其他线程调用此对象的notify()  
    void wait(long timeout)                 ————等待，或等待时间超过timeout参数  
    void wait(long timeout, int nanos)      ————等待，或等待时间超过timeout + nanos纳秒  
  - String toString()                      ————返回对象的字符串表示形式

## protected Object clone()方法如何用
  - 使用clone()，必须实现Cloneable接口，否则抛出CloneNotSupportException
  - Cloneable只是一个标记接口，没有方法需要实现（clone()是Object的方法，不是Cloneable的），仅标记该类可克隆(只需声明)
  - clone()修饰符从protected改为public，才能在其他类中使用

  ```
  class Person implements Cloneable{
    private String name;

    @Override
    public object clone() throws CloneNotSupportException{
      return supper.clone();
    }
  }

  Person a = new Person("Alice");
  Person copy = (Person)a.clone();    //Object转Person，“向下转型”
  ```

### clone()默认浅拷贝
  - 对基本类型字段包括（String），直接复制值
  - 对引用类型字段，复制的是引用地址，而非对象本身

  浅拷贝将导致原对象和克隆体的引用类型字段是共享的  
  修改一个对象的引用类型字段，另一个对象的该字段也当即被修改  

###  深拷贝（需手动实现）
  1. 递归处理引用类型字段
  2. 建立复制构造器
  3. 使用复制工厂方法
  4. 使用序列化
  ---
  1. 递归处理引用类型字段
     ```java
     class Employee implements Cloneable{
       String name;
       Department department;

       @Override
       public Object clone()throws CloneNotSupportedException{
         Employee cloned = (Employee)super.clone();                  //浅拷贝基本类型
         cloned.department = (Department)department.clone();         //深拷贝引用类型，实际复制了对象
         return cloned;
       }
     }
     ```

  2. 建立复制构造器
     ```java
     class Person{
       private String name;
       private int age;
       public Person(Person other){
         this.name = other.name;
         this.age = other.age;
       }
     }
     
     Person original = new Person("Alice", 25);
     Person copy = new Person(original);
     ```

  3. 使用复制工厂方法
     ```java
     class Person{
       private String name;
       private int age;

       public static Person newInstance(Person other){
         return new Person(other.name, other.age);          //类中static方法作复制工厂或外部建立工厂接口
       }
     }
     ```

  4. 使用序列化
     ```java
     import java.io.*;
     class DeepCopyUtil{
       @SuppressWarnings("unchecked")
       public static <T extends Serializable> T deepCopy(T object){
         try{
           ByteArrayOutputStream baos = new ByteArrayOutputStream();
           ObjectOutputStream oos = new ObjectOutputStream(baos);
           oos.writeObject(object);                                        //对象图转为字节流

           ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray() );
           ObjectInputStream ois = new ObjectInputStream(bais);
           return (T)ois.readObject();                                     //从字节流重新构造对象图
         }catch(IOException | ClassNotFoundException e){
           throw new RuntimeException("Deep copy failed", e);
         }
       }
     }
     ```

     ![序列化流程图](https://github.com/user-attachments/assets/bc29e236-ffbd-40a2-87a9-0dd3e212efa5)

     ![序列化过程](https://github.com/user-attachments/assets/a1078e02-77f9-4ff6-bcb5-498f980506e8)

# Lambda表达式
  一种简洁的匿名函数表示方法，可作为和简化函数式接口的实现（作为抽象方法的实现）  

  `(parameters) -> {expressions_or_statements}`  
  1. 无参数()
  2. 单参宿（可省略括号：x）
  3. 多参数(x, y...)
  ---
  1. 单行表达式：可省略{}和return
  2. 多行表达式：需用{}包裹，并显式使用return（若有返回值）

  作用域：可访问外部变量（外部变量在Lambda表达式内作为局部变量需为final修饰）  
  ```java
  int count = 0;               
  names.forEach( name->{
    //count++;                //非法：count必须为final！
    ...
  });
  ```

# 函数式接口（Functional Interface，仅含一个抽象方法的接口）：lambda表达式/方法引用需与函数式接口配合使用
  | 函数式接口 | 抽象方法 | 方法特点 |  
  | --- | --- | --- |  
  | Runnable | void run() | 无参无返回值任务 |   
  | Function<T, R> | R apply(T) | 接收T类型参数, 返回R |  
  | Predicate<T> | boolean test(T) | 条件判断 |  
  | Consumer<T> | void accept(T) | 接受一个参数, 无返回值 |  
  | Supplier<T> | T get() | 无参，返回T |  

  Lambda参数类型可省略（编译器自动推断） 
  ```java
  Function<String, Integer> len =  s -> s.length();    //`<String, Integer>`定义参数类型和返回值，`s ->`：省略参数类型
  ```
  Lambda中的this关键字指向所在类的实例，而非Lambda自身  

# 方法引用（可作为函数式接口的实现）和等效Lambda
  | 方法引用 | 引用语法 | 等效Lambda |  
  | --- | --- | --- |  
  | 静态方法引用 | ClassName::method | (args) -> ClassName.method(args) |  
  | 实例方法引用 | instance::method | (args) -> instance.method(args) |  
  | 构造方法引用 | ClassName::new | (args) -> new ClassName(args) |  

  ```java
  Function<String, Integer> lengthMapper = String::length;        //String类的引用方法length()作为函数式接口的实现
  List<Integer> lengths = names.stream()
                                .map(lengthMapper)
                                .collect( Collection.toList() );
  ```
   
# 匿名类
  没有显式命名的类，直接通过new父类/接口 {类体} 的方式定义并实例化  
  {} 的作用： 可重写父类/接口方法或添加新成员（字段/方法）从而创建一个继承自父类/接口的子类实例  
  
  `RandDouble rd = new RandDouble(){};`    创建了RandDouble的一个匿名子类实例，但未重写方法或添加成员。  

  ```java
  RandDouble rd = new RandDouble(){
    @Override
    public void someMethod(){              //重写了someMethod(), 并生成了RandDouble重写的子类实例
      ...
    }
  };
  ```

  1. 匿名类必须通过 {} 定义类体，即使为空
  2. {} 表示创建一个未扩展任何行为的匿名子类实例，{} 内可重写或添加扩展，通常用于接口/抽象类的快速实现
  3. 经典用途：简化代码，避免一次性使用的类要单独命名和创建单独Java文件

# List/Array的初始化
  | 容器 | 可变性 | 场景 |  
  | --- | --- | --- |  
  | List.of(...) | 不可变 | 需要固定元素的安全集合，不支持增删改 |  
  | Arrays.asList(...) | 半可变 | 快速创建支持set()的列表（set是覆盖），不支持增删 |  
  | new ArrayList<>(List.of() ) | 可变 | 可变且初始化 |  
  | new ArrayList<>() + add() | 可变 | 动态添加 |  

  - List`<Integer>` a = List.of(1, 2, 3);          //List.of()：Java9引入的一个静态工厂方法，创建一个不可变的列表
  - List`<Integer>` b = Arrays.asList(1, 2, 3);    //Arrays.asList()返回的列表大小固定(不可add/remove)
  - List`<Dog>` dogs = new ArrayList<>(List.of(new Dog() ) );    //简洁完成可变列表的初始化
  - dogs.add()

  List.of()和Arrays.asList()只能赋值List类型引用，赋值Arraylist/LinkedList类型引用会报错。  

# Java容器的使用注意点
## Map
 Map的三个方法提供遍历Map途径：  
 - entrySet()
 - keySet()
 - values()

 ```java
 for(Map.Entry t : m.entrySet() ){
  System.out.println(t.getKey() );
  System.out.println(t.getValue() );
 }
 ```

## Collection
 Collection使用迭代器遍历并获得容器的存储元素  
 ```java
 LinkedList<Integer> qu = new LinkedList<>();
 ListIterator it = (ListIterator) qu.iterator();  //Iterator转ListIterator为向下转型，需强制转换
 while( it.hasNext() ){
  int x = (int) it.next();                        //next()返回qu.get(i++), Object转int为向下转型，需强制转换
  System.out.println(x);
 }
 ```

## Enum枚举
### 定义一组命名常量
 ```java
 public enum Day{
  Monday, Tuesday, Wednesday
 }
 Day today = Day.Monday;        //枚举实例，无需new
 }
 ```

### 枚举高级特性：拥有字段、构造函数和方法
 ```java
 public enum Operation{
  PLUS("+");
  MINUS("-");

  private final String symbol;
  private Operation (String symbol){
   this.symbol = symbol;
  }
  public String getSymbol(){
   return this.symbol;
  }
  public abstract double apply(double x, double y);
 }

 Operation op = Operation.PLUS;
 ```

### Enum的自带方法
 1. name()          返回常量的名称字符串
 2. ordinal()       返回常量的声明位置
 3. values()        返回Enum的常量数组

 ```java
 for (Day d: Day.values() ){
  System.out.println(d);
 }
 ```

### 单例模式
 枚举实例默认static final且JVM加载机制保证线程安全和唯一性（防止反序列化重新创建对象）  
 所以实现单例模式的最佳方式是使用枚举   
 ```java
 public enum Singleton{
  INSTANCE;
  public void dosomething(){
   ...
  }
 }

 Sington.INSTANCE.dosomething();
 ```
