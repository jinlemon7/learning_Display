# 根类Object成员（Java中所有类的共同方法）
  - protected Object clone()      ————创建并返回一个对象的拷贝（Java17无该方法）
  - boolean equals(Object obj)    ————比较两个对象是否相等(默认比较地址，比较存储内容需重写)
  - protected void finalize()     ————GC回收垃圾时，调用此方法，处理一些内存外的清理工作（高版本Java已不支持该方法）
  - Class<?> getClass()           ————获取对象的类
  - int hashCode()                ————获取对象的hash值
  - void notify()                 ————唤醒在该对象上等待的某个线程
  - void notifyAll()              ————唤醒在该对象上等待的全部线程
  - void wait()                            ————当前线程进入等待状态,直到其他线程调用此对象的notify()  
    void wait(long timeout)                 ————等待，或等待时间超过timeout参数  
    void wait(long timeout, int nanos)      ————等待，或等待时间超过timeout + nanos纳秒  
  - String toString()                      ————返回对象的字符串表示形式

## protected Object clone()方法如何用
  - 使用clone()，必须实现Cloneable接口，否则抛出CloneNotSupportException
  - Cloneable只是一个标记接口，没有方法需要实现，仅标记该类可克隆(只需声明)
  - 修饰符从protected改为public，才能在其他类中使用

  ```
  class Person implements Cloneable{
    private String name;

    @Override
    public object clone() throws CloneNotSupportException{
      return supper.clone();
    }
  }

  Person a = new Person("Alice");
  Person copy = (Person)a.clone();    //Object转Person，“向下转型”
  ```

### clone()默认浅拷贝
  - 对基本类型字段包括（String），直接复制值
  - 对引用类型字段，复制的是引用地址，而非对象本身

  浅拷贝将导致原对象和克隆体的引用类型字段是共享的  
  修改一个对象的引用类型字段，另一个对象的该字段也当即被修改  

##  深拷贝（需手动实现）
  1. 递归处理引用类型字段
  2. 建立复制构造器
  3. 使用复制工厂方法
  4. 使用序列化以后谁要是

  1. 递归处理引用类型字段
     ```java
     class Employee implements Cloneable{
       String name;
       Department department;

       @Override
       public Object clone()throws CloneNotSupportedException{
         Employee cloned = (Employee)super.clone();                  //浅拷贝基本类型
         cloned.department = (Department)department.clone();         //深拷贝引用类型，实际复制了对象
         return cloned;
       }
     }
     ```

  2. 建立复制构造器
     ```java
     class Person{
       private String name;
       private int age;
       public Person(Person other){
         this.name = other.name;
         this.age = other.age;
       }
     }
     
     Person original = new Person("Alice", 25);
     Person copy = new Person(original);
     ```

  3. 使用复制工厂方法
     ```java
     class Person{
       private String name;
       private int age;

       public static Person newInstance(Person other){
         return new Person(other.name, other.age);          //类中static方法作复制工厂或外部建立工厂接口
       }
     }
     ```

  4. 使用序列化
     ```java
     import java.io.*;
     class DeepCopyUtil{
       @SuppressWarnings("unchecked")
       public static <T extends Serializable> T deepCopy(T object){
         try{
           ByteArrayOutputStream baos = new ByteArrayOutputStream();
           ObjectOutputStream oos = new ObjectOutputStream(baos);
           oos.writeObject(object);                                        //对象图转为字节流

           ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray() );
           ObjectInputStream ois = new ObjectInputStream(bais);
           return (T)ois.readObject();                                     //从字节流重新构造对象图
         }catch(IOException | ClassNotFoundException e){
           throw new RuntimeException("Deep copy failed", e);
         }
       }
     }
     ```

     ![序列化流程图](https://github.com/user-attachments/assets/bc29e236-ffbd-40a2-87a9-0dd3e212efa5)

     ![序列化过程](https://github.com/user-attachments/assets/a1078e02-77f9-4ff6-bcb5-498f980506e8)

# Lambda表达式
  一种简洁的匿名函数表示方法，可简化函数式接口（Functional Interface，仅含一个抽象方法的接口）的实现（作为抽象方法的实现）  

  `(parameters) -> {expressions_or_statements}`  
  1. 无参数()
  2. 单参宿（可省略括号：x）
  3. 多参数(x, y...)

  1. 单行表达式：可省略{}和return
  2. 多行表达式：需用{}包裹，并显式使用return（若有返回值）

## 函数式接口：lambda表达式需与函数式接口配合使用
  | 函数式接口 | 抽象方法 | 方法特点 |  
  | --- | --- | --- |  
  | Runnable | void run() | 无参无返回值任务 |   
  | Function<T, R> | R apply(T) | 接收T类型参数, 返回R |  
  | Predicate<T> | boolean test(T) | 条件判断 |  
  | Consumer<T> | void accept(T) | 接受一个参数, 无返回值 |  
  | Supplier<T> | T get() | 无参，返回T |  
     
  ```java
  Function<String, Integer> lengthMapper = String::length;        //String类的引用方法length()作为函数式接口的对象
  List<Integer> lengths = names.stream()
                                .map(lengthMapper)
                                .collect( Collection.toList() );
  ```

  | 方法引用简化Lambda | 引用语法 | 等效Lambda |  
  | --- | --- | --- |  
  | 静态方法引用 | ClassName::method | (args) -> ClassName.method(args) |  
  | 实例方法引用 | instance::method | (args) -> instance.method(args) |  
  | 构造方法引用 | ClassName::new | (args) -> new ClassName(args) |  

  作用域：可访问外部变量（局部变量需为final）  
  ```java
  int count = 0;               
  names.forEach( name->{
    //count++;                //非法：count必须为final！
    ...
  });
  ```
   
  Lambda参数类型可省略（编译器自动推断） 
  ```java
  Function<String, Integer> len =  s -> s.length();    //`<String, Integer>`定义参数类型和返回值，`s ->`：省略参数类型
  ```
  Lambda中的this关键字指向所在类的实例，而非Lambda自身  

  







