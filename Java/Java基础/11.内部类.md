定义在另一个类中的类称为内部类。  

# 创建内部类
  ```java
  public class Parcell {
    class Contents {
      private int i = 11;
      public int value() { return i; }
    }

    //在Parcel1内，使用内部类看上去
    //就和使用任何其他矣一样
    public void ship(String dest) {
      Contents c = new Contents();
    }
  }
  ```
  创建内部类的方式就是把类定义放在一个包围它的类之中  
  
  ```java
  public class Parcel? {
    class Contents {
      private int i = 11;
      public int value() ( return i; )
    }
    public Contents contents() {
      return new Contents();
    }

    public static void main(String[] args){
      Parcel2 q = new Parcel2();
      //定义指向内部吳的引用：
      Parcel2.Contents c = q.contents();
    }
  }
  ```
  更普遍的情况是，外部类有一个方法，该方法返回一个指向内部类的引用  
  要在外部类的非静态方法之外的任何地方创建内部类的对象，必须像在main()中看到的那样  
  将对象的类型指定为OuterClassName.InnerClassName  

# 到外部类的链接
  当创建一个内部类时，这个内部类的对象中会隐含一个链接，指向用于创建该对象的外围对象(编译器会为你处理所有这些细节 )
  通过该链接，无须任何特殊条件，内部类对象就可以访问外围对象的成员 此外，内部类拥有対外围对象所有元素的访问权  
   
  内部类的对象只能与其外围类的对象关联创建(当内部类为非static时), 内部类的对象在构造时  
  需要一个指向外围类对象的引用，如果编译器无法访问这个引用，它就会报错   

# 使用.this和 .new
  内部类中要生成外部类对象的引用，可以使用外部类的名字，后面加上句点和this。  
  这样生成的引用会自动具有正确的类型，而且是可以在编译时确定并检查的，所以没有任何运行时开销  
  ```java
  public class DotThis {
    public class Inner {
      public DotThis outer() {
        return DotThis.this;
        //如果直接写"this",引用的会是Inner的"this"
      }
    }
  }
  ```

  使用.new语法，在new表达式中提供指向内部类对象的引用  
  ```java
  public class DotNew {
    public class Inner {}
    public static void main(String(] args) {
      DotNew dn = new DotNew();
      DotNew.Inner dni = dn.new Inner();
    }
  }
  ```
  我们要使用外部类的对象来创建内部类的对象, 不用dn.new DotNew.Inner()(确实也不能用)  
  
  除非已经有了一个外部类的对象，否则创建内部类对象是不可能的 这是因为内部类的对象会暗中连接到用于创建它的外部类对象   
  然而，如果你创建的是嵌套类（static修饰的内部类），它就不需要指向外部类对象的引用  

# 内部类和向上转型
  ```java
  class Parcel4 {
    private class PContents implements Contents {
    private int i = 11；
    ©Override public int value() { return i； }
    }
  }

  public class TestParcel {
    public static void main(String[] args) {
      //非法---- 不能访问private类：
      //- Parcel4.PContents pc = p.new PContents();
    }
  }
  ```
  内部类PContents是private的，所以只有Parcel4能访问它  
  不能向下转型为private的内部类（除非有继承关系，否则也不能向下转型为protected的内部类）  
  因为无法访问其名字，就像在TestParcel中看到的那样  

# 在方法和作用域中的内部类
  内部类可以在一个方法内或者任何一个作用域内创建 这么做有两个理由:  
  1. 正如先前所演示的，你要实现某种接口，以便创建和返回一个引用
  2. 你在解决一个复杂的问题,在自己的解决方案中创建了一个类来辅助，但是你不想让它公开

  局部内部类的功能：
  1. 在方法中定义的类；
  2. 在方法中的某个作用域内定义的类；
  3. 实现某个接口的匿名类；
  4. 执行字段初始化的匿名类；它通过实例初始化来执行构造(匿名内部类不允许有构造器)的匿名类

  局部内部类：  
  ```java
  public class Parcel.5 {
    public Destination destination(String s) {
      final class PDestination implements Destination {
        private String label;
        private PDestination(String whereTo) {
          label = whereTo;
        }
        ©Override
        public String readLabel() { return label; }
      }  
      return new PDestination(s);
    }
  }
  ```
  PDestination类是destination()的一部分，而不是Parcels的一部分 因此，PDestination在destination()外无法访问   
  在return语句中的向上转型意味着destination()中只传出了一个指向Destination接口的引用  

  在同一子目录下的每个类内，你都可以使用类标识符PDestination来命名内部类，而不会产生名字冲突  

  ```java
  public class Parcels {
    private void internal!racking(boolean b) {
      if(b) {
        class TrackingSlip {
          private String id;
          TrackingSlip(String s) {
            id = s;
          }
          String getSlip() { return id; }
        }
          
        TrackingSlip ts = new TrackingSlipC'slip");
        String s = ts.getSlip();
      }
      //这里不能使用，已经出了作用域：
      //- TrackingSlip ts = new TrackingSlipC'x");
    }
  }
  ```
  TrackingSlip类被嵌入了一个if语句的作用域内  
  它在定义它的作用域之外是不可用的 除此之外,它看上去就像普通的类一样  

# 匿名内部类
  这个类没有名字一它是匿名的。  
  语法意思是“ 建一个继承自父类/接口的匿名类的对象” 通过new表达式返回的引用会被自动地向上转型为一个父类/接口引用
  
  ```java
  public class Parcels {
    public Wrapping wrapping(int x) (
      //基类构造器调用：
      return new Wrapping(x) { // [1]
        ©Override
        public int value() (
          return super.value() * 47;
        }
      }； // [2]
    }
  }
  ```
  - 将适当的参数传给基类构造器
  - 匿名内部类末尾的分号并不是用来标记类体的结束 相反，它标记表达式的结束.而该表达式恰好包含了这个匿名类

  ```java
  public class Parcel9 {
    //要在匿名内部类中使用，
    //参数必须是最终变量，或者"实际上的最终变量:“
    public Destination destination(final String dest) {
      return new Destination() {
        private String label = dest;
        ©Override
        public String readLabel() ( return label; }
      }；
    }
  }
  ```
  如果你正在定义一个匿名类，而且一定要用到一个在该匿名类之外定义的对象，编译器要求参数引用用final修饰，  
  或者是“ 际上的最终变虽”(也就是说，在初始化之后它永远不会改变，所以它可以被视为final的)  

  借助实例初始化，我们可以在效果上为匿名内部类创建一个构造器  
  ```java
  public class AnonymousConstructor {
    public static Base getBase(int i) {
      return new Base(i) {
        { System.out.printin(                      //{}类的即是实例初始化
          "Inside instance initializer"); }
        ©Override
        public void f() {
          System.out.println("In anonymous f()");
        }
      }；
    }
  }
  ```
  这里变量i并不是必须为最终变量 尽管i被传给了匿名类的基类构造器，但是在该匿名类内部，它并没有被直接使用到

  与普通的继承相比，匿名内部类有些局限性，因为它们要么是扩展一个类，要么是实现一个接口，  
  但是两者不可兼得，而且就算要实现接口，也只能实现一个  
  因为匿名内部类只能new 类名/接口名 时继承一个父类，没有类名无法使用implements  

# 嵌套类
  如果不需要内部类对象和外部类对象之间的连接，可以将内部类设置为static的嵌套类  
  嵌套类意味着:  
  1. 不需要一个外部类对象来创建嵌套类对象
  2. 无法从嵌套类对象内部访问非static的外部类对象，但是可以在嵌套类中直接new嵌套类所在的外部类

  普通内部类的字段和方法，只能放在类的外部层次中，所以普通内部类中不能有static数据、static字段，  
  也不能包含嵌套类 但是嵌套类中可以包含所有这些内容：  
  ```java
  public class Parcel11 {
    protected static final class ParcelDestination implements Destination {
      @Override
      public String readLabel() ( return label; }
        //嵌套类可以包含其他静态元素
      public static void f() {}
      static int x = 10;
      static class AnotherLevel {
        public static void f() {}
        static int x = 10;
      }
    }
  }
  ```
  普通内部类(非static的)可以使用特殊的this引用来创建指向外部类对象的连接，而嵌套类没有特殊的this引用，这使它和static方法类似  

## 接口中的类
  嵌套类可以是接口的一部分，放到接口中的任何类都会自动成为public和static的  
  ```java
  public interface Classininterface {
    void howdy();
    class Test implements Classlnlnterface {
      ©Override
      public void howdy() { System.out.println("Howdy!");
      }
    }
  }
  ```
  当你要创建供某个接口的所有不同实现使用的公用代码时，将一个类嵌入这个接口中会非常方便  
  
  在每个类中都写一个main，用来测试这个类。这样做有个潜在的缺点：测试设施会暴露在交付的产品中  
  可以使用一个嵌套类来存放测试代码:  
  ```java
  public class TestBed {
    public void f() ( System.out.printin("f()"); }
    public static class Tester {
      public static void main(String[] args) {
        TestBed t = new TestBed();
        t.f();
      }
    }
  }
  ```
  这会生成一个叫TestBed$Tester的独立的类（要运行这个程序，可以执行javaTestBed$Tester）  
  可以在交付之前删除TestBed$Tester.class  

# 从多层嵌套的内部类中访问外部成员
  一个内部类被嵌套多少层并不重要，它可以透明地访问包含它的所有类的所有成员
  ```java
  class MNA {
    private void f() {}
    class A {
      private void g() {}
      public class B {
        void h() {
          g()；
          f()；
        }
      }
    }
  }

  public class MultiNestingAccess {
    public static void main(String[] args) {
      MNA mna = new MNA();
      MNA.A mnaa = mna.new A();
      MNA.A.B mnaab = mnaa.new B();
      mnaab.h();
    }
  }
  ```
  也演示了当你在一个不同的类中创建对象时，创建多层嵌套的内部类对象的基本语法  
  .new语法会得到正确的作用域，所以不必在调用构造器时限定类的名字  

# 为什么需要内部类
  遇到有时需要继承多个类的情况（Java不允许类的多重继承）  
  理由：每个内部类都可以独立地继承自一个类。因此，外部类是否已经继承了某个类，对内部类并没有限制  

  内部类完善了多重继承问题的解决方案 接口解决了一部分问题，但内部类实际上支持了 “ 多重类继承”
  内部类实际上支持我们继承多个非接口类型  

  有了内部类.我们就可以获得如下这些额外的功能:  
  1. 内部类可以有多个实例，每个实例都有自己的状态信息，独立于外围类对象的信息
  2. 一个外围类中可以有多个内部类，它们可以以不同方式实现同一个接口，或者继承同一个类
  3. 内部类对象的创建时机不与外围类对象的创建捆绑到一起
  4. 内部类不存在可能引起混淆的“is-a”关系；它是独立的实体

## 闭包与回调
  闭包（closure）是一个可调用的对象，它保留了来自它被创建时所在的作用域的信息  
  看到内部类是面向对象的闭包，因为它不仅包含外围类对象（“ 被创建时所在的作用域”）的每一条信息，  
  而且它自动持有着对整个外围类对象的引用,它有权操作外部对象中的所有成员，甚至是private成员  

  回调（callback）：通过回调，我们可以给其他某个対象提供一段信息，以支持它在之后的某个时间点调用回原始的对象中  
  ```java
  class Callee2 extends Myincrement {
    @Override
    public void increment() {
      super.incrementO;
      i++；
      System.out.printin(i);
    }
  
    private class Closure implements Incrementable {
      @Override
      public void increment() {
      //需要指定调用外国类方法，否則会无限递归：
        Callee2.this.increment();
      }
    }
  }
  ```
  当创建内部类时, 并没有增加或修改外围类的接口  
  内部类Closure实现了 Incrementable,用来提供一个指回Callee2中的钩子，但这是—个安全的钩子  
  回调的价值在于其灵活性———— 你可以在运行时动态地决定调用哪些方法  

# 内部类与控制框架
  应用框架(application framework )是为解决某一特定类型的问题而设计的一个类或一组类   
  要应用某个应用框架，通常要继承一个或多个类，并重写某些方法  
  这是模板方法(Template Method )设计模式的一个例子  

  控制框架是一种特殊类型的应用框架，主要是为了满足对事件做出响应这样的需求   
  主要对事件做出响应的系统叫事件驱动系统(event-driven system )  
  ```java
  public class Controller {
    //用java.util中的一个英来保存Event对象：
    private List<Event> eventList = new ArrayList<>();
    public void addEvent(Event c) { eventList.add(c); }
    public void run() {
      while(eventList.size() > 0)
      //创it一个制本，这料在选择列衣
      //中的元未时此不会改动列衣了：
      for(Event e : new ArrayListo(eventList))
      if(e.readyO) {
        System.out.println(e);
        e.action();
        eventList.remove(e);
      }
    }
  }
  ```
  到目前为止，你对一个Event到底是干什么的还是一无所知 这正是这种设计的关键所在，就是它如何“ 将变化的事物与保持不变的事物分离开来  

  1. 控制框架的整个实现是在一个单独的类内创建的，从而封装了关于该实现的所有独特之处  
     内部类用来表达解决问题所必需的多种不同的action()。  
  2. 内部类可以避免这种实现变得过于笨拙，因为我们很容易访问外围类的任何成员  
     如果没有这种能力，代码可能会不好用，以至于你不得不去寻找替代方案

  内部类支持在一个类内实现同一基类Event的多个派生版本  

# 继承内部类
  ```java
  class Withlnner {
    class Inner {}
  }

  public class Inheritlnner extends Withlnner.Inner {
    //- Inheritlnner() (} // 不能编译
    Inheritlnner(Withlnner wi) {
      wi.super();
    }
    public static void main(String[] args) {
      Withlnner wi = new Withlnner();
      Inheritlnner ii = new Withlnner(wi);
    }
  }
  ```
  当需要创建构造器时，默认构造器是行不通的，只传递一个指向其包围类对象的引用是不够的。  
  除此，还必须在构造器内使用如下语法：  
  `enclosingClassReference.super();`  

# 内部类可以被重写吗
  把内部类当成外围类中的其他方法一样重写（非显式继承），并没有什么实际意义
  因为当继承外围类时，内部类并没有额外的特殊之处，这两个内部类是完全独立的实体,分别在自己的命名空间中  

  显式地继承某个内部类是可以的：  
  ```java


  











