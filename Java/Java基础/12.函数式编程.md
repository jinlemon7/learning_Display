函数式编程语言处理代码片段就像处理数据一样简单, 尽管Java并非函数式语言，  
但是Java 8的lambda表达式和方法引用允许我们以函数式风格编程  

函数式编程（functional programming, FP ）的意义所在：  
不是从零开始编写大量代码，而是从现有的、可以理解的、经过良好测试的、可靠的小代码片段幵始。  
然后将它们组合在一起，创建新的代码  

面向对象编程抽象数据，而函数式编程抽象行为  

纯函数式语言规定了额外的约束条件，即所有的数据必须是不可变的：设置一次，永不改变。  
函数会接受值，然后产生新值, 但是绝对不会修改自身之的任何东西（包括其参数或该函数作用域之外的元素）  

纯函数式语言经常被当作并行编程问题的解决方案: “不可变对象和无副作用”这一编程范式解决了并行编程（当程序的不同  
部分同时在多个处理器上运行时）中最基本和最棘手的问题之----- “可变的共享状态”问题  

# 旧方式与新方式
  以前的做法是组合语法：创建一个对象，让它的一个方法包含所需行为，然后将这个对象传递给我们想控制被引用方法的所在方法  
  在Java 8之前,我们已经能够通过组合语法和匿名类传递功能  
  Java 8之后，方法引用和lambda表达式改变了这种状况，我们想传递功能的时候就可以传递  

# lambda 表达式
  lambda表达式是使用尽可能少的语法编写的函数定义  
  lambda表达式产生的是函数，而不是类 在Java虚拟机(JVM)上，一切都是类，所以幕后会有各种各样的操作.让lambda看起来像函数  

  任何lambda表达式的基本语法如下所示:  
  1. 参数
  2. 后面跟 ->，你可以将其读作“产生” (produces)；
  3.  -> 后面的都是方法体

  ---
  1. 只有一个参数，可以只写这个参数，不写括号 不过这是一种特殊情况
  2. 通常情况是用括号将参数包裹起来
  3. 在没有参数的情况下，必须使用括号来指示空的参数列表
  4. 在有多个参数的情况下，将它们放在使用括号包裹起来的参数列表内

  方法体是一行的：方法依中表达式的结果会自动成为lambda表达式的返回值，  
  这里使用return关键字是不合法的：这是lambda表达式简化描述功能的语法的又一种方式  

  如果lambda表达式需要多行代码，则必须将这些代码行放为花括号中。这种情况下就需要使用return从lambda表达式生返回一个值了  

  在Java中也可以编写递归的lambda表达式，但是有一点要注意：  
  这个lambda表达式必须被赋值给一个静态变量或一个实例变星，否则会出现编译错误  
  ```java
  interface IntCall {
    int call(int arg);
  }

  public class RecursiveFactorial {
    static IntCall fact;
    public static void main(String[] args) {
      fact = n->n = 0 ? l ：n* fact.call (n - 1);
      for(int i = 0; i <= 10; i++)
        System.out.println(fact.call(i));
    }
  }
  ```
  请注意，不能在定义的时候像这样来初始化fact：  
  `static IntCall fact = n->n = 0 ? l ：n* fact.call (n - 1);`  
  尽管这样的期望非常合理，但是对于Java编译器而言处理起来太复杂了，所以会产生编译错误  
  > [!IMPORTANT]
  > lambda表达式赋值引用：必须先独立声明引用，之后才能初始化

# 方法引用
  Java 8方法引用指向的是方法，没有之前Java版本的历史包袱 方法引用是用类名或对象名，后面跟'::' ，然后跟方法名  
  ```java
  interface Callable {
    void call(String s);
  }
  class Describe {
    void show(String msg) (                    //[1]
      System.out.printIn(msg);
    }
  }
  public class MethodReferences {
    static void hello(String name) {
      System.out.printIn("Hello, " + name);
    }
    static class Description {
      String about;
      Description(String desc) { about = desc; }
      void help(String msg) {
        System.out.println(about + " " + msg);
      }
    }
    static class Helper {
      static void assist(String msg) {
        System.out.println(msg);
      }
    }
    public static void main(String[] args) {
      Describe d = new Describe();
      Callable c = d::show;                  //[2]
      c.call("call()");                      //[3]

      c = MethodReferences::hello;
      c.call("Bob");

      c = new Description("valuable")::help;    //[4]
      c.call("information");

      c = Helper::assist;
      c.call("Help!");
    }
  }
  ```
  ```java
  /*输出:
  call()
  Hello, Bob
  valuable information
  Help!
  */
  ```
  - [1]show()的签名(参数类型和返回类型)和Callable中call()的签名一致
  - [2]我们将Describe对象的一个方法引用赋值给了一个Callable, Callable中没有show()方法，  
    只有一个call()方法 然而，Java似乎对这种看似奇怪的赋值并没有意见，因为这个方法引用的签名和Callable中的call()方法一致  
  - [3]现在可以通过调用call()来调用show(),因为Java将call()映射到了 show()上
  - 实例方法引用：[4]这是[2]的另一个版本：对某个活跃对象上的方法的方法引用，有时叫作“绑定方法引用” (bound method reference )
  - 静态方法引用：对于static方法而言，引用该方法无需对象，只需ClassName::method

## Runnable
  Runnable接口在java.lang包中,所以不需要import。它也遵从特殊的单方法接口格式：  
  其run()方法没有参数，也没有返回值  
  ```java
  class Go {
    static void go() {
      System.out.printin("Go::go()");
    }
  }

  public class RunnableMethodReference {
    public static void main(String[] args) {
      new Thread(new Runnable() {                    //匿名类
        public void run() {
          System.out.println("Anonymous");
        }
      }).start();

      new Thread(
        ()-> System.out.printtn("lambda")            //lambda表达式
      ).start();

      new Thread(Go::go).start();                    //方法引用
    }
  }
  ```
  ```
  /*输出:
  Anonymous
  lambda
  Go::go()
  */
  ```
  Thread对象接受一个Runnable作为其构造器参数，它有一个start()方法会调用run()  
  示例代码中的3种情形，只有匿名内部类需要提供名为run()的方法  
  
  
# 未绑定方法引用
  未绑定方法引用(unbound method reference )指的是尚未关联到某个对象的普通(非静态)方法   
  对于未绑定引用，必须先提供对象.然后才能使用。（非static方法才需要先提供对象）  
  ```java
  class X {
    String f() { return "X::f()"; )
  }

  interface MakeString {
    String make();
  }

  interface TransformX {
    String transform(X x);                              //[1]
  }

  public class UnboundMethodReference {
    public static void main(String[] args) {
      // MakeString ms = X::f;                          //[2]
      TransformX sp = X::f;
      X x = new X();
      System.out.println(sp ・ transform(x));
      System.out.println(x.f()); // 效果相同
    }
  }
  ```
  ```java
  /*输出：
  X::f()
  X::f()
  */
  ```
  引用的方法，与其关联接口(方法引用所实现的接口)的签名是相同的  
  在[2]处，属于无效方法引(invalid method reference)：`X::f`代表的是一个未绑定方法引用，因为它没有“绑定到”某个对象  

  在[1]处, 在未绑定引用的情况下，函数式方法(接口中的单一方法)的签名与引用方法的签名不再完全匹配:  
  以X为参数在其上调用了 transform(),最终以某种方式调用了 x.f()  
  即：未绑定方法引用情况下，接口方法必须接受第一个参数（被规定的），事实上就是this,并在它的上面调用该方法  

  方法有更多参数，只要遵循第一个参数取的是this这种模式:  

# 构造器方法引用
  可以捕获对某个构造器的引用，之后通过该引用来调用那个构造器  
  ```java
  class Dog {
    String name;
    Dog() { name = "stray"; }
  }
  interface MakeNoArgs {
    Dog make();
  }

  public class CtorReference {
    public static void main(String[] args) {
      MakeNoArgs mna = Dog::new;
      Dog dn = mna.make();
    }
  }
  ```

# 函数式接口
  `x -> x.toString()`  
  为lambda表达式包含了某种形式的类型推断（编译器推断出类型的某些信息，而不需要程序员显式指定）  

  `(x, y) -> x + y`  
  x和y可以是支持'+'操作符的任何类型, 在lambda表达式被赋值之后，编译器就必须确定x和y的精确类型并生成正确的代码了  

  Java 8引入了包含一组接口的java.util.function,这些接口是lambda表达式和方法引用的目标类型  
  每个接口都只包含一个抽象方法，叫作函数式方法  
  “函数式方法”模式可以使用@FunctionalInterface注解来强制实施  
  ```java
  @FunctionalInterface
  interface Functional {
    String goodbye(String arg);
  }

  /*
  @FunctionalInterface
  interface NotFunctional {
    String goodbye(String arg);
    String hello(String arg);
  }
  产生报错信息：
  NotFunctional is not a functional interface
  multiple non-overriding abstract methods
  found in interface NotFunctional
  */

  public class FunctionalAnnotation {
    public String goodbye(String arg) {
      return "Goodbye, " + arg;
    }
    public static void main(String[] args) {
      FunctionalAnnotation fa = new FunctionalAnnotation();
      Functional f = fa::goodbye;
      // Functional fac = fa; // 不兼容
    }
  }
  ```
  @Functionallnteiface 注解是可选的  
  @FunctionalInterface的价值：如果接口中的方法多于一个,则会产生一条编译错误信息  
  
  如果我们将一个方法引用或lambda表达式赋值给某个函数式接口（而且类型可以匹配）,那么Java会调整这个赋值，  
  使其匹配目标接口。而在底层，Java编译器会创建一个实现了目标接口的类的实例，并将我们的方法引用或lambda表达式包裹在其中  

  使用了@FunctionalInteiface 注解的接口也叫作单一抽象方法（Single Abstract Method,SAM）类型  
  
  试图把FunctionalAnnotation直接赋值给一个Functional, Java是不允许的。这也符合我们的预期，因为它没有显式地实现Functional
  
# java.util.function  
  旨在创建一套足够完备的目标接口，这样一般情况下我们就不需要定义自己的接口了  
  命名规则：  
  1. 如果接口只处理对象，而非基本类型，那就会用一个直截了当的名字，像Function、Consumer和Predicate等。参数类型会通过泛型添加
  2. 如果接口接受一个基本类型的参数，则会用名字的第一部分来表示，例如LongConsumer.DoubleFunction和 IntPredicate等接口类型。基本的 Supplier 类型是个例外。
  3. 如果接口返回的是基本类型的结果，则会用To来表示，例如ToLongFunction<T>和IntToLongFunction
  4. 如果接口返回的类型和参数类型相同，则会被命名为Operator。UnaryOperator用于表示一个参数，Binaryoperator用于表示两个参数
  5. 如果接口接受一个参数并返回boolean,则会被命名为Predicate
  6. 如果接口接受两个不同类型的参数，则名字中会有一个Bi （比如BiPredicate）

  | 特点 | 函数式方法 | 用法 |  
  | --- | --- | --- |  
  | 没有参数；没有返回值 | Runnable (java lang) run() | Runnable |  
  | 没有参数：可以返回任何类型 | Supplier get() getAstype() | Supplier<T></br> BooleanSupplier</br> IntSupplier</br> LongSupplier</br> DoubleSupplier |  
  | 没有参数；可以返回任何类型 | Callable (java.util concurrent) call() | Callable<V> |  
  | 一个参数；没有返回值 | Consumer accept() | Consumer<T></br> IntConsumer</br> LongConsuner</br> DoubleConsumer |  
  | 两个参数的Consumer | BiConsumer accept() | BiConsuroer<T,U> |  
  | 两个参数的 Consumer: 第一个参数是引用.第二个参数是基本类型 | ObjtypeConsumer accept() | ObjIntConsumercT></br> ObjLongConsuner<T></br> ObjDoubleConsumer<T> |  
  | 一个参数；返回値为不同类型 | Function apply() TotypeFunction & typeTotypeFunction: applyAstype() | Function<T,R></br> IntFunction<R></br> LongFunction<R></br> DoubleFunction<R></br> ToIntFunction<T></br> ToLongFunction<T></br> ToDoubleFunction<T></br> IntToLongFunction</br> IntToDoubleFunction</br> LongToIntFunction</br> LongToDoubleFunction</br> DoubleToIntFunction</br> DoubleToLongFunction |  
  | 一个参数；返回值为相同类型 | UnaryOperator apply() | UnaryOperator<T></br> IntUnaryOperator</br> LongUnaryOperator</br> DoubleUnaryOperator |  
  | 两个相同类型的参数；返回值也是相同类型 | BinaryOperator apply() | BinaryOperator<T></br> IntBinaryOperator</br> LongBinaryOperator</br> DoubleBinaryOperator |  
  | 两个相同类型的参数；返回int | Comparator (java.util) compare() | Comparator<T> |  
  | 两个参数；返回boolean | Predicate test() | Predicate<T></br> BiPredicate<T,U></br> IntPredicate</br> LongPiedicate</br> DoublePredicate |  
  | 一个参数；基本类型的参数；返回值也是基本类型 | typeTotypeFunction applyAstype() | IntToLongFunction</br> IntToDoubleFunction</br> LongToIntFunction</br> LongToDoubleFunction</br> DoubleToIntFunction</br> DoubleToLongFunction |  
  | 两个参数；不同类型 | Bi+操作名（方法名会変化） | BiFunction<T,U,R></br> BiConsuner<T,U></br> BiPredicate<T,U></br> ToIntBiFunction<T,U></br> ToLongBiFunction<T.U></br> ToDoubleBiFunction<T.U> |  

  表中的“type”会根据具体情况皆换为相应类型名  

  示例列举了可用于lambda表达式的所有不同的Function变种：  
  ```java
  class Foo {}
  class Bar {
    Foo f;
    Bar(Foo f) { this.f = f; )
  }
  class IBaz {
    int i;
    IBaz(int i) {
    this.i = i;
  }
  class LBaz {
    long I;
    LBaz(long I) {
      this.I = I;
    }
  }
  class DBaz {
    double d;
    DBaz(double d) {
      this.d = d;
    }
  }
  public class Functionvariants {
    static Function<Foo,Bar> fl = f -> new Bar(f);
    static IntFunction<IBaz> f2 = i -> new IBaz(i);
    static LongFunction<LBaz> f3 = l -> new LBaz(l);
    static DoubleFunction<DBaz> f4 = d -> new DBaz(d);
    static ToIntFunction<IBaz> f5 = ib -> lb.i;
    static ToLongFunction<LBaz> f6 = lb -> lb.l;
    static ToDoubleFunction<DBaz> f7 = db -> db.d;
    static IntToLongFunction f8 = i -> i;
    static IntToDoubleFunction f9 = i -> i;
    static LongToIntFunction fl0 = l -> (int)l;
    static LongToDoubleFunction fll = l -> l;
    static DoubleToIntFunction fl2 = d -> (int)d;
    static DoubleToLongFunction fl3 = d -> (long)d;

    public static void main(String[] args) {
      Bar b = fl.apply(new Foo());
      IBaz ib = f2.apply(ll);
      LBaz lb = f3.apply(ll);
      DBaz db = f4.apply(ll);
      int i = f5.applyAsInt(ib);
      long I = f6.applyAsLong(lb);
      double d = f7.applyAsDouble(db);
      l = f8.applyAsLong(12);
      d = f9.applyAsDouble(12);
      i = flO.applyAsInt(12);
      d = fll.applyAsDouble(12);
      i = fl2.applyAsInt(13.0);
      l = f13.applyAsLong(13.0);
    }
  }
  ```

  方法引用有自己的魔法:  
  查阅BiConsumei的文档，会看到它的函数式方法是accept()。确实，如果将我们的方法命名为accept()，它可以用作方法引用  
  但如果给它起个完全不同的名字，比如someOtherName(),只要参数类型和返回类型与BiConsumei的accept()相同，也是没问题的  
  要调用我们的方法，就要调用这个函数式方法的名字（在这个示例中是accept() ）,而不是我们的方法的名字  

  所有基于类的函数式接口:  
  ```java
  class AA {}
  class BB {)
  class CC {}

  public class ClassFunctionals {
    static AA fl() { return new AA(); }
    static int f2(AA aal, AA aa2) { return 1； }
    static void f3(AA aa) {}
    static void f4(AA aa, BB bb) {}
    static CC f5(AA aa) ( return new CC(); }
    static CC f6(AA aa, BB bb) ( return new CC(); }
    static boolean f7(AA aa) ( return true; }
    static boolean f8(AA aa, BB bb) ( return true; }
    static AA f9(AA aa) ( return new AA(); )
    static AA fl6(AA aal, AA aa2) { return new AA(); }
    public static void main(String!] args) {
      Supplier<AA> s = ClassFunctionals::fl;
      s.get();
      Comparator<AA> c = ClassFunctionals::f2;
      c.compare(new AA(), new AA())；
      Consumer<AA> cons = ClassFunctionals::f3;
      cons.accept(new AA());
      BiConsumer<AA,BB> bicons = ClassFunctionals::f4;
      bicons.accept(new AA(), new BB())；
      Function<AA,CC> f = ClassFunctionals::f5;
      CC cc = f.apply(new AA());
      BiFunction<AA,BB,CC> bif = ClassFunctionals::f6;
      cc = bif.apply(new AA(), new BB());
      Predicate<AA> p = ClassFunctionals::f7;
      boolean result = p.test(new AA());
      BiPredicate<AA,BB> bip = ClassFunctionals::f8;
      result = bip.test(new AA(), new B());
      UnaryOperator<AA> uo = ClassFunctionals::f9;
      AA aa = uo.apply(new AA());
      BinaryOperator<AA> bo = ClassFunctionals: :fl0;
      bo.apply(new AA(), new AA());
    }
  }
  ```
  一旦方法引用被赋值给某个函数式接口，只能调用与这个函数式接口关联的函数式方法（不能使用引用的方法名来调用）  
  
## 带有更多参数的函数式接口
  需要用于3个参数的函数接口呢？编写我们自己的接口也很容易：
  ```java
  @FunctionalInterface
    public interface TriFunction<T, U, V, R> (
      R apply(T t, U u, V v);
    }

  public class TriFunctionTest (
    static int f(int i, long l, double d) { return 99; }
    public static void main(String[] args) {
      TriFunction<Integer, Long, Double, Integer> tf = TriFunctionTest::f;
      tf = (i, l, d) -> 12;
    }
  }
  ```

## 解决缺乏基本类型函数式接口的问题
  看如何创建java.util.function中没有提供的，涉及int、long和double等基本类型的函数式接口:  
  ```java
  static BiConsumer<Integer, Long> bicil = (i, l) -> System.out.format("%d, %d%n", i, l);    //自定义函数式接口

  public class FunctionWithWrapped {
    public static void main(String[] args) {
      Function<Integer, Double> fid = i -> (double)i;
      IntToDoubleFunction fid2 = i -> i；
    }
  }
  ```
  直接编写Function<Integer,Double>就能得到可行的方案，存在函数式接口的基本类型变种的唯一原因  
  就是防止在传递参数和返回结果时涉及自动装箱和自动拆箱。也就是说，为了性能  
  之所以有些函数式接口类型有定义，而有些没有，是根据预计的使用频率决定的  

# 高阶函数
  高阶函数只是一个能接受函数作为参数或能把函数当返回值的函数  
  ```java
  interface FuncSS extends Function<String, String> {}       // [1]

  public class ProduceFunction {
    static FuncSS produce() {
      return s -> s.toLowerCase();                           // [2]
      }
    public static void main(String[] args) {
      FuncSS f = produce()；
      System.out.println(f.apply("YELLING"));
    }
  }
  ```
  ```java
  /*
  yelling
  */
  ```
  1. 使用继承，可以轻松地为专门的接口创建一个别名
  2. 有了 lambda表达式，在方法中创建并返回一个函数简直不费吹灰之力

  要接受并使用函数，方法必须在其参数列表中正确地描述函数类型:  
  ```java
  public class ConsumeFunction {
    static Two consume(Function<One,Two> onetwo) {
      return onetwo.apply(new One());
    }
  }
  ```

  ```java
  class I {
    @Override public String toString() ( return "I"; )
  }
  class O {
    @Override public String toString() { return "O"; }
  }

  public class TransformFunction {
    static Function<I,O> transform(Function<I,O> in) {  //4.in是transform中定义的lambda表达式
      return in.andThen(o -> {                          //5.in.andThen()：先执行in的调用，再执行andThen()中的调用
        System.out.println(o);                          //5.返回一个组合函数：in.andThen(...)
        return o;                                       
      })；
    }
    public static void main(String[] args) {
      Function<I,O> f2 = transform(i -> {         //2.i即是新建的I()
        System.out.println(i);
        return new O();                           //3.返回新建的O(), 传递给in.andThen()中的o
      })；
      O o = f2.apply(new I());                    //1.新建了I()，传递给f2-lambda表达式的i
  ```
  ```java
  /*
  I
  O
  */
  ```
  Function接口中的一个叫作andThen()的默认(default)方法，该方法是专门为操作函数而设计, andThen()会在in函数调用之后调用  
  要附加上一个andThen()函数，只需要将一个函数作为参数传递  
  还有compose()方法，它会在in函数之前应用新函数。  
  
# 闭包
  闭包(closure):lambda函数可以使用其函数作用域之外的变量，闭包也称：支持词法作用域(lexically scoped) 
  闭包非常重要，因为它们使生成函数变简单了  
  lambda表达式的参数和外部变量必须是final的：主要体现在变量捕获(variable capture) ，被捕获的变量是“实际上的最终变量”  

  对同一个对象调用多次makeFun(),最终就会有多个函数全部共享同样的i的存储空间:  
  ```java
  public class Closurel {
    int i;
    IntSupplier makeFun(int x) {
      return () -> x + i++；
    }
  }
  public class SharedStorage {
    public static void main(String[] args) {
      Closurel cl new ClosureK);
      IntSupplier fl = cl.makeFun(O);
      IntSupplier f2 = cl.makeFun(O);
      IntSupplier f3 = cl.makeFun(0);
      System.out.printin(fl.getAsInt());
      System.out.printin(f2.getAsInt());
      System.out.printin(f3.getAsInt());
    }
  }
  ```
  ```java
  /*输出：
  0
  1
  2
  */
  ```

  如果i是makeFun()中的局部变量：  
  ```java
  public class Closure? {
    IntSupplier makeFun(int x) {
      int i = 0;
      return () -> x + i;
    }
  }
  ```
  makeFun()返回的IntSupplier是在i和x之上构建的闭包，所以当我们调用所返回的函数时，这两个变量都是有效的(因为在变量捕获过程中没有修改i和x的值)  

  实际上的最终变量”(effectively final)，这个术语是为Java 8创建的，如果一个局部变量的初始值从不改变，它就是“ 际
上的最终变量”  
  如果x和i在所返回的函数中没有被修改，但是在方法中的其他地方被修改了，编译器仍然会将其当作错误  

  实际上我们可以这样修复：在闭包中使用x和i之前，先将其赋值给最终变量  
  ```java
  public class Closure6 {
    IntSupplier makeFun(int x) {
      int i = 0;
      i++；
      x++;
      final int iFinal = i;
      final int xFinal = x;
      return () -> xFinal + iFinal;
    }
  }
  ```

  如果使用的是引用呢？我们把int改为Integer:  
  ```java
  public class Closure7{
    IntSuppUer makeFun(int x) {
      Integer i = 0;                // 完全OK，Integer是对象引用，没有变化，对象本身允许修改
      i = i + 1;
      return () -> x + i;
    }
  }
  ```

  ```java
  public class Closures {
    Supplier<List<Integer>> makeFun() {
      final List<Integer> ai = new ArrayListo();
      ai.add(l);
      return () -> ai;
    }
    public static void main(String[] args) {
      Closures c7 = new Closure8();
      List<Integer>
        11 = c7.makeFun().get(),
        12 = c7.makeFun().get();
      System.out.printin(11);
      Systern.out.println(12);
      11. add(42);
      12. add(96);
      System.out.println(11);
      System.out.println(12);
    }
  }
  ```
  ```java
  /*输出:
  [1]
  [1]
  [1, 42]
  [1, 96]
  */
  ```
  为每次调用makeFun()时，都会创建并返回一个全新的ArrayList——这意味着它没有被共享，所以每个生成的闭包都有自己独立的ArrayList,不会互相干扰  
  
  final关键字应用于对象引用，只是说这个对象引用不能被重新赋值，并不是说我们不能修改对象本身  
  只修改所指向的对象,Java会接受只要没有其他人得到对该对象的引用，这可能是安全的。否则就意味着有不止一个实体可以修改该对象，情况会变得非常混乱  

  这个规则并不是像说“任何在lambda表达式之外定义的变量都必须是最终变量或实际上的最终变量”那么简单。相反，我们必须从被捕获的变量是“实际上的最终变量”这个角度来考虑  

## 内部类作为闭包
  ```java
  public class AnonymousClosure {
    IntSupplier makeFun(int x) {
      int i = 0;
      //同幷的规则适用于：
      // i++; //并非"实际上的最终变量"
      // x++; // 同上
      return new IntSupplier() {
        public int getAsInt() ( return x + i; )
      }；
    }
  }
  ```
  结果证明，只要有内部类.就会有闭包(Java 8只是让闭包实现起来更容易了) 在Java 8之前，x和i必须显式地声明为最终变量  
  而到了 Java 8,内部类的规则也放宽了,可以包含“实际上的最终变量”  

# 函数组合
  支持函数组合的方法：  
  | 组合方法 | 支持的接口 |  
  | --- | --- |  
  | andThen(argument)先执行原始操作，再执行参数操作 | Function</br> BiFunction</br> Consumer</br> BiConsumer</br> IntConsumer</br> LongConsumer</br> DoubleConsumer</br> UnaryOperator</br> IntUnaryOperator</br> LongUnaryOperator</br> DoubleUnaryOperator</br> BinaryOperator |  
  | compose(argument)先执行参数操作.再执行原始操作 | Function UnaryOperator</br> IntUnaryOperator</br> LongUnaryOperator</br> DoubleUnaryOperator |  
  | and(argument)对原始谓词和参数谓词执行短路逻辑与(AND)计算 | Predicate</br> BiPredicate</br> IntPredicate</br> LongPredicate</br> DoublePredicate |  
  | or(argument)对原始谓词和参数谓词执行短路逻辑(OR)计算 | Predicate</br> BiPredicate</br> IntPredicate</br> LongPredicate</br> DoublePredicate |  
  | negate()所得谓词为该谓词的逻辑取反 | Predicate</br> BiPredicate</br> IntPredicate</br> LongPredicate</br> DoublePredicate |  

  ```java
  public class Functioncomposition {
    static Function<String, String>
      fl = s -> {
        System.out.println(s);
        return s.replace('A','_')；
      }，
      f2 = s -> s.substring(3),
      f3 = s -> s.toLowerCase(),
      f4 = f1.compose(f2).andThen(f3);
    public static void main(String[] args) {
      System.out.println(
        f4.apply("GO AFTER ALL AMBULANCES"));
    }
  }
  ```
  ```java
  /*输出：
  AFTER ALL AMBULANCES
  _fter_ll _mbul_nces
  */
  ```
  新函数F4,它几乎可以像任何其他函数一样使用apply()来调用  

# 柯里化和部分求值
  柯里化(Currying): 将一个接受多个参数的函数转变为一系列只接受一个参数的函数  
  ```java
  public class CurryingAndPartials {
    //未柯里化：
    static String uncurried(String a, String b) {
      return a + b;
    }
    public static void main(String[] args) {
      //村里化函数：
      Function<String, Function<String, String>> sum =
        a -> b -> a + b;                                  //[1]接受一个String,返回一个Function

      System.out.printin(uncurried("Hi ", "Ho"));

      Function<String, String>
        hi = sum.apply("Hi ");                            //[2]  
      System.out.printin(hi.apply("Ho"));
      
      //部分应用：
      Function<String, String> sumHi =               //将"Hup "作参数传给Function-sum，
        sum.apply("Hup ");                           //返回一Function<String, String>给sumHi
      System.out.println(sumHi.applyC'Ho"));
      System.out.printin(sumHi.apply("Hey"));
    }
  }
  ```
  ```java
  /*输出
  Hi Ho
  Hi Ho
  Hup Ho
  Hup Hey
  */
  ```
  1. [1]Function中有另一个Function作为其第二个参数
  2. [2]柯里化的目的是能够通过提供一个参数来创建一个新函数，所以我们现在有了一个“ 参数化函数”和剩下的“自由参数”

  多参数的函数逬行柯里化：  
  ```java
  Function<String,
    Function<String,
      Function<String, String>>> sum =
        a -> b -> c -> a + b + c;
  ```
  对于每一层级联箭头，我们都要在其类型声明外再包裹另一个Function。  

# 纯函数式编程
  让所有的内容都是final的，并确保所有的方法和函数都没有副作用  
  因为Java本质上并不是不可变语言，所以如果我们犯了错误，编译器是帮不上忙的  

  像Scala或Kotlin这样的语言也许更容易，因为它们天生就是为支持函数式编程而设计的  

  Java确实支持并行，但是如果并行是项目的核心部分，可以考虑至少在项目的一部分中使用Scala或Kotlin这样的语言  

# 总结
  lambda表达式和方法引用不是将Java变成函数式语言，而是提供了对函数式编程风格的更多支持  
  这是对Java的巨大改进，因为这样可以支持编写更简洁、更干净、更易懂的代码
  
