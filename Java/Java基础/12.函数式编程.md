函数式编程语言处理代码片段就像处理数据一样简单, 尽管Java并非函数式语言，  
但是Java 8的lambda表达式和方法引用允许我们以函数式风格编程  

函数式编程（functional programming, FP ）的意义所在：  
不是从零幵始编写大量代码，而是从现有的、可以理解的、经过良好测试的、可靠的小代码片段幵始。  
然后将它们组合在一起，创建新的代码  

面向对象编程抽象数据，而函数式编程抽象行为  

纯函数式语言规定了额外的约束条件，即所有的数据必须是不可变的：设置一次，永不改变。  
函数会接受值，然后产生新值, 但是绝对不会修改自身之的任何东西（包括其参数或该函数作用域之外的元素）

纯函数式语言经常被当作并行编程问题的解决方案: “不可变对象和无副作用”这一编程范式解决了并行编程（当程序的不同
部分同时在多个处理器上运行时）中最基本和最棘手的问题之----- “可变的共享状态”问题  

# 旧方式与新方式
  以前的做法是组合语法：创建一个对象，让它的一个方法包含所需行为，然后将这个对象传递给我们想控制的方法
  在Java 8之前,我们已经能够通过组合语法和匿名类传递功能  
  Java 8之后，方法引用和lambda表达式改变了这种状况，我们想传递功能的时候就可以传递  

# lambda 表达式
  lambda表达式是使用尽可能少的语法编写的函数定义  
  lambda表达式产生的是函数，而不是类 在Java虚拟机(JVM)上，一切都是类，所以幕后会有各种各样的操作.让lambda看起来像函数  

  任何lambda表达式的基本语法如下所示:  
  1. 参数
  2. 后面跟 ->，你可以将其读作“产生” (produces)；
  3.  -> 后面的都是方法体

  ---
  1. 只有一个参数，可以只写这个参数，不写括号 不过这是一种特殊情况
  2. 通常情况是用括号将参数包裹起来
  3. 在没有参数的情况下，必须使用括号来指示空的参数列表
  4. 在有多个参数的情况下，将它们放在使用括号包裹起来的参数列表内

  方法体是一行的：方法依中表达式的结果会自动成为lambda表达式的返回值，  
  这里使用return关键字是不合法的：这是lambda表达式简化描述功能的语法的又一种方式  

  如果lambda表达式需要多行代码，则必须将这些代玛行放为花括号中。这种情况下就需要使用return从lambda表达式生返回一个值了  

  在Java中也可以编写递归的lambda表达式，但是有一点要注意：  
  这个lambda表达式必须被赋值给一个静态变量或一个实例变星，否则会出现编译错误  
  ```java
  interface IntCall {
    int call(int arg);
  }

  public class RecursiveFactorial {
    static IntCall fact;
    public static void main(String[] args) {
      fact = n->n = 0 ? l ：n* fact.call (n - 1);
      for(int i = 0; i <= 10; i++)
        System.out.println(fact ・ call(i));
    }
  }
  ```
  请注意，不能在定义的时候像这样来初始化fact：  
  `static IntCall fact = n->n = 0 ? l ：n* fact.call (n - 1);`  
  尽管这样的期望非常合理，但是对于Java编译器而言处理起来太复杂了，所以会产生编译错误  
  > [IMPORTANT]
  > 必须先声明变量，之后才能初始化

# 方法引用
  Java 8方法引用指向的是方法，没有之前Java版本的历史包袱 方法引用是用类名或对象名，后面跟'::' ，然后跟方法名  
  ```java
  interface Callable {
    void call(String s);
  }
  class Describe {
    void show(String msg) (                    //[1]
      System.out.printIn(msg);
    }
  }
  public class MethodReferences {
    static void hello(String name) {
      System.out.printIn("Hello, " + name);
    }
    static class Description {
      String about;
      Description(String desc) { about = desc; }
      void help(String msg) {
        System.out.println(about + " " + msg);
      }
    }
    static class Helper {
      static void assist(String msg) {
        System.out.println(msg);
      }
    }
    public static void main(String[] args) {
      Describe d = new DescribeO;
      Callable c = d::show;                  //[2]
      c.call("call()");                      //[3]

      c = MethodReferences::hello;
      c.call("Bob");

      c = new Description("valuable")::help;    //[4]
      c.call("information");

      c = Helper::assist;
      c.call("Help!");
    }
  }
  ```
  ```java
  /*输出:
  call()
  Hello, Bob
  valuable information
  Help!
  */
  ```
  - [1]show()的签名(参数类型和返回类型)和Callable中call()的签名一致
  - [2]我们将Describe对象的一个方法引用赋值给了一个Callable, Callable中没有show()方法，  
    只有一个call()方法 然而，Java似乎对这种看似奇怪的赋值并没有意见，因为这个方法引用的签名和Callable中的call()方法一致  
  - [3]现在可以通过调用call()来调用show(),因为Java将call()映射到了 show()上
  - 实例方法引用：[4]这是[2]的另一个版本：对某个活跃对象上的方法的方法引用，有时叫作“绑定方法引用” (bound method reference )
  - 静态方法引用：对于static方法而言，引用该方法无需对象，只需ClassName::method

## Runnable
  Runnable接口在java.lang包中,所以不需要import。它也遵从特殊的单方法接口格式：  
  其run()方法没有参数，也没有返回值  
  ```java
  class Go {
    static void go() {
      System.out.printin("Go::go()");
    }
  }

  public class RunnableMethodReference {
    public static void main(String[] args) {
      new Thread(new Runnable() {                    //匿名类
        public void run() {
          System.out.println("Anonymous");
        }
      }).start();

      new Thread(
        ()-> System.out.printtn("lambda")            //lambda表达式
      ).start();

      new Thread(Go::go).start();                    //方法引用
    }
  }
  ```
  ```
  /*输出:
  Anonymous
  lambda
  Go::go()
  */
  ```
  Thread对象接受一个Runnable作为其构造器参数，它有一个start()方法会调用run()  
  示例代码中的3种情形，只有匿名内部类需要提供名为run()的方法  
  
  
# 未绑定方法引用
  未绑定方法引用(unbound method reference )指的是尚未关联到某个对象的普通(非静态)方法   
  对于未绑定引用，必须先提供对象.然后才能使用。（非static方法才需要先提供对象）  
  ```java
  class X {
    String f() { return "X::f()"; )
  }

  interface MakeString {
    String make();
  }

  interface TransformX {
    String transform(X x);                              //[1]
  }

  public class UnboundMethodReference {
    public static void main(String[] args) {
      // MakeString ms = X::f;                          //[2]
      TransformX sp = X::f;
      X x = new X();
      System.out.println(sp ・ transform(x));
      System.out.println(x.f()); // 效果相同
    }
  }
  ```
  ```java
  /*输出：
  X::f()
  X::f()
  */
  ```
  引用的方法，与其关联接口(方法引用所实现的接口)的签名是相同的  
  在[2]处，属于无效方法引(invalid method reference)：`X::f`代表的是一个未绑定方法引用，因为它没有“绑定到”某个对象  

  在[1]处, 在未绑定引用的情况下，函数式方法(接口中的单一方法)的签名与方法引用的签名不再完全匹配:  
  以X为参数在其上调用了 transform(),最终以某种方式调用了 x.f()  
  即：未绑定方法引用情况下，接口方法必须接受第一个参数（被规定的），事实上就是this,并在它的上面调用该方法  

  方法有更多参数，只要遵循第一个参数取的是this这种模式:  

# 构造器方法引用
  可以捕获对某个构造器的引用，之后通过该引用来调用那个构造器  
  ```java
  class Dog {
    String name;
    Dog() { name = "stray"; }
  }
  interface MakeNoArgs {
    Dog make();
  }

  public class CtorReference {
    public static void main(String[] args) {
      MakeNoArgs mna = Dog::new;
      Dog dn = mna.make();
    }
  }
  ```

# 函数式接口
  `x -> x.toString()`  
  为lambda表达式包含了某种形式的类型推断（编译器推断出类型的某些信息，而不需要程序员显式指定）  

  `(x, y) -> x + y`  
  x和y可以是支持'+'操作符的任何类型, 在lambda表达式被赋值之后，编译器就必须确定x和y的精确类型并生成正确的代码了  

  Java 8引入了包含一组接口的java.util.function,这些接口是lambda表达式和方法引用的目标类型  
  每个接口都只包含一个抽象方法，叫作函数式方法  
  “函数式方法”模式可以使用@FunctionalInterface注解来强制实施  
  ```java
  @FunctionalInterface
  interface Functional {
    String goodbye(String arg);
  }

  /*
  @FunctionalInterface
  interface NotFunctional {
    String goodbye(String arg);
    String hello(String arg);
  }
  产生报错信息：
  NotFunctional is not a functional interface
  multiple non-overriding abstract methods
  found in interface NotFunctional
  */

  public class FunctionalAnnotation {
    public String goodbye(String arg) {
      return "Goodbye, " + arg;
    }
    public static void main(String[] args) {
      FunctionalAnnotation fa = new FunctionalAnnotation();
      Functional f = fa::goodbye;
      // Functional fac = fa; // 不兼容
    }
  }
  ```
  @Functionallnteiface 注解是可选的  
  @FunctionalInterface的价值：如果接口中的方法多于一个,则会产生一条编译错误信息  
  
  如果我们将一个方法引用或lambda表达式赋值给某个函数式接口（而且类型可以匹配）,那么Java会调整这个赋值，  
  使其匹配目标接口。而在底层，Java编译器会创建一个实现了目标接口的类的实例，并将我们的方法引用或lambda表达式包裹在其中  

  使用了@FunctionalInteiface 注解的接口也叫作单一抽象方法（Single Abstract Method,SAM）类型  
  
  试图把FunctionalAnnotation直接赋值给一个Functional, Java是不允许的。这也符合我们的预期，因为它没有显式地实现Functional
  
  java.util.function旨在创建一套足够完备的目标接口，这样一般情况下我们就不需要定义自己的接口了  
  命名规则：  
  1. 如果接口只处理对象，而非基本类型，那就会用一个直截了当的名字，像Function、Consumer和Predicate等。参数类型会通过泛型添加
  2. 如果接口接受一个基本类型的参数，则会用名字的第一部分来表示，例如LongConsumer.DoubleFunction和 IntPredicate等接口类型。基本的 Supplier 类型是个例外。
  3. 如果接口返回的是基本类型的结果，则会用To来表示，例如ToLongFunction<T>和IntToLongFunction
  4. 如果接口返回的类型和参数类型相同，则会被命名为Opeiatoi。UnaryOperator用于表示一个参数，Binaryoperator用于表示两个参数
  5. 如果接口接受一个参数并返回boolean,则会被命名为Predicate
  6. 如果接口接受两个不同类型的参数，则名字中会有一个Bi （比如BiPredicate）

  | 特点 | 函数式方法 | 用法 |  
  | --- | --- | --- |  
  | 没有参数；没有返回值 | Runnable (java lang) run() | Runnable |  
  | 没有参数：可以返回任何类型 | Supplier get() getAstype() | Supplier<T> BooleanSupplier IntSupplier
LongSupplier DoubleSupplier |  
  | 没有参数；可以返回任何类型 | Callable (java.util concurrent) call() | Callable<V> |  
  | 一个参数；没有返回值 | Consumer accept() | Consumer<T> IntConsumer LongConsuner DoubleConsumer |  
  | 两个参数的Consumer | BiConsumer accept() | BiConsuroer<T,U> |  
  | 两个参数的 Consumer: 第一个参数是引用.第二个参数是基本类型 | ObjtypeConsumer accept() | ObjIntConsumercT> ObjLongConsuner<T> ObjDoubleConsumer<T> |  
  | 一个参数；返回値为不同类型 | Function apply() Totype & typeTotype: applyAstype() | Function<T,R> IntFunction<R> LongFunction<R> DoubleFunction<R> ToIntFunction<T> ToLongFunction<T> ToDoubleFunction<T>
IntToLongFunction IntToDoubleFunction LongToIntFunction LongToDoubleFunction DoubleToIntFunction DoubleToLongFunction |  
  | 一个参数；返回值为相同类型 | UnaryOperator apply() | UnaryOperator<T> IntUnaryOperator LongUnaryOperator DoubleUnaryOperator |  
  | 两个相同类型的参数；返回值也是相同类型 | BinaryOperator apply() | BinaryOperator<T> IntBinaryOperator
LongBinaryOperator DoubleBinaryOperator |  
  | 两个相同类型的参数；返回int | Comparator (java.util) compare() | Comparator<T> |  
  | 两个参数；返回boolean | Predicate test() | Predicate<T> BiPredicate<T,U> IntPredicate LongPiedicate DoublePredicate |  
  | 一个参数；基本类型的参数；返回值也是基本类型 | typeTotypeFunction applyAstype() | IntToLongFunction IntToDoubleFunction LongToIntFunction LongToDoubleFunction DoubleToIntFunction DoubleToLongFunction |  
  | 两个参数；不同类型 | Bi+操作名（方法名会変化） | BiFunction<T,U,R> BiConsuner<T,U> BiPredicate<T,U> ToIntBiFunction<T,U> ToLongBiFunction<T.U> ToDoubleBiFunction<T.U> |  
  表中的“type”会根据具体情况皆换为相应类型名  

  示例列举了可用于lambda表达式的所有不同的Function变种：  
  ```java
  class Foo {}
  class Bar {
    Foo f;
    Bar(Foo f) { this.f = f; )
  }
  class IBaz {
    int i;
    IBaz(int i) {
    this.i = i;
  }
  class LBaz {
    long I;
    LBaz(long I) {
      this.I = I;
    }
  }
  class DBaz {
    double d;
    DBaz(double d) {
      this.d = d;
    }
  }
  public class Functionvariants {
    static Function<Foo,Bar> fl = f -> new Bar(f);
    static IntFunction<IBaz> f2 = i -> new IBaz(i);
    static LongFunction<LBaz> f3 = l -> new LBaz(l);
    static DoubleFunction<DBaz> f4 = d -> new DBaz(d);
    static ToIntFunction<IBaz> f5 = ib -> lb.i;
    static ToLongFunction<LBaz> f6 = lb -> lb.l;
    static ToDoubleFunction<DBaz> f7 = db -> db.d;
    static IntToLongFunction f8 = i -> i;
    static IntToDoubleFunction f9 = i -> i;
    static LongToIntFunction fl0 = l -> (int)l;
    static LongToDoubleFunction fll = l -> l;
    static DoubleToIntFunction fl2 = d -> (int)d;
    static DoubleToLongFunction fl3 = d -> (long)d;

    public static void main(String[] args) {
      Bar b = fl.apply(new Foo());
      IBaz ib = f2.apply(ll);
      LBaz lb = f3.apply(ll);
      DBaz db = f4.apply(ll);
      int i = f5.applyAsInt(ib);
      long I = f6.applyAsLong(lb);
      double d = f7.applyAsDouble(db);
      l = f8.applyAsLong(12);
      d = f9.applyAsDouble(12);
      i = flO.applyAsInt(12);
      d = fll.applyAsDouble(12);
      i = fl2.applyAsInt(13.0);
      l = f13.applyAsLong(13.0);
    }
  }
  ```

  方法引用有自己的魔法:  
  查阅BiConsumei的文档，会看到它的函数式方法是accept()。确实，如果将我们的方法命名为accept()，它可以用作方法引用 但如果给它起个完全不同的名字，比如someOtherName(),只要参数类型和返回类型与BiConsumei的accept()相同，也是没问题的  
  要调用我们的方法，就要调用这个函数式方法的名字（在这个示例中是accept() ）,而不是我们的方法的名字  

  所有基于类的函数式接口:  
  ```java
  class AA {}
  class BB {)
  class CC {}

  public class ClassFunctionals {
    static AA fl() { return new AA(); }
    static int f2(AA aal, AA aa2) { return 1； }
    static void f3(AA aa) {}
    static void f4(AA aa, BB bb) {}
    static CC f5(AA aa) ( return new CC(); }
    static CC f6(AA aa, BB bb) ( return new CC(); }
    static boolean f7(AA aa) ( return true; }
    static boolean f8(AA aa, BB bb) ( return true; }
    static AA f9(AA aa) ( return new AA(); )
    static AA fl6(AA aal, AA aa2) { return new AA(); }
    public static void main(String!] args) {
      Supplier<AA> s = ClassFunctionals::fl;
      s.get();
      Comparator<AA> c = ClassFunctionals::f2;
      c.compare(new AA(), new AA())；
      Consumer<AA> cons = ClassFunctionals::f3;
      cons.accept(new AA());
      BiConsumer<AA,BB> bicons = ClassFunctionals::f4;
      bicons.accept(new AA(), new BB())；
      Function<AA,CC> f = ClassFunctionals::f5;
      CC cc = f.apply(new AA());
      BiFunction<AA,BB,CC> bif = ClassFunctionals::f6;
      cc = bif.apply(new AA(), new BB());
      Predicate<AA> p = ClassFunctionals::f7;
      boolean result = p.test(new AA());
      BiPredicate<AA,BB> bip = ClassFunctionals::f8;
      result = bip.test(new AA(), new B());
      UnaryOperator<AA> uo = ClassFunctionals::f9;
      AA aa = uo.apply(new AA());
      BinaryOperator<AA> bo = ClassFunctionals: :fl0;
      bo.apply(new AA(), new AA());
    }
  }
  ```
  一旦方法引用被赋值给某个函数式接口，只能调用与这个函数式接口关联的函数式方法（不能使用引用的方法名来调用）  
  
## 带有更多参数的函数式接口
  需要用于3个参数的函数接口呢？编写我们自己的接口也很容易：
  ```java
  @FunctionalInterface
    public interface TriFunction<T, U, V, R> (
      R apply(T t, U u, V v);
    }

  public class TriFunctionTest (
    static int f(int i, long l, double d) { return 99; }
    public static void main(String[] args) {
      TriFunction<Integer, Long, Double, Integer> tf = TriFunctionTest::f;
      tf = (i, l, d) -> 12;
    }
  }
  ```

## 解决缺乏基本类型函数式接口的问题
  看如何创建java.util.function中没有提供的，涉及int、long和double等基本类型的函数式接口:  
  ```java
  static BiConsumer<Integer, Long> bicil = (i, l) -> System.out.format("%d, %d%n", i, l);    //自定义函数式接口

  public class FunctionWithWrapped {
    public static void main(String[] args) {
      Function<Integer, Double> fid = i -> (double)i;
      IntToDoubleFunction fid2 = i -> i；
    }
  }
  ```
  直接编写Function<Integer,Double>就能得到可行的方案, ，存在函数式接口的基本类型变种的唯一原因，  
  就是防止在传递参数和返回结果时涉及自动装箱和自动拆箱。也就是说，为了性能  
  之所以有些函数式接口类型有定义，而有些没有，是根据预计的使用频率决定的  

# 高阶函数
  高阶函数只是一个能接受函数作为参数或能把函数当返回值的函数  
  ```java
  interface FuncSS extends Function<String, String> {}       // [1]

  public class ProduceFunction {
    static FuncSS produce() {
      return s -> s.toLowerCase();                           // [2]
      }
    public static void main(String[] args) {
      FuncSS f = produce()；
      System.out.println(f.apply("YELLING"));
    }
  }
  ```
  ```java
  /*
  yelling
  */
  ```
  1. 使用继承，可以轻松地为专门的接口创建一个别名
  2. 有了 lambda表达式，在方法中创建并返回一个函数简直不费吹灰之力

  要接受并使用函数，方法必须在其参数列表中正确地描述函数类型:  
  ```java
  public class ConsumeFunction {
    static Two consume(Function<One,Two> onetwo) {
      return onetwo.apply(new One());
    }
  }
  ```

  ```java
  class I {
    @Override public String toString() ( return "I"; )
  }
  class O {
    @Override public String toString() { return "O"; }
  }

  public class TransformFunction {
    static Function<I,O> transform(Function<I,O> in) {  //4.in即是新建的O()
      return in.andThen(o -> {                          //5.in.andThen()：先执行in的调用，再执行andThen()中的调用
        System.out.println(o);                          //5.返回一个函数
        return o;                                       
      })；
    }
    public static void main(String[] args) {
      Function<I,O> f2 = transform(i -> {         //2.i即是新建的I()
        System.out.println(i);
        return new O();                           //3.返回新建的O()，传递给transform的in
      })；
      O o = f2.apply(new I());                    //1.新建了I()，传递给f2-lambda表达式的i
  ```
  ```java
  /*
  I
  O
  */
  ```
  Function接口中的一个叫作andThen()的默认(default)方法，该方法是专门为操作函数而设计, andThen()会在in函数调用之后调用  
  要附加上一个andThen()函数，只需要将该函数作为参数传递  
  还有compose()方法，它会在in函数之前应用新函数。  
  
# 闭包
  闭包(closure):可以使用其函数作用域之外的变量，闭包也称：支持词法作用域(lexically scoped) 
  闭包非常重要，因为它们使生成函数变简单了  
  --是否闭包主要体现在变量捕获(variable capture) 

  












