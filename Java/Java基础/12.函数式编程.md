函数式编程语言处理代码片段就像处理数据一样简单, 尽管Java并非函数式语言，  
但是Java 8的lambda表达式和方法引用允许我们以函数式风格编程  

函数式编程（functional programming, FP ）的意义所在：  
不是从零幵始编写大量代码，而是从现有的、可以理解的、经过良好测试的、可靠的小代码片段幵始。  
然后将它们组合在一起，创建新的代码  

面向对象编程抽象数据，而函数式编程抽象行为  

纯函数式语言规定了额外的约束条件，即所有的数据必须是不可变的：设置一次，永不改变。  
函数会接受值，然后产生新值, 但是绝对不会修改自身之的任何东西（包括其参数或该函数作用域之外的元素）

纯函数式语言经常被当作并行编程问题的解决方案: “不可变对象和无副作用”这一编程范式解决了并行编程（当程序的不同
部分同时在多个处理器上运行时）中最基本和最棘手的问题之----- “可变的共享状态”问题  

# 旧方式与新方式
  以前的做法是组合语法：创建一个对象，让它的一个方法包含所需行为，然后将这个对象传递给我们想控制的方法
  在Java 8之前,我们已经能够通过组合语法和匿名类传递功能  
  Java 8之后，方法引用和lambda表达式改变了这种状况，我们想传递功能的时候就可以传递  

# lambda 表达式
  lambda表达式是使用尽可能少的语法编写的函数定义  
  lambda表达式产生的是函数，而不是类 在Java虚拟机(JVM)上，一切都是类，所以幕后会有各种各样的操作.让lambda看起来像函数  

  任何lambda表达式的基本语法如下所示:  
  1. 参数
  2. 后面跟 ->，你可以将其读作“产生” (produces)；
  3.  -> 后面的都是方法体

  ---
  1. 只有一个参数，可以只写这个参数，不写括号 不过这是一种特殊情况
  2. 通常情况是用括号将参数包裹起来
  3. 在没有参数的情况下，必须使用括号来指示空的参数列表
  4. 在有多个参数的情况下，将它们放在使用括号包裹起来的参数列表内

  方法体是一行的：方法依中表达式的结果会自动成为lambda表达式的返回值，  
  这里使用return关键字是不合法的：这是lambda表达式简化描述功能的语法的又一种方式  

  如果lambda表达式需要多行代码，则必须将这些代玛行放为花括号中。这种情况下就需要使用return从lambda表达式生返回一个值了  

  在Java中也可以编写递归的lambda表达式，但是有一点要注意：  
  这个lambda表达式必须被赋值给一个静态变量或一个实例变星，否则会出现编译错误  
  ```java
  interface IntCall {
    int call(int arg);
  }

  public class RecursiveFactorial {
    static IntCall fact;
    public static void main(String[] args) {
      fact = n->n = 0 ? l ：n* fact.call (n - 1);
      for(int i = 0; i <= 10; i++)
        System.out.println(fact ・ call(i));
    }
  }
  ```
  请注意，不能在定义的时候像这样来初始化fact：  
  `static IntCall fact = n->n = 0 ? l ：n* fact.call (n - 1);`  
  尽管这样的期望非常合理，但是对于Java编译器而言处理起来太复杂了，所以会产生编译错误  
  > [IMPORTANT]
  > 必须先声明变量，之后才能初始化

# 方法引用
  Java 8方法引用指向的是方法，没有之前Java版本的历史包袱 方法引用是用类名或对象名，后面跟'::' ，然后跟方法名  
  ```java
  interface Callable {
    void call(String s);
  }
  class Describe {
    void show(String msg) (                    //[1]
      System.out.printIn(msg);
    }
  }
  public class MethodReferences {
    static void hello(String name) {
      System.out.printIn("Hello, " + name);
    }
    static class Description {
      String about;
      Description(String desc) { about = desc; }
      void help(String msg) {
        System.out.println(about + " " + msg);
      }
    }
    static class Helper {
      static void assist(String msg) {
        System.out.println(msg);
      }
    }
    public static void main(String[] args) {
      Describe d = new DescribeO;
      Callable c = d::show;                  //[2]
      c.call("call()");                      //[3]

      c = MethodReferences::hello;
      c.call("Bob");

      c = new Description("valuable")::help;    //[4]
      c.call("information");

      c = Helper::assist;
      c.call("Help!");
    }
  }
  ```
  ```java
  /*输出:
  call()
  Hello, Bob
  valuable information
  Help!
  */
  ```
  - [1]show()的签名(参数类型和返回类型)和Callable中call()的签名一致
  - [2]我们将Describe对象的一个方法引用赋值给了一个Callable, Callable中没有show()方法，  
    只有一个call()方法 然而，Java似乎对这种看似奇怪的赋值并没有意见，因为这个方法引用的签名和Callable中的call()方法一致  
  - [3]现在可以通过调用call()来调用show(),因为Java将call()映射到了 show()上
  - 实例方法引用：[4]这是[2]的另一个版本：对某个活跃对象上的方法的方法引用，有时叫作“绑定方法引用” (bound method reference )
  - 静态方法引用：对于static方法而言，引用该方法无需对象，只需ClassName::method

## Runnable
  Runnable接口在java.lang包中,所以不需要import。它也遵从特殊的单方法接口格式：  
  其run()方法没有参数，也没有返回值  
  ```java
  class Go {
    static void go() {
      System.out.printin("Go::go()");
    }
  }

  public class RunnableMethodReference {
    public static void main(String[] args) {
      new Thread(new Runnable() {                    //匿名类
        public void run() {
          System.out.println("Anonymous");
        }
      }).start();

      new Thread(
        ()-> System.out.printtn("lambda")            //lambda表达式
      ).start();

      new Thread(Go::go).start();                    //方法引用
    }
  }
  ```
  ```
  /*输出:
  Anonymous
  lambda
  Go::go()
  */
  ```
  Thread对象接受一个Runnable作为其构造器参数，它有一个start()方法会调用run()  
  示例代码中的3种情形，只有匿名内部类需要提供名为run()的方法  
  
  
# 未绑定方法引用
  未绑定方法引用(unbound method reference )指的是尚未关联到某个对象的普通(非静态)方法   
  对于未绑定引用，必须先提供对象.然后才能使用。（非static方法才需要先提供对象）  
  ```java
  class X {
    String f() { return "X::f()"; )
  }

  interface MakeString {
    String make();
  }

  interface TransformX {
    String transform(X x);
  }

  public class UnboundMethodReference {
    public static void main(String[] args) {
      // MakeString ms = X::f;
      TransformX sp = X::f;
      X x = new X();
      System.out.println(sp ・ transform(x));
      System.out.println(x.f()); // 效果相同
    }
  }
  ```
  
  














