# 几乎所有操作符只能操作基本类型，例外的是“ = 、 == 和 != ”也能操作对象

# 赋值（左值=右值）
  - 对基本类型：右值是实际内存内容
  - 对对象：右值是引用（内存地址）

  对象1 = 对象2，对象1也指向了对象2所指的对象，而非复制了对象2  
  ```java
  f(y){         //传递了引用，方法修改了作用域之外的对象
  ...
  }
  ```

# ++/-- 前缀与后缀区别
  - 前缀：先执行运算，再返回值
  - 后缀：先返回值，再执行运算

  ```java
  int i = 1;
  print( i++ );           //输出 1
  print( i );             //输出 2
  ```

# == 和 != 在对象上的结果
  | Java语句 | t1==t2 && -128<=v<=127 | t1.equals(t2) && -128<=v<=127 | t1==t2 && (v<-128 \|\| v>127) | t1.equals(t2) && (v<-128 \|\| v>127) |  
  | --- | --- | --- | --- | --- |  
  | Integer t1 = v;<br/> Integer t2 = v; | true | true | false | true |  
  | Integer t1 = new Integer(v);<br/> Integer t2 = new Integer(v); | false | true | false | true |  
  | Integer t1 = Integer.valueOf(v);<br/> Integer t2 = Integer.valueOf(v); | true | true | false | true |  
  | int t1 = v;<br/> int t2 = v; | true | | true | |  

  - `Integer t1 = v;`："自动装箱"转换为Integer。底层其实是通过对Integer.valueOf()的调用来完成的  
    `int t = t1`：“自动拆箱”转换为int。底层其实是通过对Integer.intValue()的调用来完成的
  - Integer会通过享元模式来緩存范围在-128到127内的对象，因此调用-128<=v<=127的Integer.valueOf(v)返回的都是同一个对象  
    v<-128 \|\| v>127 的Integer.valueOf(v)返回的都是调用new Integer(v)得到的新对象

  ------------------
  - “==”操作符可以使用在基本类型和引用类型中
  - 如果比较的是基本类型变量：比较两个变量保存的数据是否相等。  
    （比较基本类型，"=="左右两边的变量类型不一定要相同）
  - 如果比较的是引用类型变量：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体  
    （比较引用类型，"=="左右两边的变量类型必须相同）
  ------------------
  - equals()是方法，而非运算符，只能适用于引用类型  
    equals()的两个变量的类型必须相同
  - 默认情况下，equals()方法比较的是对象的引用地址，即是否是同一个对象。
  - 要实现对象内容的比较，需要对equals()方法进行重写。
  - String、Date、File、包装类WrapperClass（Boolean/Character/Integer/Short/Byte/Long/Float/Double）等都【重写】了Object类中的equals()方法。

# 字面量：进制标识符/类型标识符
  | 进制 | 标识符 | 示例 |  
  | --- | --- | --- |  
  | 十六进制 | 0X/0x | 0x2f |  
  | 八进制 | 0 | 0177 |  
  | 二进制 | 0B/0b | 0b0010|  

  | 类型 | 标识符 | 示例 |  
  | --- | --- | --- |  
  | long | L/l | 200L |  
  | float | F/f | 200F |  
  | double | D/d | 200D |  

  数字字面量可使用下划线：  
  1. 不能连续多个下划线
  2. 数字开头结尾不能有下划线
  3. L/F/D后缀的左右不能有下划线     例：341_435F
  4. X/B进制标识符左右不能有下划线   例：0x7f_e9_b7

  System.out.println()           //使用\n标识换行符  
  System.out.printf()/format()   //使用%n标识换行符（格式标准化：实现平台移植）  

# 位操作符
  | 操作 | 二进制补码（计算机实际存储） | 原码 |  
  |  --- | --- | --- |  
  | i = -1; | 11111111 11111111 11111111 11111111 | 10000000 00000000 00000000 00000001 |  
  | j = 1; | 00000000 00000000 00000000 00000001 | 正数原码与补码一致 |  
  | 2^31-1 | 01111111 11111111 11111111 11111111 | 正数原码与补码一致 |  
  | -2^31 | 10000000 00000000 00000000 00000000 | 1 10000000 00000000 00000000 00000000 (原码至少33位，无法用32位表示) |  
  | i^j | 11111111 11111111 11111111 11111110 | |  
  | i<<5 | 11111111 11111111 11111111 11100000 | |  
  | i>>5 | 11111111 11111111 11111111 11111111 | |  
  | i>>>5 | 00000111 11111111 11111111 11111111 | |  

  为什么8位补码范围-2^7 ~ 2^7-1, 原码-(2^7-1) ~ 2^7-1 ?  
  为什么补码比原码多表示一个数：-2^7 ?  
  16位Short/32位Integer/64位Long 与8位Byte是一样的情况。  
  
  - 原码中有2个0，   +0：0000 0000，  -0：1000 0000
  - -0的补码：1 0000 0000 溢出，所以补码中舍去-0，并将补码：1000 0000 定义为-2^7 (原码至少9位，无法用8位表示)
  --------------------
## 为什么能将补码中的-0舍去并定义 1000... 为-2^n (n为符号位在字节中的位序)
  > [!IMPORTANT]
  > PS：字节的最低位是第0位，位序向字节高位逐位增加  
 
  因为可以向上完美兼容，类型转换时开销小。同时，符号位在单个特殊情况下作数据位不与其他补码的值起冲突。  
  - 补码：1000 0000 定义为-2^7 也向上兼容16位补码。
  - -2^7的16位补码为 11111111 10000000，所以-2^7的8位补码转16位补码时，在8位补码的高位添加8个1即可。
  --------------------
  - 看补码比大小（直观比较，直观得值）：
  - 将补码作为数轴刻度，符号位1代表负数符号‘-’，符号位0代表负数符号‘+’
  - 符号位1的补码排补码0的左边，符号位0的补码排补码0的右边，左右半轴各根据除去符号位的绝对值升序排列
  - 补码所在数轴位置越左，补码的数值越小； 补码所在数轴位置越右，补码的数值越大
  - 数轴：1_000 ——1_100——1_101——1_111     ——0_000——————0_111
  - 数值：-8　————　-4 ——— -3　——　-1 —————— 0 —————————　+7
    
  如何快速得出补码1101的值？
  - 补码转原码计算：符号位不参与计算，补码数据位按位取反得 中间码（不是补码），中间码+1得 原码  
    原码转补码计算：符号位不参与计算，原码数据位按位取反得 反码，反码+1得 补码  
    补码和原码的相互转换：符号位不参与计算，数据位按位取反后，+1
    
  - 快速判断补码1100的值，最低位的1在第2位，则补码1100的值是-2^2，  
    101在数轴上100的右边+1位置，所以补码1101的值比补码1100的值大1，所以补码1101的值为-4+1=-3
    
  - 设n位（n为符号位在字节中的位序）补码，符号位不参与计算  
    运用公式：补码 + 补码取反 + 1 = 2^n（101 + 010 + 1 = 1000），补码取反 + 1 = 原码，所以  
    补码 + 原码 = 2^n  
    (101)<sub>2</sub> = 5, 则不计符号位原码的值 = 2^3 - 5 = 3, 补码1101的值为 -3
