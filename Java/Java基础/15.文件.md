Java 7带来了巨大的改逬，似乎设计者们终于听到了用户多年来的呼声。  
这些新元素被打包放在了 java.nio.file之下，其中nio中的n以前是指“new”（新的），现在是指“non-blocking” （非阻塞）,io 是指 “input/output"（输入 / 输出）  
java.nio.file库最终将Java的文件操作提升到了可以与其他编程语言媲美的程度  

# 文件和目录路径
  Path对象代表的是一个文件或目录的路径，它是在不同的操作系统和文件系统之上的抽象  
  java.nio.file.Paths类包含了重载的static get()方法，可以接受一个String序列.或一个统一资源标识符(Uniform Resource Identifier, URI),然后将其转化为一个Path对象:  
  ```java
  import java.nio.file.*;
  import java.net.URI;
  import java.io.File;
  import java.io.lOException;

  public class Pathinfo {
    static void show(String id, Object p) {
      System.out.printIn(id + p);
    }
    static void info(Path p) {
      show("toString:\n ", p);
      show("Exists: ", Files.exists(p));
      show("RegularFile: ", Files.isRegularFile(p));
      show("Directory： ", Files.isDirectory(p));
      show("Absolute: ", p.isAbsoluteO);
      show("FileName: ", p.getFileNameO);
      show("Parent: ", p.getParent());
      show("Root: ", p.getRoot());
      System, out. printin("************");
    }
    public static void main(String[] args) {
      System.out.println(System.getProperty( "os.name"));
      info(Paths.get(
        "C:", "path", "to", "nowhere", "NoFile.txt"));
      Path p = Paths.get("Pathinfo.java");
      try {
        info(p.toRealPath());
      } catch(lOException e) {
        System.out.println(e);
      }
      URI u = p.toUri();
      System.out.println("URI:\n" + u);
      Path puri = Paths.get(u);
      System.out.println(Files.exists(puri));
      File f = ap.toFileO; // 不要被骗了
    }
  }
  ```
  ```java
  /*输出:
  Windows 10
  toString:
  C:\path\to\nowhere\NoFile.txt
  Exists: false
  RegularFile: false
  Directory: false
  Absolute: true
  FileName: NoFile.txt
  Parent: C:\path\to\nowhere
  Root: C:\
  ******************
  toString:
  C: \Git\0nJava8\ExtractedExamples\files\PathInfo.java
  Exists: true
  RegularFile: true
  Directory: false
  Absolute: true
  FileName: Pathinfo.java
  Parent: C:\Git\0nJava8\ExtractedExamples\files
  Root: C:\
  ******************
  URI:
  file: ///C :/Git/0nJava8/ExtractedExamples/files/PathInfo.java
  true
  */
  ```
  - System.getProperty( "os.name")返回操作系统的名称
  - getFileName()总是会生成文件的名字
  - 使用Files工具类,我们可以测试文件是否存在，为否为“普通”文件，是否为目录,等等
  - 文档中对“真实”路径的定义有点模糊.因为它取决于特定的文件系统，例如.如果文件名的比较不区分大小写，即使路径因为大小写的原因看起来不是完全一样.匹配也会成功
  - URI可以用来描述大多数事物.不仅限于文件
  - toFile():在旧世界里，File实际上意味着一个文件或一个目录————听起来它应该被称为“路径”(path)。这个命名非常草率，也令人困惑，但现在忽略它也没什么问题，因为java.nio.file已经存在

## 选择Path的片段
  ```java
  public class PartsOfPaths {
    public static void main(String(] args){
      System.out.printin(System.getProperty("os.name"));
      Path p =
        Paths.get("PartsOfPaths.java").toAbsolutePath();
      for(int i = 0; i < p.getNameCount(); i++)
        System.out.printin(p.getName(i));
      System.out.println("ends with '.java': " +
        p.endsWith(".java"));
      for(Path pp : p) {
        System.out.print(pp + ":");
        System.out.print(p.startsWith(pp) + ":")；
        System.out.println(p.endsWith(pp))；
      }
      System.out.println("Starts with " + p.getRoot() +
        " "+ p.startsWith(p.getRoot()));
    }
  }
  ```
  ```java
  /*输出：
  Windows 10
  Git
  0nJava8
  ExtractedExampl.es
  files
  PartsOfPaths.java
  ends with '.java': false
  Git: false : false
  0nJava8: false : false
  ExtractedExamples: false : false
  files: false : false
  PartsOfPaths.java: false : true
  Starts with C:\ true
  */
  ```
  - 在getNameCount()界定的上限之内，我们可以结合索引使用getName(),得到一个Path的各个部分
  - Path也可以生成Iterator,所以我们也可以使用for-in来遍历
  - 路径确实是以.java结尾的，但endsWith()的结果是false。这是因为endsWith()比较的是整个路径组件,而不是名字中的一个子串
  - getNameCount()和for-in在对Path进行遍历，并没有包含根目录

## 分析Path
  Files工具类中包含了一整套用于检查Path的各种信息的方法：  
  ```java
  import java.nio.file.*;
  import java.io.lOException;

  public class PathAnalysis {
    static void say(String id, Object result) {
      System.out.print(id + ":");
      System.out.printIn(result);
    }
    public static void main(String[] args) throws lOException {
      System. out. printin(System. getProperty("os. name"));
      Path p =
        Paths.get("PathAnalysis.java").toAbsolutePath();
      say("Exists", Files.exists(p));
      say("Directory", Files.isDirectory(p));
      say("Executable", Files.isExecutable(p));
      say("Readable", Files.isReadable(p));
      say("RegularFile", Files.isRegularFile(p));
      say("Writable", Files.isWritable(p));
      say("notExists", Files.notExists(p));
      say("Hidden", Files.isHidden(p));
      say("size", Files.size(p));
      say("Filestore", Files.getFileStore(p));
      say("LastModified： ", Files.getLastModifiedTime(p));
      say("Owner", Files.getOwner(p));
      say( "ContentType", Files.probeContentType(p));
      say("SymbolicLink", Files.isSymbolicLink(p));
      if(Files.isSymbolicLink(p))
        say("SymbolicLink", Files.readSymbolicLink(p));
      if(FileSystems.getDefault()
        .supportedFileAttributeViews().contains("posix"))
      say("PosixFilePermissions",
        Files, getPosixFilePermissions (p));
    }
  }
  ```
  ```java
  /*输出：
  Windows 10
  Exists: true
  Directory: false
  Executable: true
  Readable: true
  RegularFile: true
  Writable: true
  notExists: false
  Hidden: false
  size: 1617
  Filestore: (C:)
  LastModified::
  2021-11-08T00:34:52.693768Z
  Owner: GR00T\Bruce (User)
  ContentType: text/plain
  SymbolicLink: false
  */
  ```

## 添加或删除路径片段
  要去掉Path这个基准路径,应该使用relativize()  
  要在一个Path对象的后面增加路径片段.则应该使用resolve()  
  ```java
  public class AddAndSubtractPaths {
    static Path base = Paths.get("..", "..", "..");
      .toAbsolutePath()
      .normalize();
    static void show(int id, Path result) {
      if(result.isAbsolute())
        System.out.println("(" + id + ")r " +
          base.relativize(result));
      else
        System.out.println("(" + id + ") " + result);
        try {
          System.out.println("RealPath:"
            + result.toRealPath());
        } catch(lOException e) {
          System.out.println(e);
        }
      }
    public static void main(String[] args) {
      System.out.println(System.getProperty("os.name"));
      System.out.println(base);
      Path p = Paths.get("AddAndSubt ractPaths.java")
        .toAbsolutePath();
      show(1, p);

      Path p5 = Paths.get("").toAbsolutePath();
      show(10, p5.resolveSibling("strings"));
    }
  }
  ```
  ```java
  /*输出:
  Windov/s 10
  C:\Git
  (1)r 0nJava8\ExtractedExamples\files\AddAndSubtractPaths. java
  RealPath:
  C: \Git\0nJava8\ExtractedExamples\files\AddAndSubtractPaths .java
  
  (10) r 0nJava8\ExtractedExampl.es\strings
  RealPath: C: \Git\0nJava8\ExtractedExamples\strings
  */
  ```

# 目录
  Files工具类包含了操作目录和文件所需的大部分操作。然而由于某些原因，其中并没有包括用于删除目录树的工具，所以我们会创建一个  
  ```java
  import java.nio.file.*;
  import java.nio.file.attribute.BasicFileAttributes;
  import java.io.lOException;

  public class RmDir {
    public static void rmdir(Path dir)
    throws IOException {
      Files.walkFileTree(dir,
        new SimpleFileVisitor<Path>() {
        @Override public FileVisitResult
        visitFile(Path file, BasicFileAttributes attrs)
        throws IOException {
          Files.delete(file);
          return FileVisitResult.CONTINUE;
        }
        @Override public FileVisitResult
        postVisitDirectory(Path dir, IOException exc)
        throws lOException {
          Files.delete(dir);
          return FileVisitResult.CONTINUE;
        }
      });
    }
  }
  ```
  - 这依赖于Files.walkFileTree(),这里“walk”的意思是查找每个子目录和文件，也就是遍历

  访问者（Visitor）设计模式提供了一个访问集合中的每个对象的标准机制，我们需要提供想在每个对象上执行的动作  
  这个动作取决于我们如何实现FileVisitor参数，其中包括如下方法:  
  - preVisitDirectory()：先在当前目录上运行，然后逬入这个目录下的文件和目录
  - visitFile()：在这个目录下的每个文件上运行
  - visitFileFailed()：当文件无法访问时调用
  - postVisitDirectory()：先进入当前目录下的文件和目录（包括所有的子目录），最后在当前目录上运行

  为了让事情更简单，java.nio.file.SmpleFileVisitor为所有这些方法提供了默认的定义(可重写)  
  这两个方法的返回标志:FileVisitResult.CONTINUE, 都表示应该继续遍历（直到找到我们要找的东西为止）  

  ```java
  public class Directories {
    static Path test = Paths.get("test");
    static String sep =
      FileSystems.getDefault().getSeparator();
    static List<String> parts =
      Arrays.asList("foo", "bar", "baz", "bag");
    static Path makeVariant() {
      Collections.rotate(parts, 1);
      return Paths.get("test", String.join(sep, parts));
    }
    static void refreshTestDir() throws Exception {
      if(Files.exists(test))
        RmDir.rmdir(test);
      if(!Files.exists(test))
        Files.createDirectory(test);
    }
    static void populateTestDir() throws Exception {
      for(int i = 0; i < parts.sizeO; i++) {
          Path variant = makeVariant();
          if(!Files.exists(variant)) {
            Files.createDirectories(variant);
            Files.copy(Paths.get("Di rectories.java"),
            variant.resolve("File.txt"));
            Files.createTempFile(variant, null, null);
          }
      }
    }
    public static void main(String[] args) throws Exception {
      refreshTestDir();
      Files.createFile(test.resolve ("Hello.txt");
      Path variant = makeVariant();
      //抛出异常(层次太多了)：
      try {
        Files.createDirectory(variant);
      } catch(Exceptior)e) {
        System.out.println("Nope, that doesn't work.");
      }
      populateTestDir();
      Path tempdir =
        Files.createTempDirectory(test, "DIR_");
      Files.createTempFile(tempdir, "pre", ".non");
      Files.newDirectoryStream(test)
        .forEach(System.out::println);
      System. out .printin("**********");
      Files .walk(test).forEach(System.out::printin);
    }
  }
  ```
  ```java
  /*输出：
  Nope, that doesn't work.
  test\bag
  test\bar
  test\baz
  test\DIR_8683707748599240459
  test\foo
  test\Hello.txt
  *********
  test
  test\bag
  test\bag\foo
  test\bag\foo\bar
  test\bag\foo\bar\baz
  test\bag\foo\bar\baz\4316127347949967230.tmp
  test\bag\foo\bar\baz\File.txt
  test\bar
  test\bar\baz
  test\bar\baz\bag
  test\bar\baz\bag\foo
  test\bar\baz\bag\foo\1223263495976065729.tmp
  test\bar\baz\bag\foo\File.txt
  test\baz
  test\baz\bag
  test\baz\bag\foo
  test\baz\bag\foo\bar
  test\baz\bag\foo\bar\6666183168609O95028.tmp
  test\baz\bag\foo\bar\File.txt
  test\DIR_8683707748599240459
  test\DIR_868370774859924O459\pre63666268O4787365549.non
  test\foo
  test\foo\bar
  test\foo\bar\baz
  test\foo\bar\baz\bag
  test\foo\bar\baz\bag\4712324129eil589115.tmp
  test\foo\bar\baz\bag\File.txt
  test\Hello.txt
  */
  ```
  - 如果我们对一个已经存在的目录调用了createDirectory(),则会产生异常
  - createFile()用参数Path创建了一个空文件，resolve()将文件名添加到了test这个Path的末尾
  - 用createDirectory()来创建一个不止一层的路径，会抛出了一个异常，因为这个方法只能创建单层目录
  - 使用createDirectories()创建了完整的目录路径
  - createTempDirectory()只有一个名字前缀选项，这点和createTempFile()不同，后者可以同时指定名字的前缀和后缀
  - createTempFile()如果没有指定后缀，所生成的文件会自动带上".tmp” 后缀
  - Files.newDirectoryStream(test)中只有test目录下的内容,耍获得包含整个目录树内容的流,请使用Files.walk()

# 文件系统
  用静态的FileSystems工具来获得“默认”的文件系统  
  ```java
  public class FileSystemDemo {
    static void show(String id, Object o) {
      System.out.println(id + ": " + o);
    }
    public static void main(String[] args) {
      System.out.printin(System.getProperty("os.name"));
      FileSystem fsys = FileSystems.getDefault();
      for(Filestore fs : fsys.getFileStores())
        showCFile Store", fs);
      for(Path rd : fsys.getRootDirectories())
        show("Root Directory", rd);
      show("Separator", fsys.getSeparator());
      show("UserPrincipalLookupservice",
        fsys.getUserPrincipalLookupService());
      show("isOpen", fsys.isOpen());
      show("isReadOnly", fsys.isReadOnly());
      show("FileSystemProvider", fsys.provider());
      show("File Attribute Views",
        fsys.supportedFileAttributeViews());
    }
  }
  ```
  ```java
  /*输出：
  Windows 10
  File Store: (C:)
  File Store: System Reserved (E:)
  File Store: (F:)
  File Store: Google Drive (G:)
  Root Directory: C:\
  Root Directory: D:\
  Root Directory: E:\
  Root Directory: F:\
  Root Directory: G:\
  Separator: \
  UserPrincipalLookupService:
  sun. nio. fs .WindowsFileSystem$LookupService$l@lbd4fdd
  isOpen: true
  isReadOnly: false
  FileSystemProvider:
  sun.nio.fs.WindowsFileSystemProvider@55183b20
  File Attribute Views: [owner, dos, acl, basic, user]
  */
  ```

# 监听 Path
  ```java
  import java.io.IOException;
  import java.nio.file.*;
  import static java.nio.file.StandardWatchEventKinds.*;
  import java.util.concurrent.*;

  public class PathWatcher {
    static Path test = Paths.get("test");
    static void delTxtFiles() {
      try {
        Files.walk(test)
          .filter(f ->
            f.toString() .endsWith(".txt"))
          .forEach(f -> {
            try {
              System.out.println("deleting " + f)；
              Files.delete(f);
            } catch(lOException e) {
              throw new RuntimeException(e)
            }
          });
      } catch(lOException e) {
        throw new RuntimeException(e);
      }
    }
    public static void main(String[] args) throws Exception {
      Directories.refreshTestDir();
      Directories.populateTestDir();
      Files .createFile(test.resolve("Hello, txt"));
      WatchService watcher =
        FileSystems. getDefault(). newWatchService();
      test.register(watcher, ENTRY_DELETE);
      Executors.newSingleThreadScheduledExecutor()
        .schedule(
          PathWatcher::delTxtFiles,
          250, TimeUnit.MILLISECONDS);
      WatchKey key = watcher.take();
      for(WatchEvent evt : key.pollEvents()) {
        System.out.println(
          "evt.context(): " + evt.context() +
          "\nevt.count(): " + evt.count() +
          "\nevt.kind(): " + evt.kind() );
        System.exit(0);
      }
    }
  }
  ```
  ```java
  /*输出：
  deleting test\bag\foo\bar\baz\File.txt
  deleting test\bar\baz\bag\foo\File.txt
  deleting test\baz\bag\foo\bar\File.txt
  deleting test\foo\bar\baz\bag\File.txt
  deleting test\HeUo.txt
  evt.contextO: Hello.txt
  evt.countO: 1
  evt.kindO： ENTRY_DELETE
  */
  ```
  - delTxtFiles()中的tiy块看上去是冗余的.因为它们都在捕捉相同类型的异常。所以似乎有外部的tiy就足够了。然而，由于某些原因(可能是个bug ). Java要求两者都存在
  - 在filter()中,必须显式地调用f.toString(),否则endsWith()会比较整个Path对象，而不是其用字符串表示的名字部分
  - 通过调用Executors.newSingleThreadScheduledExecutor()获得一个ScheduledExecutorService,然后调用schedule(),将所需函数的方法引用以及运行之前应该等待的时间交给它
  - watcher.take(),主线程会在这里等待。当有符合我们目标模式的事情发生时，会返回一个包含WatchEvent的WatchKey。

  一旦从FileSystem得到一个WatchService,我们就将它和由我们感兴趣的事件组成的可变参数列表一起注册给test这个Path。  
  感兴趣的事件可以从ENTRY_CREATE、ENTRY_DELETE或ENTRY_MODIFY中选择(创建和删除不属于修改)  

  在Hello.txt被删除之前，WatchService不会触发。它只监听这个目录，而不是它下面的一切  
  如果想监听整个目录树，则必须在整个树的每个子目录上设置一个WatchService  
  ```java
  import java.io.lOException;
  import java.nio.file.*;
  import static java.nio.file.StandardWatchEventKinds.*;
  import java.util.concurrent.*;

  public class TreeWatcher {
    static void watchDir(Path dir) (
    try {
      WatchService watcher =
        FileSystems.getDefault().newWatchService();
      dir.register(watcher, ENTRYDELETE);
      Executors.newSingleThreadExecutor().submit(() -> {
        try {
          WatchKey key = watcher.takeO;
          for(WatchEvent evt : key.pollEvents()) {
            System.out.println(
              "evt.context() : " + evt.context() +
              "\nevt.count(): " + evt.count() +
              "\nevt.kind(): " + evt.kind() );
            System.exit(0);
          }
        }catch(InterruptedException e) {
          return;
        }
      });
    } catch(lOException e) (
      throw new RuntimeException(e);
    }
    public static void main(String[] args) throws Exception {
      Directories.refreshTestDir();
      Directories.populateTestDir();
      Files.walk(Paths.get("test"))
        .filter(Files::isDirectory)
        .forEach(TreeWatcher::watchDir);        //[1]
      PathWatcher.delTxtFiles();
    }
  }
  ```
  ```java
  /»输出:
  deleting test\bag\foo\bar\baz\File.txt
  deleting test\bar\baz\bag\foo\File.txt
  evt.context()： File.txt
  evt.count()： 1
  evt.kind()： ENTRY_DELETE
  */
  ```
  - 启动了一个独立的进程来监控这个WatchSeivice()
  - 这里没有通过schedule()方法让任务推迟到以后再运行，而是通过submit()让它现在就运行
  - [1]我们遍历整个目录树，并在每个子目录上应用watchDir()

# 查找文件
  java.nio.file有一个更好的解决方案：PathMatcher  
  在FileSystem对象上调用getPathMatcher()来获得一个PathMatcher,并传入我们感兴趣的模式  
  模式有两个选项：glob就和regex。glob更简单,但实际上非常强大。如果冋题更为复杂，可以使用regex。  
  ```java
  import java.nio.file.*;

  public class Find {
    public static void main(String[] args) throws Exception {
      Path test = Paths.get("test");
      Directories.refreshTestDir();
      Directories.populateTestDir();
      //创走一个目录，而不是文件：
      Files.createDirectory(test.resolve("dir.tmp"));

      PathMatcher matcher = FileSystems.getDefault()
        .getPathMatcher("glob:**/*.{tmp,txt}");
      Files.walk(test)
        .filter(matcher::matches)
        .forEach(System.out::println);
      System.out.println("***************");
    }
  }
  ```
  ```java
  /*输出：
  test\bag\foo\bar\baz\5208762845883213974.tmp
  test\bag\foo\bar\baz\File.txt
  test\bar\baz\bag\foo\7918367201207778677.tnip
  test\bar\baz\bag\foo\File.txt
  test\baz\bag\foo\bar\8O16595521026696632.tmp
  test\baz\bag\foo\bar\File.txt
  test\dir.tmp
  test\foo\bar\baz\bag\5832319279813617280.tmp
  test\foo\bar\baz\bag\File.txt
  ***************
  */
  ```
  - 在matcher中，glob表达式开头的**/表示“所有子目录”，它匹配的是完整路径。
  - 单个的*表的是“任何东西”，后面的花括号表示的是一系列的可能性

# 读写文件
  如果一个文件是“小”的（意味着“对你来说运行得足够快，并旦不会耗尽内存”），java.nio.file.Files类包含了方便读写文本文件和二逬制文件的工具函数  
  ```java
  Files.readAllLines (
    Paths.get("../streams/Cheese.dat"))
    .stream()
    .filter(line -> !line.startsWith("//"))
    .map(line ->
      line.substring(0, line.length()/2))
    .forEach(System.out::println);
  ```
  - readAllLines()有一个重载的版本，还包含一个Charset参数，用来确定文件的Unicode编码

  Files.write()也被重载了，可以将byte数组或任何实现了Iterable接口的类的对象(还包括一个Charset选项)写入文件  
  ```java
  byte[] bytes = new byte[SIZE];
  rand.nextBytes(bytes);
  Files.write(Paths.get("bytes.dat"), bytes);
  System.out.println("bytes.dat: " +
    Files.size(Paths.get("bytes.dat")));
  ```
  ```java
  /*输出:
  bytes.dat: 1000
  */
  ```

  文件大小是个问题怎么办？可能是以下情况之一:  
  1. 这个文件非常大，如果一次性读取整个文件，可能会耗尽内存；
  2. 我们只需要文件的一部分就能得到想要的结果，所以读取整个文件是在浪费时间

  Files.lines()可以很方便地将一个文件变为一个由行组成的Stream:  
  ```java
  Files.lines(Paths.get("PathInfo.java"))
    .skip(13)
    .findFirst()
    .ifPresent(System.out::println);
  ```

  在一个流中完成读取、处理和写入：  
  ```java
  try(
    Stream<String> input =
      Files.lines(Paths.get("StreamInAndOut.java"));
    PrintWriter output =
      new PrintWriter("StreamInAndOut.txt")
  ){
    input
    .map(String::toUpperCase)
    .forEachOrdered(output::println);
  } catch(Exception e) {
    throw new RuntimeException(e);
  }
  ```
  - 因为我们是在同一个块中执行的所有操作，所以两个文件可以在相同的try-with-lesources块中打开
  - PrintWriter是一个旧式的java.io类，允许我们“打印’到一个文件，所以它是这个应用的理想选择

# 小结
  Java中的文件和目录操作，本章已做了相当全面的介绍，但库中仍然有一些我们没讲到的特性，请务必研究一下java.nio.file的文档，特别是java.nio.file.Files的。
  
