你永远无法保证自己的代码是正确的.你只能证明自己的代码存在问题.  

# 测试
  如果没有经过测试，代码就不可能正常工作  
  代码验证的第一步就是创建 试.来检查代码行为是否满足你的目标  

## 单元测试
  将单元测试集成到构建过程中, 并在每次构建系统时运行这些测试。  
  构建过程不仅可以检查语法错误，还可以检查语义错误。

  单元测试通常每个类都有测试，检查它所有方法。而“系统”测试则不同.它检查已完成的程序是否满足了最终要求  

  用Java开发程序比用C++快得多（大多数情况下前者速度是后者的两倍），原因在于Java的安全网，即垃圾收集和改进的类型检查等功能  

  为了保证代码的正确性，需要自动提取每个程序，然后使用适当的构建系统进行编译。  

## JUnit
  JUnit通过使用反射和注解极大地改逬了自身，并大大简化了编写单元测试的过程  
  在JUnit的最简单用法中，可以 用@Test注解来表示测试的每个方法。JUnit将这些方法识别为单独的测试.每次设置和运行一个，并采取措施来避免测试之间相互影响  

  标准做法是将测试代码放在它们自己的子目录中，测试代码也必须放在包里，这样JUnit才能识别它们  

  ```java
  import java.util.*;
  import org.junit.jupiter.api.*;
  import static org.junit.jupiter.api.Assertions.*;

  public class CountedListTest {
    private CountedList list;
    @BeforeAll
    static void beforeAllMsg() {
      System. out. println (">>> Starting CountedListTest");
    }
    @AfterAll
    static void afterAllMsg() {
      System.out.println(">>> Finished CountedListTest");
    }
    @BeforeEach
    public void initialize() {
      list = new CountedList();
      System, out. print In ("Set up for " + list .getld());
      for(int i = 0; i < 3; i++)
        list.add(Integer.toString(i));
    }
    @AfterEach
    public void cleanup(){
      System.out.println("Cleaning up " + list.getld());
    }
    @Test
    public void insert() {
      System.out.println("Running testlnsert()");
      assertEquals(list.size(), 3);
      list.add(l, "Insert");
      assertEquals(list.size(), 4);
      assertEquals(list.get(1), "Insert");
    }
    @Test
    public void replace() {
      System.out.println("Running testReplace()");
      assertEquals(list.size(), 3);
      list.set(1, "Replace");
      assertEquals(list.size(), 3);
      assertEquals(list.get(1), "Replace");
    }
    //用于简化代码的材助方法
    //只要没有@Test注解，JUnit就不会自动执行
    private void compare(List<String> lst, String[] strs) {
      assertArrayEquals(1st.toArray(new String[0]), strs);
    }
    @Test
    public void order() {
      System.out.println("Running testOrder()");
      compare (list, new String[] { "0", "1", "2" ));
    }
    @Test
    public void remove() {
      System.out.println("Running testRemove()");
      assertEquals(list.size(), 3);
      list.remove(1);
      assertEquals(list.size(), 2);
      compare(list, new String[] { "0", ”2" });
    }
    @Test
    public void addAll() {
      System.out.println("Running testAddAll()");
      list.addAll(Arrays.asList(new String[] {
        "An", "African", "Swallow"}));
      assertEquals(list.size(), 6);
      compare(list, new String[] { "0", "1", "2",
        "An", "African", "Swallow" });
    }
  }
  ```
  - @BeforeAll注解标注的方法会在任何测试执行之前运行一次。@AfterAll注解标注的方法在所有测试执行之后运行一次。两种方法都必须是静态的
  - @BeforeEach注解标注的方法通常用于创建和初始化一组公共对象，并在每次测试之前运行。也可以将这些初始化操作放在测试类的构造器中，不过为@BeforeEach更清晰
  - JUnit为每个测试创建一个对象 ，以确保运行的测试之间没有副作用
  - @BeforeEach和构造器之间的唯一区别是，@BeforeEach在测试运行之前才被调用，构造器的初始化对象是提前一次性创建的
  - 如果在每次测试后必须执行清理（比如需要恢复修改过的static成员，需要关闭打开的文件、数据库或网络连接等），请使用@AfterEach注解来标注方法
  - JUnit使用@Test注解来标注这些方法，并将每个方法作为测试运行。使用JUnit的断言方法（均以名称“assert”开头）来验证测试的正确性（在JUnit文档中可以找到所有的“assert”语句）  
  - 只要没有@Test注解，JUnit就不会运行它，或期望它具备特定的方法签名  
  - 断言语句不是必需的
  - 其余的测试方法通过将重复代码重构到compare()里来消除冗余

  JUnit是目前最流行的Java单元测试框架之一,但也有其他的替代方案  

## 测试覆盖率的幻觉
  测试覆盖率(test coverage ),也称为代码覆盖率(code coverage ),是衡量代码库的测试百分比。百分比越高，测试做盖率越大  

  如果有人要求100%的覆盖率，那么就会在其余部分浪费大量时间，并且在以后向项目添加代码时浪费更多时间  

  如果覆盖率工具报告的值特别低(例如，小于40%). 则表明覆盖率可能不足  

  概盖工具的最佳用途是发现代码库中未经测试的部分。但是，不要依赖覆盖率来获取测试质量相关的信息  

# 前置条件
  前置条件(precondition )的概念来自契约式设计(Design By Contract, DbC ),并使用了基本的断言(assertion )机制来实现  

## 断言
  断言通过验证程序执行期间是否满足某些条件来提高程序的稳健性  

### Java断言语法  
  断言语句有两种形式:  
  `assert boolean-expression;`  
  `assert boolean-expression: information-expression;`  
  两者都表示“我断言这个boolean-expression的值是trueMo如果不是这种情况，则断言会产生一个AssertionError异常。它是Throwable的一个子类，因此不需要指定异常规范  
  第一种断言形式产生的异常不包含boolean-expression的任何信息(这与大多数其他语言的断言机制相反)  

  ```java
  //运行时客要使用-ea标志：
  // {java -ea Assertl)
  // {ThrowsException)
  public class Assertl {
    public static void main(String!] args) {
      assert false;
    }
  }
  ```
  ```java
  /*榆出:
  ___[ Error Output ] ___
  Exception in thread "main" java.lang.AssertionError
      at Assert1.main(Assert1.java:9)
  */
  ```
  - 如果正常运行程序.不加任何特殊的断言标志，则什么都不会发生
  - 显式地启用断言,最简单的方法是使用`-ea`标志，它也可以拼写为-enableassertions。这将运行程序并执行任何断言语句

  最有用的information-expression通常是给程序员看的字符串文本：  
  ```java
  public class Assert2 {
    public static void main(String[] args) {
      assert false:
      "Here's a message saying what happened";
    }
  }
  ```
  - information-expression可以生成任何类型的对象

  你还可以根据类名或包名打开和关闭断言，也就是说.可以为整个包启用或禁用断言。  
  日志或调试可能是获取这类信息更好的工具  

  还有另一种方法可以控制断言：以编程的方式操作ClassLoader对象。ClassLoader中有几种方法允许动态启用和禁用断言，包括setDefaultAssertionStatus(),它为之后加载的所有类设置了断言状态:  
  ```java
  //使用类加载器开启断言

  public class LoaderAssertions {
    public static void main(String[] args) {
      ClassLoader.getSystemClassLoader()
        .setDefaultAssertionStatus(true);
      new Loaded().go();
    }
  }

  class Loaded {
    public void go() {
      assert false: "Loaded.go()";
    }
  }
  ```
  ```java
  /*输出:
  ___[ Error Output ]___
  Exception in thread "main" java.lang.AssertionError:
  Loaded.go()
      at Loaded.go(LoaderAssertions.java:15)
      at LoaderAssertions.main(LoaderAssertions. java:9)
  */
  ```
  - 这消除了运行程序时在命令行上使用-ea标志的需要，当然使用-ea标志启用断言可能同样简单
  - 在交付独立产品时，你可能需要设置一个执行脚本，来配置其他启动参数,以便用户无论如何都可以启动程序

  在程序运行时再决定是否启用断言也是有道理的,用以下静态子句完成此操作.该子句放置在系统的主类中:  
  ```java
  static {
    boolean assertionsEnabled = false;
    //注意.此处的赋值副作用是故意造成的：
    assert assertionsEnabled = true;
    if(JassertionsEnabled)
      throw new RuntimeException("Assertions disabled");
  }
  ```
  - 这个断言永远不会失败，因为赋值的返回值是分配的值

### Guava里的断言
  ```java
  try {
    verify(l + 2  == 4, "Bad math: %s",  "not 4");
    } catch(VerifyException e) {
      System.out.printtn(e.getMessage());
    }
  
  String s ="":
  s = verifyNotNull(s);
  s= null;
  try {
    verifyNotNull(
      s, "Shouldn't be null: %s", "arg s");
  } catch(VerifyException e) (
    System.out.println(e.getMessage());
  }
  ```
  ```java
  /*输出：
  Bad math: not 4
  Shouldn't be null: arg s
  */
  ```
  - 这里有两个方法，verify()和verifyNotNull()，它们各自又有变种方法可以提供错误消息。
  - 清注意，verifyNotNull()的内置错误消息通常就足够了，而verify()则过于笼统，无法提供有用的默认错误消息

### 在契约式设计中使用断言
  DbC假定服务提供者与该服务的消费者或客户之间存在着明确指定的合同。在面向对象编程中，服务通常由对象提供，  
  对象的边界————提供者和消费者之间的分界————是对象所属类的接口。当客户调用特定的公共方法时，  
  他们期望该调用会产生某些特定的行为：对象中状态的更改，或可预测的返回值  
  - 可以明确规定这种行为,就好像合同一样
  - 可以通过某些运行时检查来保证这种行为，也就是他所说的前置条件、后置条件和不变项

### 检查指令
  断言称之为检查指令(check instruction )。

### 前置条件测试
  这几乎总是意味着在方法调用的最幵始（即在该方法执行任何操作之前）检查参数，以确保它们适合在该方法中使用  

### 后置条件测试
  后置条件会测试方法的执行结果。此代码放置在方法调用的末尾return语句之前（如果有的话）  

### 不变项
  对象的状态信息在以下时间段会始终遵守规定的规则：  
  1. 进入方法后
  2. 离幵方法之前
  根据这个描述，一个有效的不变项被定义为一个方法.可以命名为invariant（）,它在对象构造之后以及每个方法的开始和结束时被调用  

### 放宽DbC的限制
  下面是放宽DbC检查的顺序，从最安全到最不安全  
  1. 首先禁用每个方法开头的不变项检查，因为每个方法末尾的不变项检查就可以保证:对象的状态在每次方法调用开始时都是有效的  
  2. 当有合理的单元测试来验证方法的返回值时，可以禁用后置条件检查  
  3. 如果确信方法体不会将对象置于无效状态，则可以禁用方法调用结束时的不变项检查。可以采用白盒测试（也就是使用可以访问私有字段的单元测试来验证对象状态）来验证这一点
  4. 不得已的话，还可以禁用前置条件检查。这是最不安全和最不明智的选择。

## DbC + 单元测试
  ```java
  //契约式设计的相关方法
  private static void precondition(boolean cond, String msg) {
    if(!cond) throw new CircularQueueException(msg);
  }
  private static boolean postcondition(boolean cond, String msg) {
    if(!cond) throw new CircularQueueException(msg);
      return true;
  }
  private boolean invariant() {
    //保证在保存了对象的data区域不会有空位：
    for(int i = out; i != in; i = (i + 1) % data.length)
      if(data[i] == null)
        throw new CircularQueueException(
          "null in CircularQueue");
    //保证在保存了对象的data区域之外只会有空值：
    if(full()) return true;
    for(int i = in; i != out; i = (i + 1) % data.length)
      if(data[i] != null)
        throw new CircularQueueException(
          "non-null outside of CircularQueue range:"
          + dumpO);
    return true;
  }
  public String dump() {
    return "in = " + in +
      ", out =" + out +
      ", full() =" + full() +
      ", empty() =" + empty() +
      ", CircularQueue =" + Arrays.asList(data);
  }
  ```
  - postcondition()和invariant()都返回一个布尔值.因此它们可以在assert语句中使用。之后如果出于性能原因禁用断言，那么就根本不会有方法调用
  - invariant()在对象上执行内部有效性检查。此外，如果你对实现有任何更改.invariant()可以确保你没有破坏自己的代码

## 使用Guava里的前置条件
  前置条件是DbC中不应该删除的部分,因为它会检查方法参数的有效性。
  由于Java默认禁用断言，因此最好还是使用始终验证方法参数的其他库。  
  Google的Guava库包含了一组很好的前置条件测试，这些测试不仅易于使用.而且提供了具有描述性的良好命名。  
  ```java
  import java.util.function.*;
  import static com.google.common.base.Preconditions.*:

  public class GuavaPreconditions {
    static void test(Consumer<String> c, String s) {
      try (
        System.out.println(s);
        c.accept(s);
        System.out.println("Success");
      } catch(Exception e) {
        String type = e.getClass().getSimpleName();
        String msg = e.getMessage();
        System.out.printIn(type +
          (msg == null ? "" : ":"+ msg));
      }
    }
    public static void main(String[] args) {
      test(s -> s = checkNotNull(s, "s was null, %s %s", "arg2", "arg3M), null);

      test(s -> checkArgument(s ==  "Fozzie", "Bear Left! %s Right!", "Frog"), null);

      test(s -> checkState(s.length() > 6), "Mort");

      test(s -> checkElementIndex(6, s.length()), "Bob");

      test(s -> checkPositionIndex(6, s.length()), "Bob");
    
      test(s -> checkPositionIndexes(7, 6, s.length()), "Hieronymus");
    }
  }
  ```
  ```
  /*输出：
  null
  NullPointerException: s was null, arg2 arg3

  null
  IllegalArgumentException: Bear Left! Frog Right!

  Mort
  IllegalStateException

  Bob
  IndexOutOfBoundsException: index (6) must be less than
  size (3)

  Bob
  IndexOutOfBoundsException: index (6) must not be
  greater than size (3)

  Hieronymus
  IndexOutOfBoundsException: end index (6) must not be
  less than start index (7)
  */
  ```
  - Guava的前置条件适用于所有类型
  - 每个前置条件都有三种不同的重载形式：没有消息的测试.带有简单String消息的测试，以及带有String及替换值的可变参数列表的测试
  - 出于效率原因，只允许使用％s(String类型)替换标签
  - checkNotNull()会返回其参数，因此你可以在表达式中通过内联的方式使用它
  - checkArgument()使用布尔表达式来对参数逬行更具体的测试，并在失败时抛出IllegalArgumentException
  - checkState()会测试对象的状态(例如.不变项检查)，而不是检查参数，并在失败时抛出IllegalStateException()
  - 最后三个方法在失败时都抛出IndexOutOfBoundsException()
  - checkElementIndex()保证其第一个参数是一个List、String或数组的有效元素索引，这个List、String或数组的大小由第二个参数指定
  - checkPositionlndex()确定它的第一个参数是否在0和第二个参数(包括)的范围内
  - checkPositionIndexes()保证［first_arg, second_arg)是一个 List、String或数组的有效子范围，而这个List, String或数组的大小是由第三个参数指定的

  Guava的所有前置条件方法都被重载，包括基本类型和Object类型  

# 测试驱动开发
  测试驱动开发(TDD)的前提是,如果在设计和编写代码时考虑到测试，你不仅会创建可测试的代码.而旦代码的设计会变得更好   

  TDD纯粹主义者在实现新功能之前会为该功能编写测试，这称为测试优先开发(TestFirst Development )  

  JUnit5中最复杂的新特性之一:动态测试生成(dynamic test generation )。你可以编写代码在运行时生成测试，而不是自己手动编写每个测试  

  JUnit5提供了多种动态生成测试的方法，DynamicTest.stream()方法的参数包括下列组成部分：  
  - 一组对象的迭代器.每组测试的对象都是不同的。该迭代器生成的对象可以是任何类型，但每次只生成一个对象，因此对于不同的多个项目，你必须人为地将它们打包成一个类型
  - 一个Function,它从迭代器中获取对象并生成一个字符串来描述这个测试
  - 一个Consumer,它接受来自迭代器的对象，并包含了基于该对象的测试代码
  ```java
  import java.util.*;
  import java.util.function.*;
  import java.util.stream.*;
  import org.junit.jupiter.api.*;
  import static org. junit.jupiter.api.Assertions.*;
  import static org.junit.jupiter.api.DynamicTest.*;

  class DynamicStringlnverterTests {
    //组合操作来防止重复代码：
    Stream<DynamicTest> testVersions(String id, Function<Stringinverter, String> test) {
      List<StringInverter> versions = Arrays.asList(
      new Inverter1y(), new Inverter2(),
      new Inverter3(), new Inverter4());
      return DynamicTest.stream(
        versions.iterator(),
        inverter -> inverter.getCl.ass() .getSimpleName(),
        inverter -> {
          System.out.printin(
            inverter.getClass().getSimpleName() +
              ":" + id);
          try {
            if(test.apply(inverter) != "fail")
              System.out.prinfln("Success");
          } catch(Exception | Error e)  {
            System.out.println(
              "Exception: " + e.getMessage());
          }
        }
      );
    }

    String isEqual(String lval, String rval) {
      if(lval.equals(rval))
        return "success";
      System.out.printin("FAIL: " + lval + " != " + rval);
      return "fail";
    }

    @BeforeAll
    static void startMsg() {
      System.out.printin(
        ">>> Starting DynamicStringlnverterTests <<<");
    }

    @AfterAll
    static void endMsg() (
      System.out.println(
        ">>> Finished DynamicStringlnverterTests <<<");
    }

    @TestFactory
    Stream<DynamicTest> basicInversionl() {
      String in = "Exit, Pursued by a Bear.";
      String out = "eXIT, pURSUED BY A bEAR.";
      return testversions(
        "Basic inversion (should succeed)",
        inverter -> isEqual(inverter.invert(in), out) );
    }
  }
  ```
  - 用@TestFactory注解标注过的每个方法都会生成一个DynamicTest对象的流(通过testVersions() ), JUnit会像执行常规的@Test方法一样执行流里的每个测试

  你可以先在测试用例里指明所有要实现的功能，然后以此为起点，在代码中实现相关功能，直到所有测试都通过  

## 测试驱动与测试优先
  纯测试优先编程的主要问题是，它假设你预先了解正在解决的冋题的一切。  
  实际上，可能值得创造一个像“面向测试开发”这样的词，来描述编写测试良好的代码的做法  

# 日志
  在日志包(logging package )可用之前,程序员可以基于这一点逬行编程：  
  debug是static final boolean的，你可以这样做:  
  ```java
  if(debug) {
    System.out.printin("Debug info");
  }
  ```
  - 当debug为false时，编译器会删除大括号内的代码。因此，代码不使用的话就对运行时没有影响
  - 但该技术的一个缺点是，你必须重新编译代码以打幵或关闭跟踪语句。如果能通过更改配置文件来修改日志记录属性，无须重新编译程序即可打开跟踪语句的话，那会方便很多

  SLF4J (Simple Logging Facade for Java )为多个日志框架提供了一个统一的门面(facade)  
  例如 java.util.logging、logback 和 log4j。SLF4J允许最终用户在部署时再插入所需的日志框架  
  ```java
  import org.slf4j.*;

  public class SLF4JLogging {
    private static Logger log = LoggerFactory.getLogger(SLF4JLogging.class);
    public static void main(String[] args) {
      log.info("hello logging");
    }
  }
  ```
  ```java
  /*输出：
  2O21-01-24T08:49:38.496
  [main] INFO SLF4JLogging - hello logging
  */
  ```
  - 输出中的格式和信息，甚至输出的内容是正常信息还是“错误”信息，都取决于连接到SLF4J的后端包

  日志系统会检测日志消息来源的类名和方法名.不过它不能保证这些名称是正确的,所以不要依赖于它们的准确性  

## 日志级别
  SLF4J提供了多个级别的报告  
  示例按“重性”的递増顺序显示了所有的级别




