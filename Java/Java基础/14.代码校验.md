你永远无法保证自己的代码是正确的.你只能证明自己的代码存在问题.  

# 测试
  如果没有经过测试，代码就不可能正常工作  
  代码验证的第一步就是创建 试.来检查代码行为是否满足你的目标  

## 单元测试
  将单元测试集成到构建过程中, 并在每次构建系统时运行这些测试。  
  构建过程不仅可以检查语法错误，还可以检查语义错误。

  单元测试通常每个类都有测试，检查它所有方法。而“系统”测试则不同.它检查已完成的程序是否满足了最终要求  

  用Java开发程序比用C++快得多（大多数情况下前者速度是后者的两倍），原因在于Java的安全网，即垃圾收集和改进的类型检查等功能  

  为了保证代码的正确性，需要自动提取每个程序，然后使用适当的构建系统进行编译。  

## JUnit
  JUnit通过使用反射和注解极大地改逬了自身，并大大简化了编写单元测试的过程  
  在JUnit的最简单用法中，可以 用@Test注解来表示测试的每个方法。JUnit将这些方法识别为单独的测试.每次设置和运行一个，并采取措施来避免测试之间相互影响  

  标准做法是将测试代码放在它们自己的子目录中，测试代码也必须放在包里，这样JUnit才能识别它们  

  ```java
  import java.util.*;
  import org.junit.jupiter.api.*;
  import static org.junit.jupiter.api.Assertions.*;

  public class CountedListTest {
    private CountedList list;
    @BeforeAll
    static void beforeAllMsg() {
      System. out. println (">>> Starting CountedListTest");
    }
    @AfterAll
    static void afterAllMsg() {
      System.out.println(">>> Finished CountedListTest");
    }
    @BeforeEach
    public void initialize() {
      list = new CountedList();
      System, out. print In ("Set up for " + list .getld());
      for(int i = 0; i < 3; i++)
        list.add(Integer.toString(i));
    }
    @AfterEach
    public void cleanup(){
      System.out.println("Cleaning up " + list.getld());
    }
    @Test
    public void insert() {
      System.out.println("Running testlnsert()");
      assertEquals(list.size(), 3);
      list.add(l, "Insert");
      assertEquals(list.size(), 4);
      assertEquals(list.get(1), "Insert");
    }
    @Test
    public void replace() {
      System.out.println("Running testReplace()");
      assertEquals(list.size(), 3);
      list.set(1, "Replace");
      assertEquals(list.size(), 3);
      assertEquals(list.get(1), "Replace");
    }
    //用于简化代码的材助方法
    //只要没有@Test注解，JUnit就不会自动执行
    private void compare(List<String> lst, String[] strs) {
      assertArrayEquals(lst.toArray(new String[0]), strs);
    }
    @Test
    public void order() {
      System.out.println("Running testOrder()");
      compare (list, new String[] { "0", "1", "2" ));
    }
    @Test
    public void remove() {
      System.out.println("Running testRemove()");
      assertEquals(list.size(), 3);
      list.remove(1);
      assertEquals(list.size(), 2);
      compare(list, new String[] { "0", "2" });
    }
    @Test
    public void addAll() {
      System.out.println("Running testAddAll()");
      list.addAll(Arrays.asList(new String[] {
        "An", "African", "Swallow"}));
      assertEquals(list.size(), 6);
      compare(list, new String[] { "0", "1", "2",
        "An", "African", "Swallow" });
    }
  }
  ```
  - @BeforeAll注解标注的方法会在任何测试执行之前运行一次。@AfterAll注解标注的方法在所有测试执行之后运行一次。两种方法都必须是静态的
  - @BeforeEach注解标注的方法通常用于创建和初始化一组公共对象，并在每次测试之前运行。也可以将这些初始化操作放在测试类的构造器中，不过为@BeforeEach更清晰
  - @BeforeEach和构造器之间的唯一区别是，@BeforeEach在测试运行之前才被调用，构造器的初始化对象是提前一次性创建的
  - JUnit为每个测试创建一个对象 ，以确保运行的测试之间没有副作用
  - 如果在每次测试后必须执行清理（比如需要恢复修改过的static成员，需要关闭打开的文件、数据库或网络连接等），请使用@AfterEach注解来标注方法
  - JUnit使用@Test注解来标注这些方法，并将每个方法作为测试运行。使用JUnit的断言方法（均以名称“assert”开头）来验证测试的正确性（在JUnit文档中可以找到所有的“assert”语句）  
  - 只要没有@Test注解，JUnit就不会运行它，或期望它具备特定的方法签名  
  - 断言语句不是必需的
  - 其余的测试方法通过将重复代码重构到compare()里来消除冗余

  JUnit是目前最流行的Java单元测试框架之一,但也有其他的替代方案  

## 测试覆盖率的幻觉
  测试覆盖率(test coverage ),也称为代码覆盖率(code coverage ),是衡量代码库的测试百分比。百分比越高，测试做盖率越大  

  如果有人要求100%的覆盖率，那么就会在其余部分浪费大量时间，并且在以后向项目添加代码时浪费更多时间  

  如果覆盖率工具报告的值特别低(例如，小于40%). 则表明覆盖率可能不足  

  概盖工具的最佳用途是发现代码库中未经测试的部分。但是，不要依赖覆盖率来获取测试质量相关的信息  

# 前置条件
  前置条件(precondition )的概念来自契约式设计(Design By Contract, DbC ),并使用了基本的断言(assertion )机制来实现  

## 断言
  断言通过验证程序执行期间是否满足某些条件来提高程序的稳健性  

### Java断言语法  
  断言语句有两种形式:  
  `assert boolean-expression;`  
  `assert boolean-expression: information-expression;`  
  两者都表示“我断言这个boolean-expression的值是true。如果不是这种情况，则断言会产生一个AssertionError异常。它是Throwable的一个子类，因此不需要指定异常规范  
  第一种断言形式产生的异常不包含boolean-expression的任何信息(这与大多数其他语言的断言机制相反)  

  ```java
  //运行时客要使用-ea标志：
  // {java -ea Assertl)
  // {ThrowsException)
  public class Assertl {
    public static void main(String!] args) {
      assert false;
    }
  }
  ```
  ```java
  /*榆出:
  ___[ Error Output ] ___
  Exception in thread "main" java.lang.AssertionError
      at Assert1.main(Assert1.java:9)
  */
  ```
  - 如果正常运行程序.不加任何特殊的断言标志，则什么都不会发生
  - 显式地启用断言,最简单的方法是使用`-ea`标志，它也可以拼写为-enableassertions。这将运行程序并执行任何断言语句

  最有用的information-expression通常是给程序员看的字符串文本：  
  ```java
  public class Assert2 {
    public static void main(String[] args) {
      assert false:
      "Here's a message saying what happened";
    }
  }
  ```
  - information-expression可以生成任何类型的对象

  你还可以根据类名或包名打开和关闭断言，也就是说.可以为整个包启用或禁用断言。  
  日志或调试可能是获取这类信息更好的工具  

  还有另一种方法可以控制断言：以编程的方式操作ClassLoader对象。ClassLoader中有几种方法允许动态启用和禁用断言，包括setDefaultAssertionStatus(),它为之后加载的所有类设置了断言状态:  
  ```java
  //使用类加载器开启断言

  public class LoaderAssertions {
    public static void main(String[] args) {
      ClassLoader.getSystemClassLoader()
        .setDefaultAssertionStatus(true);
      new Loaded().go();
    }
  }

  class Loaded {
    public void go() {
      assert false: "Loaded.go()";
    }
  }
  ```
  ```java
  /*输出:
  ___[ Error Output ]___
  Exception in thread "main" java.lang.AssertionError:
  Loaded.go()
      at Loaded.go(LoaderAssertions.java:15)
      at LoaderAssertions.main(LoaderAssertions. java:9)
  */
  ```
  - 这消除了运行程序时在命令行上使用-ea标志的需要，当然使用-ea标志启用断言可能同样简单
  - 在交付独立产品时，你可能需要设置一个执行脚本，来配置其他启动参数,以便用户无论如何都可以启动程序

  在程序运行时再决定是否启用断言也是有道理的,用以下静态子句完成此操作.该子句放置在系统的主类中:  
  ```java
  static {
    boolean assertionsEnabled = false;
    //注意.此处的赋值副作用是故意造成的：
    assert assertionsEnabled = true;
    if( !assertionsEnabled)
      throw new RuntimeException("Assertions disabled");
  }
  ```
  - 这个断言永远不会失败，因为赋值的返回值是分配的值

### Guava里的断言
  ```java
  try {
    verify(l + 2  == 4, "Bad math: %s",  "not 4");
    } catch(VerifyException e) {
      System.out.printtn(e.getMessage());
    }
  
  String s ="":
  s = verifyNotNull(s);
  s= null;
  try {
    verifyNotNull(
      s, "Shouldn't be null: %s", "arg s");
  } catch(VerifyException e) {
    System.out.println(e.getMessage());
  }
  ```
  ```java
  /*输出：
  Bad math: not 4
  Shouldn't be null: arg s
  */
  ```
  - 这里有两个方法，verify()和verifyNotNull()，它们各自又有变种方法可以提供错误消息。
  - 清注意，verifyNotNull()的内置错误消息通常就足够了，而verify()则过于笼统，无法提供有用的默认错误消息

### 在契约式设计中使用断言
  DbC假定服务提供者与该服务的消费者或客户之间存在着明确指定的合同。在面向对象编程中，服务通常由对象提供，  
  对象的边界————提供者和消费者之间的分界————是对象所属类的接口。当客户调用特定的公共方法时，  
  他们期望该调用会产生某些特定的行为：对象中状态的更改，或可预测的返回值  
  - 可以明确规定这种行为,就好像合同一样
  - 可以通过某些运行时检查来保证这种行为，也就是他所说的前置条件、后置条件和不变项

### 检查指令
  断言称之为检查指令(check instruction )。

### 前置条件测试
  这几乎总是意味着在方法调用的最幵始（即在该方法执行任何操作之前）检查参数，以确保它们适合在该方法中使用  

### 后置条件测试
  后置条件会测试方法的执行结果。此代码放置在方法调用的末尾return语句之前（如果有的话）  

### 不变项
  对象的状态信息在以下时间段会始终遵守规定的规则：  
  1. 进入方法后
  2. 离开方法之前  
  根据这个描述，一个有效的不变项被定义为一个方法.可以命名为invariant(),它在对象构造之后以及每个方法的开始和结束时被调用  

### 放宽DbC的限制
  下面是放宽DbC检查的顺序，从最安全到最不安全  
  1. 首先禁用每个方法开头的不变项检查，因为每个方法末尾的不变项检查就可以保证:对象的状态在每次方法调用开始时都是有效的  
  2. 当有合理的单元测试来验证方法的返回值时，可以禁用后置条件检查  
  3. 如果确信方法体不会将对象置于无效状态，则可以禁用方法调用结束时的不变项检查。可以采用白盒测试（也就是使用可以访问私有字段的单元测试来验证对象状态）来验证这一点
  4. 不得已的话，还可以禁用前置条件检查。这是最不安全和最不明智的选择。

## DbC + 单元测试
  ```java
  //契约式设计的相关方法
  private static void precondition(boolean cond, String msg) {
    if(!cond) throw new CircularQueueException(msg);
  }
  private static boolean postcondition(boolean cond, String msg) {
    if(!cond) throw new CircularQueueException(msg);
      return true;
  }
  private boolean invariant() {
    //保证在保存了对象的data区域不会有空位：
    for(int i = out; i != in; i = (i + 1) % data.length)
      if(data[i] == null)
        throw new CircularQueueException(
          "null in CircularQueue");
    //保证在保存了对象的data区域之外只会有空值：
    if(full()) return true;
    for(int i = in; i != out; i = (i + 1) % data.length)
      if(data[i] != null)
        throw new CircularQueueException(
          "non-null outside of CircularQueue range:"
          + dumpO);
    return true;
  }
  public String dump() {
    return "in = " + in +
      ", out =" + out +
      ", full() =" + full() +
      ", empty() =" + empty() +
      ", CircularQueue =" + Arrays.asList(data);
  }
  ```
  - postcondition()和invariant()都返回一个布尔值.因此它们可以在assert语句中使用。之后如果出于性能原因禁用断言，那么就根本不会有方法调用
  - invariant()在对象上执行内部有效性检查。此外，如果你对实现有任何更改.invariant()可以确保你没有破坏自己的代码

## 使用Guava里的前置条件
  前置条件是DbC中不应该删除的部分,因为它会检查方法参数的有效性。
  由于Java默认禁用断言，因此最好还是使用始终验证方法参数的其他库。  
  Google的Guava库包含了一组很好的前置条件测试，这些测试不仅易于使用.而且提供了具有描述性的良好命名。  
  ```java
  import java.util.function.*;
  import static com.google.common.base.Preconditions.*:

  public class GuavaPreconditions {
    static void test(Consumer<String> c, String s) {
      try (
        System.out.println(s);
        c.accept(s);
        System.out.println("Success");
      } catch(Exception e) {
        String type = e.getClass().getSimpleName();
        String msg = e.getMessage();
        System.out.printIn(type +
          (msg == null ? "" : ":"+ msg));
      }
    }
    public static void main(String[] args) {
      test(s -> s = checkNotNull(s, "s was null, %s %s", "arg2", "arg3"), null);

      test(s -> checkArgument(s ==  "Fozzie", "Bear Left! %s Right!", "Frog"), null);

      test(s -> checkState(s.length() > 6), "Mort");

      test(s -> checkElementIndex(6, s.length()), "Bob");

      test(s -> checkPositionIndex(6, s.length()), "Bob");
    
      test(s -> checkPositionIndexes(7, 6, s.length()), "Hieronymus");
    }
  }
  ```
  ```
  /*输出：
  null
  NullPointerException: s was null, arg2 arg3

  null
  IllegalArgumentException: Bear Left! Frog Right!

  Mort
  IllegalStateException

  Bob
  IndexOutOfBoundsException: index (6) must be less than
  size (3)

  Bob
  IndexOutOfBoundsException: index (6) must not be
  greater than size (3)

  Hieronymus
  IndexOutOfBoundsException: end index (6) must not be
  less than start index (7)
  */
  ```
  - Guava的前置条件适用于所有类型
  - 每个前置条件都有三种不同的重载形式：没有消息的测试.带有简单String消息的测试，以及带有String及替换值的可变参数列表的测试
  - 出于效率原因，只允许使用％s(String类型)替换标签
  - checkNotNull()会返回其参数，因此你可以在表达式中通过内联的方式使用它
  - checkArgument()使用布尔表达式来对参数逬行更具体的测试，并在失败时抛出IllegalArgumentException
  - checkState()会测试对象的状态(例如.不变项检查)，而不是检查参数，并在失败时抛出IllegalStateException()
  - 最后三个方法在失败时都抛出IndexOutOfBoundsException()
  - checkElementIndex()保证其第一个参数是一个List、String或数组的有效元素索引，这个List、String或数组的大小由第二个参数指定
  - checkPositionlndex()确定它的第一个参数是否在0和第二个参数(包括)的范围内
  - checkPositionIndexes()保证［first_arg, second_arg)是一个 List、String或数组的有效子范围，而这个List, String或数组的大小是由第三个参数指定的

  Guava的所有前置条件方法都被重载，包括基本类型和Object类型  

# 测试驱动开发
  测试驱动开发(TDD)的前提是,如果在设计和编写代码时考虑到测试，你不仅会创建可测试的代码.而旦代码的设计会变得更好   

  TDD纯粹主义者在实现新功能之前会为该功能编写测试，这称为测试优先开发(Test-First Development )  

  JUnit5中最复杂的新特性之一:动态测试生成(dynamic test generation )。你可以编写代码在运行时生成测试，而不是自己手动编写每个测试  

  JUnit5提供了多种动态生成测试的方法，DynamicTest.stream()方法的参数包括下列组成部分：  
  - 一组对象的迭代器.每组测试的对象都是不同的。该迭代器生成的对象可以是任何类型，但每次只生成一个对象，因此对于不同的多个项目，你必须人为地将它们打包成一个类型
  - 一个Function,它从迭代器中获取对象并生成一个字符串来描述这个测试
  - 一个Consumer,它接受来自迭代器的对象，并包含了基于该对象的测试代码
  ```java
  import java.util.*;
  import java.util.function.*;
  import java.util.stream.*;
  import org.junit.jupiter.api.*;
  import static org. junit.jupiter.api.Assertions.*;
  import static org.junit.jupiter.api.DynamicTest.*;

  class DynamicStringlnverterTests {
    //组合操作来防止重复代码：
    Stream<DynamicTest> testVersions(String id, Function<Stringinverter, String> test) {
      List<StringInverter> versions = Arrays.asList(
      new Inverter1y(), new Inverter2(),
      new Inverter3(), new Inverter4());
      return DynamicTest.stream(
        versions.iterator(),
        inverter -> inverter.getCl.ass() .getSimpleName(),
        inverter -> {
          System.out.printin(
            inverter.getClass().getSimpleName() +
              ":" + id);
          try {
            if(test.apply(inverter) != "fail")
              System.out.prinfln("Success");
          } catch(Exception | Error e)  {
            System.out.println(
              "Exception: " + e.getMessage());
          }
        }
      );
    }

    String isEqual(String lval, String rval) {
      if(lval.equals(rval))
        return "success";
      System.out.printin("FAIL: " + lval + " != " + rval);
      return "fail";
    }

    @BeforeAll
    static void startMsg() {
      System.out.printin(
        ">>> Starting DynamicStringlnverterTests <<<");
    }

    @AfterAll
    static void endMsg() (
      System.out.println(
        ">>> Finished DynamicStringlnverterTests <<<");
    }

    @TestFactory
    Stream<DynamicTest> basicInversionl() {
      String in = "Exit, Pursued by a Bear.";
      String out = "eXIT, pURSUED BY A bEAR.";
      return testversions(
        "Basic inversion (should succeed)",
        inverter -> isEqual(inverter.invert(in), out) );
    }
  }
  ```
  - 用@TestFactory注解标注过的每个方法都会生成一个DynamicTest对象的流(通过testVersions() ), JUnit会像执行常规的@Test方法一样执行流里的每个测试

  你可以先在测试用例里指明所有要实现的功能，然后以此为起点，在代码中实现相关功能，直到所有测试都通过  

## 测试驱动与测试优先
  纯测试优先编程的主要问题是，它假设你预先了解正在解决的冋题的一切。  
  实际上，可能值得创造一个像“面向测试开发”这样的词，来描述编写测试良好的代码的做法  

# 日志
  在日志包(logging package )可用之前,程序员可以基于这一点逬行编程：  
  debug是static final boolean的，你可以这样做:  
  ```java
  if(debug) {
    System.out.printin("Debug info");
  }
  ```
  - 当debug为false时，编译器会删除大括号内的代码。因此，代码不使用的话就对运行时没有影响
  - 但该技术的一个缺点是，你必须重新编译代码以打幵或关闭跟踪语句。如果能通过更改配置文件来修改日志记录属性，无须重新编译程序即可打开跟踪语句的话，那会方便很多

  SLF4J (Simple Logging Facade for Java )为多个日志框架提供了一个统一的门面(facade)  
  例如 java.util.logging、logback 和 log4j。SLF4J允许最终用户在部署时再插入所需的日志框架  
  ```java
  import org.slf4j.*;

  public class SLF4JLogging {
    private static Logger log = LoggerFactory.getLogger(SLF4JLogging.class);
    public static void main(String[] args) {
      log.info("hello logging");
    }
  }
  ```
  ```java
  /*输出：
  2O21-01-24T08:49:38.496
  [main] INFO SLF4JLogging - hello logging
  */
  ```
  - 输出中的格式和信息，甚至输出的内容是正常信息还是“错误”信息，都取决于连接到SLF4J的后端包

  日志系统会检测日志消息来源的类名和方法名。不过它不能保证这些名称是正确的,所以不要依赖于它们的准确性  

## 日志级别
  SLF4J提供了多个级别的报告，示例按“严重性”的递増顺序显示了所有的级别：  
  ```java
  public class SLF4JLevels {
    private static Logger log = LoggerFactory. getLogger(SLF4JLevels. class);
    public static void main(String[] args) {
      log.trace("Hello");
      log.debug("Logging");
      log.info("Using");
      log.warn("the SLF4J");
      log.error("Facade");
    }
  }
  ```
  ```java
  /*输出：
  2021-01-24T08:49:37.658
  [main] TRACE SLF4JLevels - Hello
  2621-91-24108:49:37.661
  [main] DEBUG SLF4JLevels - Logging
  2021-01-24108:49:37.661
  [main] INFO SLF4JLevels - Using
  2021-61-24108:49:37.661
  [main] WARN SLF4JLevels - the SLF4J
  2021-01-24TG8:49:37.661
  [main] ERROR SLF4JLevels - Facade
  */
  ```
  - 这些不同的级别设置可以让你查看某个级别的消息。这些级別通常设置在单独的配置文件中，因此无须重新编译即可重新配置
  - 配置文件格式取决于使用的后端日志实现

  logback使用的XML配置：  
  ```xml
  <!-- validating/logback.xml -->
  <?xml version="1.0" encoding="UTF-8"?>
  <configuration>
    <appender name="STDOUT"
      class="ch. qos. logback. core. ConsoleAppender'>
      <encoder>
        <pattern>
  %d{yyyy-MM-dd'T'HH:mm:ss.SSS}
  [%thread] %-5level %logger - %msg%n
        </pattern>
      </encoder>
    </appender>
    <root level="TRACE">
      <appender-ref ref="STDOUT" />
    </root>
  </configuration>
  ```
  - 将＜root level="TRACE"＞这一行更改为不同的级别，然后重新运行程序来查看输出是如何变化的
  - 如果你不提供logback.xml文件，就会使用默认的配置

# 调试
  和打印语句相比，你可能还需要更深入地査看程序。为此，你需要一个调试器(debugger )  
  除了比使用打印语句生成的信息更快、更容易显示之外，调试器还可以设置断点(breakpoint),并在程序到达这些断点时停止  
  调试器可以随时显示程序的状态，查看变量的值，逐行执行程序，连接到远程运行的程序，等等  

## 使用JDB进行调试
  Java调试器(JDB)是JDK附带的命令行工具。  
  JDB对于学习调试和执行简单的调试任务很有用，并且只要安装了 JDK,它就是可用的  
  ```java
  public class SimpleDebugging {
    private static void fool() {
      System.out.printin("In fool");
      foo2();
    }
    private static void foo2() (
      System.out.printIn("In foo2");
      foo3();
    }
    private static void foo3() {
      System.out.printin("In foo3");
      int j =1；
      j--；
      int i = 5 / j;
    }
    public static void main(String[] args) {
      fool();
    }
  }
  ```
  要运行JDB,首先要让编译器使用`-g`标志来编译SimpleDebugging.java,这样才会生成调试信息  
  `jdb SimpleDebugging`  
  
  命令`catch Exception`会在任何抛出异常的地方设置一个断点（但是，即使你没有明确给出这个指令，调试器也会停止————异常似乎是JDB中的默认断点）  

  run命令:  
  ```shell
  run SimpleDebugging
  Set uncaught j ava.lang.Throwable
  Set deferred uncaught java.lang.Throwable
  >
  VM Started： In fool
  In foo2
  In foo3
  Exception occurred: java.lang.ArithmeticException
  (uncaught )"thread=main",
  SimpleDebugging.foo3(), line=17 bci=15
  17         int i = 5 / j;
  ```

  可以使用list命令列出程序源码中停止运行的地方  
  ```shell
  main[l] list
  13      private static void foo3() {
  14        System.out.println("In foo3");
  15        int j = 1;
  16        j--；
  17 =>     int i = 5 / j;
  18      }
  19      public static void main(String(] args) {
  20        fool();
  21      }
  22    }
  ```
  - 此淸单中的指针(“=>”)显示了程序执行到的位置，恢复执行后将从此处继续
  - 使用cont ( continue )命令恢复执行，但这会使JDB在异常处退出，然后打印栈信息

  locals命令会转储所有的局部变量的值:  
  ```java
  main[l] locals
  Method arguments:
  Local variables:
  j = 0
  ```

  wherei命令会打印当前线程的方法栈里压入的栈帧:  
  ```java
  main[l] wherei
  [1] SimpleDebugging.foo3 (SimpleDebugging.java:17), pc = 15
  [2] SimpleDebugging.foo2 (SimpleDebugging.java:11), pc = 8
  [3] SimpleDebugging.fool (SimpleDebugging.java:7), pc = 8
  [4] SimpleDebugging.main (SimpleDebugging.java:20), pc = 0
  ```
  - wherei之后的每一行代表一个方法调用和调用返回的点［由程序计数器(programcounter) pc 的值表示］

  命令行调试器往往需要花费更多精力才能获得结果。我们应该使用jdb学习调试的基础知识，然后转向图形调试器  

## 图形调试器
  使用像JDB这样的命令行渦试器可能很不方便。它需要显式命令来查看变量的状态(locals、dump ).在源码中列出执行点(list),找出系统中的线程(threads ),设置断点(stop in、stop at),等等  
  图形调试器只需单击几下鼠标即可提供这些功能，并旦在不使用显式命令的情况下，还可以显示正在调试的程序的最新详细信息  

# 基准测试
  基准测试(Benchmarking )意味着对代码或算法逬行计时，以查看哪些运行得更快  
  而对于像Java这样具有复杂运行时系统的语言，基准测试变得更具挑战性。为了产生可靠的数据.实验设置必须控制各种变量，例如CPU频率、节能功能、在同一台机器上运行的其他进程、优化器选项，等等  

## 微基准测试
  可以编写一个计时实用程序来比较不同代码段的运行速度  
  1. 创建一个Timer对象，执行你想耍的操作，然后在这个Timer对象上调用duration()方法，来生成以毫秒为单位的用时
  2. 将Runnable传递给静态方法duiation()。符合Runnable接口的类都会有一个函数式方法run(),这个函数式方法有一个不带参数也不返回任何东西的函数签名
  ```java
  import static java.util.concurrent.TimeUnit.*;
  
  public class Timer {
    private long start = System.nanoTime();
    public long duration() {
      return NANOSECONDS.toMillis(
        System.nanoTime() - start);
    }
    public static long duration(Runnable test) {
      Timer timer = new Timer();
      test.run();
      return timer.duration();
    }
  }
  ```

  如果你的操作依赖于公共资源，并行版本最终可能会慢得多，因为多个任务会争用该资源  

  JVM的Hotspot技术对性能影响也很大。如果在运行测试之前不先运行代码来“预热” JVM,则可能会得到“冷”结果，  
  这些结果并没有反映出程序运行一段时间后的速度（如果正在运行的应用程序使用并不频繁，结果最终没有触发JVM的“预热”呢？  
  你将无法获得预期的性能.甚至可能还会降低速度）  
  Hotspot技术————JIT编译器将频繁使用的代码编译为字节码，以加快重复使用代码时的速度  

## 介绍 JMH
  Java微基准测试工具（Java Microbenchmarking Harness, JMH ）  
  唯一需要的注解是@State @Benchmark
  ```java
  import java.util.*;
  import org.openjdk.jmh.annotations.*;
  import java.util.concurrent.TimeUnit;

  @State(Scope.Thread)
  @BenchmarkMode(Mode.AverageTime)
  @OutputTimeUnit(TimeUnit.MICROSECONDS)
  //包括下面三个注解来提高精确度：
  @Warmup (iterations = 5)
  @Measurement(iterations = 5)
  @Fork(l)
  public class JMH1 {
    private long[] la;
    @Setup
    public void setup() {
      la = new long[25O_000_000];
    }
    ©Benchmark
    public void setAll() {
      Arrays.setAll(la, n -> n):
    }
    @Benchmark
    public void parallelSetAll() {
      Arrays.parallelSetAll(la, n -> n);
    }
  }
  ```
  - @Fork注解将其减为1
  - @Warmup和@Measurement注解将预热迭代和测量迭代的数量从.默认的20次减少到5次

  考虑一下其他因素:  
  - C：执行操作的客户线程数
  - P：并行算法使用的并行量
  - N：数组的大小：10^(2*k）,其中k=1..7通常足以労盖不同的缓存占用场景
  - Q：setter操作的成本
  ---
  - N*Q（基本上就是工作量）对并行性能至关重要
  - 如果操作对资源的竞争很激烈的话，无论N*Q有多大，并行性能都不会高
  - 当C较高时，P的相关性要低得多（大量的外部并行性使得内部并行性变得多余）。对于C大小相同的同一客户来说，并行分解带来的成本使得它运行并行算法比运行顺序算法更慢

  前面的示例中，我们所做的只是将索引的值分配到数组对应的位置，这是最简单的任务之一。所以即使N变大，N*Q仍然不是那么好，看起来我们没有提供足够的并行机会  
  ```java
  public static long f(long x) {
    long quadratic = 42 * x * x + 19 * x + 47;
    return Long.divideUnsigned(quadratic, x + 1);
  }
  @Benchmark
  public void setAll() {
    Arrays.setAll(la, n -> f(n) );
  }
  @Benchmark
  public void parallelSetAll() {
    Arrays.parallelSetAll.(la, n -> f(n));
  }
  ```

  parallelSetAll()的结果在很大程度上取决于计算的复杂性和数组的大小  

# 分析与优化
  - 分析器(profiler)可以找到耗时的部分，这样你就可以通过最简单、最明显的方法来加快速度  
  - 分析器会收集各种信息，比如程序的哪些部分消耗内存，以及哪些方法消耗了最多的时间。一些分析器甚至会禁用垃圾收集器来帮助确定内存的分配模式   
  - 分析器对于检测程序中的线程死锁也很有用  
  - 请注意分析和基准测试之间的区别：分析着眼于处理实际数据的完整程序，而基准测试着眼于程序的一个独立片段，通常是为了优化算法

  Java开发工具包(JDK)安装时附带了一个名为VisualVM的可视化分析器  
  要启动VisualVM,控制台命令是：`jvisualvm`  

## 优化指南
  - 避免为了性能而牺牲代码可读性
  - 不要孤立地看待性能。权衡付出的努力与获得的好处
  - 程序的大小很重要。性能优化通常只对长时间运行的大型项目有价值。小型项目通常不需要关心性能
  - 让程序先正常工作比努力提高其性能更重要。一旦有了一个能运行的程序，你就可以在必要时使用分析器来提高它的效率。仅当性能是关键因素时，才应该在初始设计/幵发阶段就考虑性能
  - 不要猜测性能瓶颈在哪里。运行分析器来获取该数据
  - JVM会优化static final变量来提高程序速度。因此，程序常量应该声明为static和final的

# 样式检查
  当整个团队一起在某个项目（特别是开源项目）上工作时.如果每个人都遵循相同的编程风格，这会很有用。  
  这样的话，阅读和理解项目代码时就不会被风格差异所干扰  
  
  比较流行的样式检查器是Checkstyle  

# 静态错误分析
  尽管Java的静态类型检查会发现基本的语法错误.但额外的分析工具可以发现更复杂的错误  
  其中一种工具是Findbugs  
  在启动调试器之前运行一下Findbugs是值得的，因为它可能很快就会找到一些问题.而发现这些问题原本可能需要花费数小时  

# 代码审查
  代码审查有多种方式，一般由一个人或一组人编写代码.然后让其他人或其他组来阅读和评估   
  代码审查可以作为结对编程的一部分，或使用演练（walkthrough ）的方式，每个人都阅读代码并讨论它。后一种方法具有共享知识与编程文化的显著优势

# 结对编程
  结对编程（pair programming ）是两个程序员一起编程的一种实践  
  结对编程有很多好处,但最引人注目的两个好处是共享知识和防止信息阻塞  
  两个人结伴工作，继续前进要容易得多，而孤军作战很容易陷入困境  

# 重构
  技术债务（technical debt）是那些在软件中积累的快速而肮脏的解决方案，它使设计无法理解，代码无法阅读  
  重构（refactoring ）是技术债务的解毒剂。重构的关键在于，它改进了代码设计、结构和可读性（从而减少了技术债务），但它不会改变代码的行为  

  在开始重构代码之前，必须具备以下三个支持系统：  
  1. 测试（通常来说，最低要求是要有JUnit测试），因此你可以确保自己的重构不会改变代码的行为
  2. 构建自动化，从而容易构建代码并运行所有测试。这样就可以轻松进行小的改动,并验证是否破坏了任何东西
  3. 版本控制，这样就可以随时提供或回退到可工作的代码版本，并跟踪这个过程中的所有操作
  没有这三个系统，重构几乎是不可能的。事实上.如果没有这些，构建、维护和添加代码就会立刻成为一个巨大的挑战

# 持续集成
  人们一次只能管理一个步骤，因此他们相信自己是在“ 通道”中前进，每个幵发阶段都会无缝衔接。  
  这种错觉通常被称为软件开发的“ 布模型”(TheWaterfall Model )  

  根据来自流水线的思维方式，每个开发阶段都有自己的团队。上游团队的进度表被传递给下游团队，当开始测试和整合时，这些团队被期望以某种方式赶上进度.当他们不可避免地失败时，就会被认为是“不合格的团队成员”  

  极限编程：把可工作的产品————尽管功能非常少————交付到客户手中，并询问他们：  
  1. 这是不是他们想要的
  2. 他们是否喜欢这个产品的工作方式
  3. 他们还觉得哪些新功能会有用
  然后函新回到开发阶段来迭代新版本。一个版本接一个版本，项目最终发展成真正为客户创造价值的产品

  这完全颠粮了濕布模型的理念。你不再将产品测试和部署等环节放到“最后一步”  

  持续集成（continuous integration, CI ）  
  当前CI技术的顶点是持续集成服务器（continuous integration server ）。这是一台单独的机器或虚拟机，通常是第三方公司托管的完全独立的服务  
  CI服务器一开始是一个完全空白的平台，只有最精简的可用操作系统。这很重要，因为如果你在开发机器上安装了某个东西，可能会很容易就忘记将其包含在你的构建和部署系统中  

  就像重构一样，持续集成也有一些基本要求，包括分布式版本控制、构建自动化和自动化测试。  
  CI服务器通常会绑定到你的版本控制存储库。当CI服务器发现存储库有变更时,就会检出最新版本，并幵始运行CI脚本中指定的过程  

  使用持续集成时，你签入存储库的每个变更都会被从头到尾自动验证。通过这种方式,你可以立即发现是否有问题。  
  更好的一点是，当你准备发布产品的新版本时，不会有任何延迟或任何额外的必要步骤［能够随时交付，也就是持续交付(Continuous Delivery)］  

# 总结
  “它在我的机器上能正常运行。” “我们不会把你的机器连同它一起发布！”  

  代码验证不是单一的过程或技术。任何一种方法都只能找到特定类别的错误。  
  作为一名程序员，随着你的持续成长，你了解到的每一种额外的技术都会增加代码的可靠性和盘健性。  
  现代幵发不仅仅意味着编写代码，而旦还意味着融入开发过程中的每一种测试技术————尤其是为适应特定应用程序而创建的自定义工具————可以带来更好、更快、更愉快的幵发过程以及更高的价值，并为客户提供更满意的体验  
  
