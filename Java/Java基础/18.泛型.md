普通的类和方法一般需要依赖具体的类型：要么是基本类型，要么是类类型。如果要编写跨类型的代码.这种硬性的机制就会带来过多的限制  

多态是面向对象的一种泛化手段：你可以这么实现：编写一个方法，并以某个基类为参数，然后在使用该方法的时候就可以传入该基类的任何子类了————包括尚未创建的类  

单一继承层次结构的限制太多，因为你必须从该层継承来生成符合方法参数要求的对象。如果将方法的参数从类改成接口，就能解除该限制，从而可以泛化到支持该接口的任何实现类  

有时甚至接口也会太过严格。接口仍然要求你的代码依赖于该特定接口。如果可以让代码只需依赖于“某种不具体指定的类型”，而不是某个特定的接口或类，那么你就可以编写出更为通用的代码  

这便是泛型（Java 5最重大的变化之一）的概念。  
泛型可以生成参数化类型.这样你就可以创建适用于多种类型的组件（主要用于集合）   
术语“泛型”的意思是“适用或者可兼容大批的类”  

参数化类型机制：使用别人的泛型类型通常会比较容易，但是创建自己的泛型类型时则容易发生很多意外  

# 和C++的对比
  接下来要进行Java泛型和C++泛型之间的比较，主要基于两个原因：  
  - 第一个原因是，对C++模板（泛型的主要灵感以及基本语法的来源）某些方面的理解有助于掌握（泛型）概念的基础，以及非常重要的一点————理解Java泛型的限制和这些限制存在的原因。终极目标是使你通过对各种边界情况的清晰理解,成为更强大的程序员。而淸楚哪些事情不能做，能让你更好地利用那些你所能做的事情（部分原因是可以让你无须浪费时间走死胡同了）。
  - 第二个原因是，Java社区对C++模板的理解存在重大分歧，而这种分歧会逬一步加深你对泛型（所要实现的）目标的疑惑

# 简单泛型
  泛型最重要的初衷之一，是用于创建集合类。  
  集合是一种可以用来持有其他类型对象的对象.数组也有同样的作用，不过集合往往比简单的数组更灵活，而且具有不同的特性  
  实际上所有的程序都需要你在使用一组对象的时候拥有持有这些对象的能力，因此集合是复用性最高的库之一  

  ```java
  public class ObjectHolder {
    private Object a;
    public ObjectHolder(Object a) { this.a = a;}
    public void set(Object a) ( this.a = a; )
    public Object get() ( return a; )
    public static void main(String[] args) {
      ObjectHolder h2 =
        new ObjectHolder(new Automobile() )；
      Automobile a = (Automobile)h2.get();
      h2.set("Not an Automobile");
      String s = (String)h2.get();
      h2.set(l);               // 自动装箱为 Integer
      Integer x = (Integer)h2.get();
    }
  }
  ```
  - 这样ObjectHolder就可以持有任何东西了————在本例中，ObjectHolder持有了3个不同类型的对象

  在个别情况下，你会想要能持有多个不同类型对象的集合，但是大多数时候，你只会将一种类型的对象保存到某个特定的集合对象  
  泛型的主要目的之一是指定集合能持有的对象类型，并且通过编译器来强制执行该规范  

  因此相较于Object,我们更倾向于指定一个类型占位符，并在晩些时候再决定（具体的类型）  
  要实现这个目的，你需要在类名后的尖括号内放置一个类型参数，然后在使用该类的时候再将其替换为实际的类型  
  ```java
  public class GenericHolder<T> {
    private T a;
    public GenericHolder() {}
    public void set(T a) { this.a = a;}
    public T get() { return a; }
    public static void main(String[] args) {
      GenericHolder<Automobile> h3 =
        new GenericHolder<Automobile>();
      h3.set(new Automobile());       // 类型已检查
      Automobile a = h3.get();        //不需要转型
      //- h3.set("Not an Automobile"); // Error
      //- h3.set(1); // Error
    }
  }
  ```

  Java泛型的核心理念：只需告诉泛型所需的类型，剩下的全部细节就可以都交给它了  
  
  你会注意到h3的定义相当冗长旦多余。在等号的左侧，你声明了GenericHolderAutomobile>，然后在等号的右侧再次声明了同样的东西  
  在Java 5问世的时候，这种啰唆的方式总被解释为“必须这么做”,但是到了Java 7.设计者们修正了该问题题(而删繁就简随之便被吹嘘为优秀的特性)：  
  ```java
  public class Diamond<T> {
    public static void main(String[] args) {
      GenericHolder<Automobile> h3 = 
        new GenericHolder<>();
    }
  }
  ```
  - h3定义的右侧现在使用了 “钻石”语法，而不用再将左边的类型信息复制一遍

## 元组库
  你常常会通过一次方法调用返回多个对象。  
  由于return语句只能返回一个对象，因此解决的办法是创建一个可持有多个对象的对象，然后返回该对象  

  这个概念被称为元组(tuple),它将一组对象一起包装进了一个对象：该对象的接收方可以读取其中的元素，但不能往里放入新元素————这个概念也称为数据传输对象(Data Transfer Object)或者信使(Messenger)  

  元组一般无长度限制.其中的每个对象都可以是不同的类型；不过我们会指定每个元素的类型，并旦保证接收方读取元素值时得到的是正确的类型。对于多种不同长度的问题，我们通过创建多个不同的元组来解决。  
  ```java
  public class Tuple2<A, B> {
    public final A al;
    public final B a2;
    public Tuple2(A a, B b) { al = a; a2 = b; }
    public String rep() { return al + ", " + a2; }
    @Override public String toString() {
      return " (" + rep() + ")";
    }
  }
  ```
  - 构造器会获取要保存的对象。元组则隐式地按顺序存放各个元素
  - al和a2不是private的，调用方仍然可以读取这两个对象，并对它们进行任何操作，但是它们无法将al和a2赋值给任何其他东西
  - 因此final声明的方式可以为你提供与private相等的安全性，但形式更简洁紧凑

  如要使用元组，你就需要为函数定义长度合适的元组来作为返回值.然后创建该元组并返回：  
  ```java
  public class TupleTest {
    static Tuple2<String, Integer> f() {
      //自动装箱将int转换为Integer：
      return new Tuple2<>("hi", 47);
    }
    static Tuple3<Amphibian, String, Integer> g() {
      return new Tuple3<>(new Amphibian(), "hi", 47);
    }
    static
    Tuple4<Vehicle, Amphibian, String, Integer> h() {
      return
        new Tuple4()(
          new Vehicle(), new Amphibian(), "hi", 47);
    }
    static
    Tuple5<Vehicle, Amphibian, String, Integer, Double> k() {
      return new
        Tuple5<>(
          new Vehicle(), new Amphibian(), "hi", 47, 11.1);
    }
    public static void main(String[] args) {
      Tuple2<String, Integer> ttsi = f();
      System.out.println(ttsi);
      // ttsi.al = "there"; // Compile error: final
      System.out.println(g());
      System.out.println(h());
      System.out.println(k());
    }
  }
  ```
  ```java
  /*输出:
  (hi, 47)
  (Amphibian@lc7c054, hi, 47)
  (Vehicle@14991ad, Amphibian@d93b30, hi, 47)
  (Vehicle@al4482, Amphibian(ai40el9d, hi, 47, 11.1)
  */
  ```
  
  有了泛型，只需编写该表达式，就可以很轻松地创建任何元组来返回任意一组类型  

## 栈类
  ```java
  public class LinkedStack<T> {
    private static class Node<U> {
      U item;
      Node<U> next;
      Node() { item = null; next = null; }
      Node(U item, Node<U> next) {
        this.item = item;
        this.next = next;
      }
      boolean end() {
        return item == null && next == null;
      }
    }
    private Node<T> top = new Node<>(); // 末端哨兵(end sentinel)
    public void push(T item) {
      top = new Node<>(item, top);
    }
    public T pop() {
      T result = top.item;
      if(!top.end())
        top = top.next;
      return result;
    }
    public static void main(String[] args) {
      LinkedStack<String> lss = new LinkedStacko();
      for(String s : "Phasers on stun!".split(" "))
        Iss.push(s);
      String s;
      while((s = lss.pop()) != null)
        System.out.printLn(s);
    }
  }
  ```
  ```java
  /*输出：
  stun！
  on
  Phasers
  */
  ```
  - 内部类Node同样也是泛型,并且有着自己的类型参数
  - 以上示例利用了末端哨兵(end sentinel)来检查栈何时为空

## RandomList
  ```java
  public class RandomList<T> extends ArrayList<T> {
    private Random rand = new Random(47);
    public T select() {
      return get(rand.nextInt(size()));
    }
    public static void main(String[] args) {
      RandomList<String> rs = new RandomList<>();
      Arrays.stream(
        ("The quick brown fox jumped over " +
        "the lazy brown dog").split(" "))
        .forEach(rs::add);
      IntStream.range(0, 11).forEach(i ->
        System.out.print(rs.select() + " "));
    }
  }
  ```
  ```java
  /*输出：
  brown over fox quick quick dog brown The brown lazy brown
  */
  ```
  - 由于RandomList (随机列表)继承自ArrayList,因此它拥有ArrayList中的全部内建行为

# 泛型接口
  泛型同样可用于接口  
  生成器(generator)是一种用于创建对象的类。生成器实际上是工厂方法(Factory Method )设计模式的一种特殊形式，只是在向生成器
请求创建新对象时，无须向其传入任何参数，而通常在使用工厂方法时都会向其中传入参数  
  java.util.function库将生成器定义为Supplier,其中的生成方法则称为get()。get()的返回类型被参数化为T  
  ```java
  public class CoffeeSupplier
  implements Supplier<Coffee>, Iterable<Coffee> {
    private Class<?>[] types = { Latte.class, Mocha.class,
      Cappuccino.class, Americano.class, Breve.class, };
    private static Random rand = new Random(47);
    public CoffeeSupplier() {}
    //迭代：
    private int size = 0;
    public CoffeeSupplier(int sz) { size = sz; }
    @Override public Coffee get() {
      try {
        return (Coffee)
          types [rand.nextInt(types.length)]
          .getConstructor().newInstance();
      //报告运行时程序错误：
        } catch(InstantiationException |
                NoSuchMethodException |
                InvocationTargetException |
                IllegalAccessException e) {
        throw new RuntimeException(e);
      }
    }
    class Coffeeiterator implements Iterator<Coffee> {
      int count = size;
      @Override
      public boolean hasNext() { return count > 0; }
      @Override public Coffee next() {
        count--;
        return CoffeeSupplier.this.get();
      }
      @Override
      public void removed {         // 未实现
        throw new Unsu叩ortedOperationException();
      }
    }
    @Override public Iterator<Coffee> iterator() {
      return new CoffeeIterator();
    }
    public static void main(String[] args) {
      Stream.generate(new CoffeeSupplier())
        .limit(5)
        .forEach(System.out::println);
      for(Coffee c : new CoffeeSupplier(5))
          System.out.println(c);
    }
  }
  ```
  ```
  /*给出：
  Americano 0
  Latte 1
  Americano 2
  Mocha 3
  Mocha 4
  Breve 5
  Americano 6
  Latte 7
  Cappuccino 8
  Cappuccino 9
  */
  ```
  - 参数化的Supplier接口会确保get()方法返回的是参数类型
  - CoffeeSupplier同样实现了Iterable接口，因此它可以在for-in语句中使用
  - 不过它必须知道何时该停止，而这是由第二个构造器指定的

  ```java
  public class Fibonacci implements Supplier<Integer> {
    private int count = 0;
    @Override
    public Integer get() { return fib(count++); }
    private int fib(int n) {
      if(n < 2) return 1;
      return fib(n-2) + fib(n-l);
    }
    public static void main(String[] args) {
      Stream.generate(new Fibonacci())
      .limit(18)
      .map(n -> n + " ")
      .forEach(System.out::print);
    }
  }
  ```
  ```java
  /*输出:
  1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584
  */
  ```
  
  虽然我们在该类的内外部使用的都是int,但是类型参数是Integer这引出了Java泛型的限制之一：无法将基本类型作为类型参数  
  Java 5的自动装箱和自动拆箱机制实现了从基本类型到包装类型的双向转换  

# 泛型方法
  还可以对类内部的方法进行参数化。类自身可以是泛型的,也可以不是————这和是否存在参数化的方法无关  
  准则：“尽量”使用泛型方法。相比于泛型化整个类，泛型化单个方法通常来说会更淸晰  

  要定义一个泛型方法，需要将泛型参数列表放在返回类型声明之前：  
  ```java
  public class GenericMethods {
    public <T> void f(T x) {
      System.out.printin(x.getClass().getName());
    )
    public static void main(String[] args) {
      GenericMethods gm = new GenericMethods();
      gm.f("");
      gm.f(1);
      gm.f(1.0);
      gm.f(1.0F);
      gm.f('c');
      gm.f(gm);
    }
  }
  ```
  ```java
  /*输出：
  java.lang.St ring
  java.lang.Integer
  java.lang.Double
  java.lang.Float
  java.lang.Character
  GenericMethods
  */
  ```
  - 使用泛型类时，在实例化类的时候必须指定类型参数
  - 使用泛型方法的时候，通常不需要指定参数类型，因为编译器会为你检测出来————类型参数推断(type argument inference )
  - 在用基本类型调用f()方法时，自动装箱机制便会生效，将基本类型自动包装为相应的对象

## 可变参数和泛型方法
  泛型方法和可变参数列表可以和平共处:  
  ```java
  public class GenericVarargs {
    @SafeVarargs
    public static <T> List<T> makeList(T... args) {
      List<T> result = new ArrayList<>();
      for(T item : args)
        result.add(item);
      return result;
    }
    public static void main(String[] args) {
      List<String> ls = makeList("A");
      System.out.printIn(ls);
      ls = makeList("A", "B", "C");
      System.out.printIn(ls);
      ls = makeList(
        "ABCDEFFHIJKLMNOPQRSTUVWXYZ".split(""));
      System.out.println(Is);
    }
  }
  ```
  ```java
  /*输出:
  [A]
  [A, B, C]
  [A, B, C, D, E, F, F, H, I, J, K, L, M, N, 0, P, Q, R,
  S, T, U, V, W, X, Y, Z]
  */
  ```
  - 这里的makeList()方法实现了和标准库中的java.util.Arrays.asList()方法一样的功能
  - @SafeVarargs注解表示我们承诺不会对变量参数列表做任何修改

## 通用 Supplier
  以下示例中的类可以为任何具有无参构造器的类生成一个Supplier  
  ```java
  public class BasicSupplier<T> implements Supplier<T> {
    private Class<T> type;
    public BasicSupplier(Class<T> type) {
      this.type = type;
    }
    @Override public T get() {
      try {
        //假定类型是public的英:
        return type.getConstructor().newlnstance();
      } catch(InstantiationException |
              NoSuchMethodException |
              InvocationTargetException |
              IllegalAccessException e) {
        throw new RuntimeException(e);
      }
    }
    //基于类型标记生成默认的Supplier：
    public static <T> Supplier<T> create(Class<T> type) {
      return new BasicSupplier<>(type);
    }
  }
  ```
  该类提供了为符合以下条件的类生成对象的基本实现:  
  1. 该类是public的
  2. 该类具有无参构造器

  泛型的create()方法提供了更为方便的语法 BasicSupplier.create(MyType.class),  
  而不是麻烦的 new BasicSupplier<MyType>(MyType.class)  

  泛型方法减少了生成Supplier对象所必需的代码编写量。 Java泛型强制要求传入Class对象  

## 简化元组的使用
  ```java
  public class Tuple {
    public static <A, B> Tuple2<A, B> tuple(A a, B b) {
      return new Tuple2<>(a, b);
    }
    public static <A, B, C> Tuple3<A, 8, C>
    tuple(A a, B b, C c) {
      return new Tuple3<>(a, b, c);
    }
    public static <A, B, C, D> Tuple4<A, B, C, D>
    tuple(A a, B b, C c, D d) {
      return new Tuple4<>(a, b, c, d);
    }
    public static <A, B, C, D, E>
    Tuple5<A, B, C, D, E> tuple(A a, B b, C c, D d, E e) {
      return new Tuple5<>(a, b, c, d, e);
    }
  }

  public class TupleTest2 {
    static Tuple2<String, Integer> f() {
      return tuple("hi", 47);
    }
    static Tuple2 f2() { return tuple("hi", 47); }
    static Tuple3<Amphibian, String, Integer> g() {
      return tuple(new Amphibian(), "hi", 47);
    }
    static
    Tuple4<Vehiclef Amphibian, String, Integer> h() {
      return tuple(
        new Vehicle(), new Amphibian(), "hi", 47);
    }
    static
    Tuple5<Vehicle, Amphibian,
        String, Integer, Double> k() {
      return tuple(new Vehicle(), new Amphibian()，
        "hi", 47, 11.1);
    }
    public static void main(String[] args) {
      Tuple2<String, Integer> ttsi = f();
      System.out.println(ttsi);
      System.out.println(f2());
      System.out.println(g());
      System.out.println(h());
      System.out.println(k());
    }
  }
  ```
  ```java
  /*输出:
  (hi, 47)
  (hi, 47)
  (Amphibian@a298b7, hi, 47)
  (Vehicle@16d3586, Amphibian@154617c, hi, 47)
  (Vehicle@17327b6, Amphibian@14ae5a5, hi, 47, 11.1)
  */
  ```
  - f()方法返回了参数化的Tuple2对象，而f2()则返回了未参数化的Tuple2对象
  - 由于返回值并未以参数化的方式使用，因此编译器并未对f2()方法产生警告。某种意义上，它被“向上转型”成了未参数化的Tuple2。不过，如果你试图获取f2()的结果并放入参数化的Tuple2,编译器便会产生警告

## Set实用工具
  ```java
  public class Sets {
    public static <T> Set<T> union(Set<T> a, Set<T> b) {
      Set<T> result = new HashSet<>(a);
      result.addAll(b);
      return result;
    }
    public static <T>
    Set<T> intersection(Set<T> a, Set<T> b) {
      Set<T> result = new HashSet<>(a);
      result.retainAll(b);
      return result;
    }
    //从超集中减去子集：
    public static <T> Set<T>
    difference(Set<T> superset, Set<T> subset) {
      Set<T> result = new HashSet<>(superset);
      result.removeAll(subset);
      return result;
    }
    //反过来——所有不在交集中的元素：
    public static
    <T> Set<T> complement (Set<T> a, Set<T> b) {
      return difference(union(a, b), intersection(a, b));
    }
  }
  ```
  - 前三个方法将第一个参数的引用复制到了一个新的HashSet对象中，从而复制了该参数，这样作为参数的Set就不会被直接修改了  

  可以通过EnumSet轻松地根据枚举生成Set。静态方法EnumSet.range()指定了选取范围的头尾边界元素，用于创建结果Set。
  ```java
  Set<Watercolors> set2 =
    EnumSet.range(CERULEAN_BLUE_HUE, BURNT_UMBER);
  ```

  用Sets.diffeience()演示了 java.util中的各Collection和Map类之间的区别：  
  ```java
  public class CollectionMethodDifferences {
    static Set<String> methodSet(Class<?> type) {
      return Arrays.stream( type.getMethods ())
        .map(Method::getName)
        .collect(Collectors.toCollection(TreeSet::new));
    }
    static void interfaces(Class<?> type) {
      System.out .print("Interfaces in " +
        type.getSimpleName() + ":");
      System.out.println(
        Arrays.stream(type.getInterfaces())
          .map(Class::getSimpleName)
          .collect(Collectors.toList()));
    }
    static Set<String> object = methodSet(Object.class);
    static { object.add("clone"); }
    static void
    difference(Class<?> superset, Class<?> subset) {
      System.out.print(superset.getSimpleName() +
        "extends " + subset.getSimpleName() +
        "，adds: ");
      Set<String> comp = Sets.difference(
        methodSet(superset), methodSet(subset));
      comp.removeAll(object);       // 忽略 Object 类的方法
      System.out.println(comp);
      interfaces(superset);
    }
    public static void main(String[] args) (
      System.out.println("Collection: " +
        methodSet(Collection.class));
      interfaces(Collection.class);
      difference(Set.class, Collection.class);
      difference(HashSet.class, Set.class);
      difference(LinkedHashSet.class, HashSet.class);
      difference(TreeSet.class, Set.class);
      difference (List .class, Collection.class);
      difference(ArrayList.class, List.class);
      difference(LinkedList.class, List.class);
      difference(Queue.class, Collection.class);
      difference(PriorityQueue.class, Queue.class);
      System.out.println("Map: " + methodSet(Map.class));
      difference(HashMap.class, Map.class);
      difference(LinkedHashMap.class, HashMap.class);
      difference(SortedMap.class, Map.class);
      difference(TreeMap.class, Map.class);
    }
  }
  ```
  ```java
  /*输出：
  Collection: [add, addAll, clear, contains, containsAll,
  equals, forEach, hashCode, isEmpty, iterator,
  parallelstream, remove, removeAll, removelf, retainAll,
  size, spliterator, stream, toArray]
  Interfaces in Collection: [Iterable]
  Set extends Collection, adds:[]
  Interfaces in Set: [Collection]
  HashSet extends Set, adds:[]
  Interfaces in HashSet: [Set, Cloneable, Serializable]
  LinkedHashSet extends HashSet, adds:[]
  Interfaces in LinkedHashSet: [Set, Cloneable,
  Serializable]
  TreeSet extends Set, adds: [headSet,
  descendinglterator, descendingSet, pollLast, subSet,
  floor, tailSet, ceiling, last, lower, comparator,
  pollFirst, first, higher]
  Interfaces in TreeSet: [NavigableSet, Cloneable,
  Serializable]
  List extends Collection, adds: [replaceAll, get,
  indexOf, subList, set, sort, lastlndexOf, listlterator]
  Interfaces in List: [Collection]
  ArrayList extends List, adds: [trimToSize,
  ensureCapacity]
  Interfaces in ArrayList: [List, RandomAccess,
  Cloneable, Serializable]
  LinkedList extends List, adds: [offerFirst, poll,
  getLast, offer, getFirst, removeFirst, element,
  removeLastOccurrence, peekFirst, peekLast, push,
  pollFirst, removeFirstOccurrence, descendinglterator,
  pollLast, removeLast, pop, addLast, peek, offerLast,
  addFirst]
  Interfaces in LinkedList: (List, Deque, Cloneable,
  Serializable]
  Queue extends Collection, adds: [poll, peek, offer,
  element]
  Interfaces in Queue: [Collection]
  PriorityQueue extends Queue, adds: [comparator]
  Interfaces in PriorityQueue: [Serializable]
  Map: [clear, compute, computelfAbsent,
  computelfPresent, containsKey, containsValue, entrySet,
  equals, forEach, get, getOrDefault, hashCode, isEmpty,
  keyset, merge, put, putAll, putlfAbsent, remove,
  replace, replaceAll, size, values]
  HashMap extends Map, adds:[]
  Interfaces in HashMap： [Map, Cloneable, Serializable]
  LinkedHashMap extends HashMap, adds:[]
  Interfaces in LinkedHashMap: [Map]
  SortedMap extends Map, adds: [LastKey, subMap,
  comparator, firstKey, headMap, tailMap]
  Interfaces in SortedMap: [Map]
  TreeMap extends Map, adds: [descendingKeySet,
  navigableKeySet, higherEntry, higherKey, floorKey,
  subMap, ceilingKey, pollLastEntry, firstKey, lowerKey,
  headMap, tailMap, lowerEntry, ceilingEntry,
  descendingMap, pollFirstEntry, LastKey, firstEntry,
  floorEntry, comparator, lastEntry]
  Interfaces in TreeMap: [NavigableMap, Cloneable,
  Serializable]
  */
  ```

# 构建复杂模型
  泛型有个重要的好处，即具有简单旦安全地创建复杂模型的能力  
  ```java
  class Product {
    private final int id;
    private String description;
    private double price;
    Product(int idNumber, String descr, double price) {
      id = idNumber;
      description = descr;
      this.price = price;
      System.out.println(toString())；
    }
    @Override public String toString() {
      return id + "： " + description +
        ", price: $" + price;
    }
    public void priceChange(double change) (
      price += change
    }
    public static Supplier<Product> generator =
      new Supplier<Product>() {
        private Random rand = new Random(47);
        @Override public Product get() {
          return new Product(rand.nextlnt(1000), "Test",
            Math.round(
              rand.nextDouble() * 1000.0) + 0.99);
        }
      };
  }

  class Shelf extends ArrayList<Product> {
    Shelf(int nProducts) {
      Suppliers.fill(this, Product.generator, nProducts);
    }
  }
  class Aisle extends ArrayList<Shelf> {
    Aisle(int nShelves, int nProducts) {
      for(int i = 0; i < nShelves; i++)
        add(new Shelf(nProducts));
    }
  }
  class Checkoutstand {}
  class Office {}

  public class Store extends ArrayList<Aisle> {
    private ArrayList<CheckoutStand> checkouts =
      new ArrayList<>();
    private Office office  =new Office();
    public Store(
      int nAisles, int nShelves, int nProducts) {  
      for(int i = 0; i < nAisles; i++)
        add (new Aisle(nShelves, nProducts));
    }
    @Override public String toString() {
      StringBuilder result = new StringBuilder();
      for(Aisle a : this)
        for(Shelf s : a)
          for(Product p : s) {
            result.append(p);
            result.append("Xn");
          }
      return result.toString();
    }
    public static void main(String[] args) {
      System.out.println(new Store(5, 4, 3));
    }
  }
  ```
  ```java
  /* 输出：(First 8 Lines)
  258: Test, price: $490.99
  861: Test, price: $160.99
  868: Test, price: $417.99
  207: Test, price: $268.99
  551: Test, price: S114.99
  278: Test, price: $804.99
  520: Test, price: $554.99
  140: Test, price: $530.99
  ...
  */
  ```
  - 从Store.toString()方法可以看出效果：集合具有很多层.但仍然是类型安全旦便于管理的
  - Suppliers.fill()接收一个Collection类（第一个参数）,并通过Supplier（第二个参数）将n（第三个参数）个元素填充逬该Collection

# 类型擦除的奥秘
  ```java
  public class ErasedTypeEquivalence {
    public static void main(String[] args) {
      Class cl = new ArrayList<String>().getClass();
      Class c2 = new ArrayList<Integer>().getClass();
      System.out.println(cl == c2);
    }
  }
  ```
  ```java
  /*输出：
  true
  */
  ```
  - ArrayList<Stiing>和ArrayList<Integer>应该是不同的类型,然而上面的程序会认为这两者是相同的类型

  ```java
  class Frob {}
  class Fnorkle {)
  class Quark<Q> {}
  class Particle<POSITION, M0MENTUM> {}

  public class Lostlnformation {
    public static void main(String[] args) {
      List<Frob> list = new ArrayList<>();
      Map<Frob, Fnorkle> map = new HashMap<>();
      Quark<Fnorkle> quark = new Quark<>();
      Particle<Long, Double> p = new Particle<>();
      System.out.println(Arrays.toString(
        list.getClass().getTypeParameters()));
      System.out.println(Arrays.toString(
        map.getClass().getTypeParameters()));
      System.out.println(Arrays.toString(
        quark.getClass().getTypeParameters()));
      System.out.println(Arrays.toString(
        p.getClass().getTypeParameters()));
    }
  }
  ```
  ```java
  /*输出：
  [E]
  [K, V]
  [Q]
  [POSITION, MOMENTUM]
  */
  ```
  - Class.getTypeParameters()会"返回一个由 TypeVariable 对象组成的数组，代表由泛型声明所声明的类型变量
  - 然而，如程序输出所示，你只能发现作为参数占位符的标识符

  泛型代码内部并不存在有关泛型参数类型的可用信息  
  你可以知道诸如类型参数的标识符和泛型类型的边界等信息，但你就是无法知道实际用于创建具体实例的类型参数  

  Java泛型是通过类型擦除实现的。这意味着在使用泛型时，任何具体的类型信息都将被擦除  
  List<String>和List<Integer>在运行时实际上是相同的类型。两者的类型都被“擦除”为它们的原始类型(raw type ): List  

## C++的实现方法
  ```c++
  #include <iostream>
  using namespace std;

  template<class T> class Manipulator {
    T obj;
  public:
    Manipulator(T x) { obj = x; }
    void manipulate() { obj.f(); }
  };

  class HasF {
  public:
    void f() { cout << "HasF::f()" << endl; }
  }

  int main() {
    HasF hf;
    Manipulater<HasF> manipulator(hf);
    manipulator.manipulate();
  }
  ```
  ```c++
  /*输出：
  HasF::f()
  */
  ```
  - C++编译器会在你实例化模板的时候进行检査，这样在实例化Manipulator<HasF>时.编译器便会看到HasF中存在方法f()。如果情况并非如此，就会出现编译时错误，从而保证了类型的安全
  - 用C++编写这类代码很简单,因为在实例化模板的时候.模板代码知道其自身模板参数的类型

  ```java
  public class HasF {
    public void f() {
      System.out.println( "HasF. f()");
    }
  }

  //示例剩余的部分，则会无法编译
  class Manipulator<T> {
    private T obj;
    Manipulator(T x) ( obj = x; }
    // Error: cannot find symbol: method f():
    public void manipulate() { obj.f(); }
  }

  public class Manipulation {
    public static void main(String[] args) {
      HasF hf = new HasF();
      Manipulator<HasF> manipulator =
        new Manipulator<>(hf);
      manipulator.manipulate();
    }
  }
  ```
  - 由于类型擦除的缘故，Java编译器无法将“manipulate()必须调用obj上的f()”的这个要求，关联到“HasF中存在f()方法”的这个事实上
  - 要调用f(),我们就必须帮助泛型类，为它指定边界，来告诉编译器只接受符合该边界的类型

  ```java
  class Manipulator2<T extends HasF> {
    private T obj;
    Manipulator2(T x) { obj = x; )
    public void manipulate(){ obj. f (); }
  }
  ```
  - 边界＜T extends HasF＞声明了 T必须是HasF类型或者其子类。如果符合这个条件,就可以安全地调用obj上的F()方法

  我们说泛型类型参数会被擦除为其第一个边界(你稍后会看到，多重边界也是可以的)  
  可以观察到，泛型在Manipulator2.java中没有做出任何贡献

  只有在类型参数比具体类型（及其所有子类）更加“泛型（泛化）” 的时候。也就是说，在希望代码能够跨多个类型运行的时候一泛型才会有所帮助  

  如果某个类有一个返回T的方法，那么泛型就能起作用.因为泛型可以让该方法返回精确的类型  
  ```java
  class ReturnGenericType<T extends HasF> (
    private T obj;
    ReturnGenericType(T x) { obj = x; )
    public T get() { return obj; }
  }
  ```

## 迁移的兼容性
  它是在Java泛型实现中必要的一种折中，因为泛型并不是这门语言与生俱来的一部分。这种折中会给你带来痛苦，所以尽早习惯它，并理解它为什么存在吧  
  如果泛型在Java 1.0的时候就是这门语言的一部分了，这个特性就不会用类型擦除来实现，而会通过具体化（reification）来将类型参数保持为第一类实体.这样你就可以对类型参数执行基于类型的语言操作和反射操作了  
  在基于类型擦除的实现中.泛型类型被视同于第二类类型处理.无法在某些重要的上下文中使用  
  泛型类型只在静态类型检查时期存在，在这之后.程序中所有的泛型类型都会被擦除，并替换为它们的非泛型上界。举例来说，List＜T＞这样的类型注解会被擦除为List,而普通的类型变量则被擦除为Object,除非指定了边界  

  类型擦除的核心初衷是，希望让泛化的调用方程序可以依赖于非泛化的库正常使用，反之亦然。这通常称为迁移兼容性  
  因此Java泛型不仅必须支持向后兼容性（即保证已有的代码和类文件都依旧是合法的，并且能继续保持原有的含义），而且还必须支持迁移兼容性.这样库才能按它们自己的节奏变得通用,并且一旦某个库变得通用了，便不会对依赖它的代码和程序造成破坏  
  类型擦除是唯一可行的方案。通过允许非泛型的代码和泛型代码共存，类型擦除实现了向泛型的迁移  

  要实现迁移兼容性，所有的库和程序都必须在是否使用了泛型这件事上各自保持无关。所以它们不能去检测其他库是否使用了泛型  

  如果没有某种迁移的途径，那么所有已经存在了很久的库都有可能要和选择迁移到Java泛型上的开发者们说再见了。库可以说是一门编程语言最有影响力的组成部分，因此这种代价是不可接受的。类型擦除是否是最佳甚至唯一的迁移途径，只有时间能给我们答案了  

## 类型擦除存在的问题
  类型擦除使得现有的非泛型调用方代码可以在不用修改的情况下继续使用，直至调用方做好了用泛型来重写代码的准备。这个动机非常有意义，因为它不会突然间破坏掉所有已有代码  
  类型擦除的代价也很大。泛型代码无法用于需要显式引用运行时类型的操作，比如类型转换 instanceof操作，以及new表达式  
  因为关于参数的所有类型信息都丢失了，所以在编写泛型代码时，你必须时刻提醒自己，你只是看起来掌握了参数的类型信息而已  

  ```java
  class Foo<T> {
    T var;
  }
  Foo<Cat> f = new Foo<>();
  ```
  class Foo中的代码看起来应该知道它现在是在使用Cat类。而泛型语法也在强烈暗示,类中各处的类型T都已经被替换了.如同C++中一样。但是并非如此.在为该类编写代码时.你必须时刻提醒自己，“不.它仍然只是一个Object”。  

  ```java
  class GenericBase<T> {
    private T element;
    public void set(T arg) ( element = arg; }
    public T get() { return element; }
  }
  class Derived1<T> extends GenericBase<T> {}
  class Derived2 extends GenericBase {} //未产生警告

  // class Derived3 extends GenericBase<?> {}
  //奇怪的错误：
  //  unexpected type
  //  required: class or interface without bounds

  public class ErasureAndInheritance {
    @SuppressWarnings("unchecked")
    public static void main(String[] args) {
      Derived2 d2 = new Derived2();
      Object obj = d2.get();
      d2.set(obj);       //此处出现警告
    }
  }
  ```
  - Derived2 继承自 GenericBase,但并未包含泛型参数.而编译器并未给出警告：直到调用set() ,警告才出现
  - 从Derived3产生的警告可以推断出，编译器期望的是一个原始的基类

  如果你希望将类型参数当作比Object更强大的武器，就需要付出额外的精力来管理边界  

## 边界的行为
  类型擦除的存在，使我发现了泛型最容易令人困惑的方面————可以将无意义的事物表达出来  
  ```java
  public class ArrayMaker<T> {
    private Class<T> kind;
    public ArrayMaker(Class<T> kind) { this.kind = kind; }
    @SuppressWarnings("unchecked")
    T[] create(int size) {
      return (T[])Array.newInstance(kind, size);
    }
    public static void main(String[] args) {
      ArrayMaker<String> stringMaker =
        new ArrayMakero(String.class);
      String[] stringArray = stringMaker.create(9);
      System.out.printin(Arrays.toString(stringArray));
    }
  }
  ```
  ```java
  /*输出:
  [null, null, null, null, null, null, null, null, null]
  */
  ```
  尽管kind看起来是被存储为Class<T>，但是类型擦除意味着它实际上只是被存为一个不带参数的Class  
  因此，在你使用它的时候，如同创建数组一样，Array.newInstance()并不实际掌握kind含有的类型信息。它无法生成具体的结果，因此必须进行类型转换，这会产生令人不悦的警告  
  注意对Array.newInstance()的使用，这是在泛型中创建数组的推荐方式  

  ```java
  public class ListMaker<T> {
    List<T> create() { return new ArrayList<>(); }
    public static void main(String[] args) {
      ListMaker<String> stringMaker = new ListMaker<>();
      List<String> stringList = stringMaker.create();
    }
  }
  ```
  - 尽管我们知道(由于类型擦除)，在create()内部的new ArrayList<>()方法中，<T>被移除了————在运行时，类中并没有<T>
  - 将表达式修改为new ArrayList(),缉译器会产生警告

  ```java
  public class FilledList<T> extends ArrayList<T> {
    FilledList(Supplier<T> gen, int size) {
      Suppliers.fill(this, gen, size);
    }
    public FilledList(T t, int size) {
      for(int i = 0; i < size; i++)
      this.add(t);
    }
    public static void main(String[] args) {
      List<String> list = new FilledListo("Hello", 4);
      System.out.printin(list);
      //用Supplier实现的版本：
      List<Integer> ilist = new FilledListo(() -> 47, 4);
      System.out.println(ilist);
    }
  }
  ```
  ```java
  /*输出:
  [Hello, Hello, Hello, Hello] 
  [47, 47, 47, 47]
  */
  ```
  - 尽管在add()内部，编译器无法知道任何关于T的信息。但仍然可以在编译时确保向FilledList中放入的是类型T。因此.即使类型擦除移除了方法或类中的实际类型信息，编译器仍然能够确保类型使用方式的内部一致性

  由于类型擦除移除了方法体中的类型信息，运行时的关键便指向了边界————对象进入和离开某个方法的临界点。  
  编译器会在编译时在临界点执行类型检查，并插入类型转换的代码  
  ```java
  public class SimpleHolder {
    private Object obj;
    public void set(Object obj) { this.obj = obj; }
    public Object get() { return obj; )
    public static void main(String[] args) {
      SimpleHolder holder = new SimpleHolder();
      holder.set("Item");
      String s = (String)holder.get();
    }
  }
  ```
  - 而在调用get()时则会对类型转换进行检查

  ```java
  public class GenericHolder2<T> {
    private T obj;
    public void set(T obj) ( this.obj = obj; )
    public T get() { return obj; }
    public static void main(String[] args) {
      GenericHolder2<String> holder = 
        new GenericHolder2<>():
      holder.set("Item");
      String s = holder.get();
    }
  }
  ```
  - 看起来get()中不再需要进行类型转换了，但是我们仍然知道传给set()的值经过了编译期类型检查
  - set()中对传入类型的额外检查工作是编译器自动执行的。而对get()输出值的类型转换仍然存在，但并不比你自己来实现做得少

  泛型所有的行为都发生在边界。包括对传入值额外的编译时检查，和对输出值插入的类型转换；记住“边界是行为发生的地方”，这有助于减少对类型擦除产生的困惑  

# 对类型擦除的补偿
  由于类型擦除的缘故，我们失去了在泛型代码中执行某些操作的能力。任何需要在运行时知道确切类型的操作都无法运行  
  ```java
  public class Erased<T> {
    private final int SIZE = 100;
    public void f(Object arg) {
      // error: illegal generic type for instanceof
      if(arg instanceof T) {}

      // error: unexpected type
      T var = new T();

      // error: generic array creation
      T[] array = new T[SIZE];

      // warning: [unchecked] unchecked cast
      T[] array = (T[])new Object[SIZE];
    }
  }
  ```

  你可以偶尔在编程时绕过这些问题，但是有时你必须通过引入类型标签(type tag)来补偿类型擦除导致的损失  
  类型标签则可以提供动态的isInstance()能力：  
  ```java
  class Building {}
  class House extends Building {}

  public class ClassTypeCapture<T> {
    Class<T> kind;
    public ClassTypeCapture(Class<T> kind) {
      this.kind = kind;
    )
    public boolean f(Object arg) {
      return kind.isInstance(arg);
    }
    public static void main(String[] args) {
      ClassTypeCapture<Building> cttl =
        new ClassTypeCaptureo(Building.class);
      System.out.printin(cttl.f(new Building()))；
      System.out.printin(cttl.f(new House()));
      ClassTypeCapture<House> ctt2 =
        new ClassTypeCaptureo(House.class);
      System.out.println(ctt2.f(new Building()));
      System.out.println(ctt2.f(new House()));
    }
  }
  ```
  ```java
  /*输出：
  true
  true
  false
  true
  */
  ```
  编译器保证了类型标签能够和泛型参数匹配  

## 创建类型实例
  创建new T()是不会成功的，部分原因是类型擦除，另一部分原因是编译器无法验证T中是否存在无参构造器  

  







