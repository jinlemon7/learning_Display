普通的类和方法一般需要依赖具体的类型：要么是基本类型，要么是类类型。如果要编写跨类型的代码.这种硬性的机制就会带来过多的限制  

多态是面向对象的一种泛化手段：你可以这么实现：编写一个方法，并以某个基类为参数，然后在使用该方法的时候就可以传入该基类的任何子类了————包括尚未创建的类  

单一继承层次结构的限制太多，因为你必须从该层継承来生成符合方法参数要求的对象。如果将方法的参数从类改成接口，就能解除该限制，从而可以泛化到支持该接口的任何实现类  

有时甚至接口也会太过严格。接口仍然要求你的代码依赖于该特定接口。如果可以让代码只需依赖于“某种不具体指定的类型”，而不是某个特定的接口或类，那么你就可以编写出更为通用的代码  

这便是泛型（Java 5最重大的变化之一）的概念。  
泛型可以生成参数化类型.这样你就可以创建适用于多种类型的组件（主要用于集合）   
术语“泛型”的意思是“适用或者可兼容大批的类”  

参数化类型机制：使用别人的泛型类型通常会比较容易，但是创建自己的泛型类型时则容易发生很多意外  

# 和C++的对比
  接下来要进行Java泛型和C++泛型之间的比较，主要基于两个原因：  
  - 第一个原因是，对C++模板（泛型的主要灵感以及基本语法的来源）某些方面的理解有助于掌握（泛型）概念的基础，以及非常重要的一点————理解Java泛型的限制和这些限制存在的原因。终极目标是使你通过对各种边界情况的清晰理解,成为更强大的程序员。而淸楚哪些事情不能做，能让你更好地利用那些你所能做的事情（部分原因是可以让你无须浪费时间走死胡同了）。
  - 第二个原因是，Java社区对C++模板的理解存在重大分歧，而这种分歧会逬一步加深你对泛型（所要实现的）目标的疑惑

# 简单泛型
  泛型最重要的初衷之一，是用于创建集合类。  
  集合是一种可以用来持有其他类型对象的对象.数组也有同样的作用，不过集合往往比简单的数组更灵活，而且具有不同的特性  
  实际上所有的程序都需要你在使用一组对象的时候拥有持有这些对象的能力，因此集合是复用性最高的库之一  

  ```java
  public class ObjectHolder {
    private Object a;
    public ObjectHolder(Object a) { this.a = a;}
    public void set(Object a) ( this.a = a; )
    public Object get() ( return a; )
    public static void main(String[] args) {
      ObjectHolder h2 =
        new ObjectHolder(new Automobile() )；
      Automobile a = (Automobile)h2.get();
      h2.set("Not an Automobile");
      String s = (String)h2.get();
      h2.set(l);               // 自动装箱为 Integer
      Integer x = (Integer)h2.get();
    }
  }
  ```
  - 这样ObjectHolder就可以持有任何东西了————在本例中，ObjectHolder持有了3个不同类型的对象

  在个别情况下，你会想要能持有多个不同类型对象的集合，但是大多数时候，你只会将一种类型的对象保存到某个特定的集合对象  
  泛型的主要目的之一是指定集合能持有的对象类型，并且通过编译器来强制执行该规范  

  因此相较于Object,我们更倾向于指定一个类型占位符，并在晩些时候再决定（具体的类型）  
  要实现这个目的，你需要在类名后的尖括号内放置一个类型参数，然后在使用该类的时候再将其替换为实际的类型  
  ```java
  public class GenericHolder<T> {
    private T a;
    public GenericHolder() {}
    public void set(T a) { this.a = a;}
    public T get() { return a; }
    public static void main(String[] args) {
      GenericHolder<Automobile> h3 =
        new GenericHolder<Automobile>();
      h3.set(new Automobile());       // 类型已检查
      Automobile a = h3.get();        //不需要转型
      //- h3.set("Not an Automobile"); // Error
      //- h3.set(1); // Error
    }
  }
  ```

  Java泛型的核心理念：只需告诉泛型所需的类型，剩下的全部细节就可以都交给它了  
  
  你会注意到h3的定义相当冗长旦多余。在等号的左侧，你声明了GenericHolderAutomobile>，然后在等号的右侧再次声明了同样的东西  
  在Java 5问世的时候，这种啰唆的方式总被解释为“必须这么做”,但是到了Java 7.设计者们修正了该问题题(而删繁就简随之便被吹嘘为优秀的特性)：  
  ```java
  public class Diamond<T> {
    public static void main(String[] args) {
      GenericHolder<Automobile> h3 = 
        new GenericHolder<>();
    }
  }
  ```
  - h3定义的右侧现在使用了 “钻石”语法，而不用再将左边的类型信息复制一遍

## 元组库
  你常常会通过一次方法调用返回多个对象。  
  由于return语句只能返回一个对象，因此解决的办法是创建一个可持有多个对象的对象，然后返回该对象  

  这个概念被称为元组(tuple),它将一组对象一起包装进了一个对象：该对象的接收方可以读取其中的元素，但不能往里放入新元素————这个概念也称为数据传输对象(Data Transfer Object)或者信使(Messenger)  

  元组一般无长度限制.其中的每个对象都可以是不同的类型；不过我们会指定每个元素的类型，并旦保证接收方读取元素值时得到的是正确的类型。对于多种不同长度的问题，我们通过创建多个不同的元组来解决。  
  ```java
  public class Tuple2<A, B> {
    public final A al;
    public final B a2;
    public Tuple2(A a, B b) { al = a; a2 = b; }
    public String rep() { return al + ", " + a2; }
    @Override public String toString() {
      return " (" + rep() + ")";
    }
  }
  ```
  - 构造器会获取要保存的对象。元组则隐式地按顺序存放各个元素
  - al和a2不是private的，调用方仍然可以读取这两个对象，并对它们进行任何操作，但是它们无法将al和a2赋值给任何其他东西
  - 因此final声明的方式可以为你提供与private相等的安全性，但形式更简洁紧凑

  如要使用元组，你就需要为函数定义长度合适的元组来作为返回值.然后创建该元组并返回：  
  ```java
  public class TupleTest {
    static Tuple2<String, Integer> f() {
      //自动装箱将int转换为Integer：
      return new Tuple2<>("hi", 47);
    }
    static Tuple3<Amphibian, String, Integer> g() {
      return new Tuple3<>(new Amphibian(), "hi", 47);
    }
    static
    Tuple4<Vehicle, Amphibian, String, Integer> h() {
      return
        new Tuple4()(
          new Vehicle(), new Amphibian(), "hi", 47);
    }
    static
    Tuple5<Vehicle, Amphibian, String, Integer, Double> k() {
      return new
        Tuple5<>(
          new Vehicle(), new Amphibian(), "hi", 47, 11.1);
    }
    public static void main(String[] args) {
      Tuple2<String, Integer> ttsi = f();
      System.out.println(ttsi);
      // ttsi.al = "there"; // Compile error: final
      System.out.println(g());
      System.out.println(h());
      System.out.println(k());
    }
  }
  ```
  ```java
  /*输出:
  (hi, 47)
  (Amphibian@lc7c054, hi, 47)
  (Vehicle@14991ad, Amphibian@d93b30, hi, 47)
  (Vehicle@al4482, Amphibian(ai40el9d, hi, 47, 11.1)
  */
  ```
  
  有了泛型，只需编写该表达式，就可以很轻松地创建任何元组来返回任意一组类型  

## 栈类
  ```java
  public class LinkedStack<T> {
    private static class Node<U> {
      U item;
      Node<U> next;
      Node() { item = null; next = null; }
      Node(U item, Node<U> next) {
        this.item = item;
        this.next = next;
      }
      boolean end() {
        return item == null && next == null;
      }
    }
    private Node<T> top = new Node<>(); // 末端哨兵(end sentinel)
    public void push(T item) {
      top = new Node<>(item, top);
    }
    public T pop() {
      T result = top.item;
      if(!top.end())
        top = top.next;
      return result;
    }
    public static void main(String[] args) {
      LinkedStack<String> lss = new LinkedStacko();
      for(String s : "Phasers on stun!".split(" "))
        Iss.push(s);
      String s;
      while((s = lss.pop()) != null)
        System.out.printLn(s);
    }
  }
  ```
  ```java
  /*输出：
  stun！
  on
  Phasers
  */
  ```
  - 内部类Node同样也是泛型,并且有着自己的类型参数
  - 以上示例利用了末端哨兵(end sentinel)来检查栈何时为空

## RandomList
  ```java
  public class RandomList<T> extends ArrayList<T> {
    private Random rand = new Random(47);
    public T select() {
      return get(rand.nextInt(size()));
    }
    public static void main(String[] args) {
      RandomList<String> rs = new RandomList<>();
      Arrays.stream(
        ("The quick brown fox jumped over " +
        "the lazy brown dog").split(" "))
        .forEach(rs::add);
      IntStream.range(0, 11).forEach(i ->
        System.out.print(rs.select() + " "));
    }
  }
  ```
  ```java
  /*输出：
  brown over fox quick quick dog brown The brown lazy brown
  */
  ```
  - 由于RandomList (随机列表)继承自ArrayList,因此它拥有ArrayList中的全部内建行为

# 泛型接口
  泛型同样可用于接口  
  生成器(generator)是一种用于创建对象的类。生成器实际上是工厂方法(Factory Method )设计模式的一种特殊形式，只是在向生成器
请求创建新对象时，无须向其传入任何参数，而通常在使用工厂方法时都会向其中传入参数  
  java.util.function库将生成器定义为Supplier,其中的生成方法则称为get()。get()的返回类型被参数化为T  
  ```java
  public class CoffeeSupplier
  implements Supplier<Coffee>, Iterable<Coffee> {
    private Class<?>[] types = { Latte.class, Mocha.class,
      Cappuccino.class, Americano.class, Breve.class, };
    private static Random rand = new Random(47);
    public CoffeeSupplier() {}
    //迭代：
    private int size = 0;
    public CoffeeSupplier(int sz) { size = sz; }
    @Override public Coffee get() {
      try {
        return (Coffee)
          types [rand.nextInt(types.length)]
          .getConstructor().newInstance();
      //报告运行时程序错误：
        } catch(InstantiationException |
                NoSuchMethodException |
                InvocationTargetException |
                IllegalAccessException e) {
        throw new RuntimeException(e);
      }
    }
    class Coffeeiterator implements Iterator<Coffee> {
      int count = size;
      @Override
      public boolean hasNext() { return count > 0; }
      @Override public Coffee next() {
        count--;
        return CoffeeSupplier.this.get();
      }
      @Override
      public void removed {         // 未实现
        throw new Unsu叩ortedOperationException();
      }
    }
    @Override public Iterator<Coffee> iterator() {
      return new CoffeeIterator();
    }
    public static void main(String[] args) {
      Stream.generate(new CoffeeSupplier())
        .limit(5)
        .forEach(System.out::println);
      for(Coffee c : new CoffeeSupplier(5))
          System.out.println(c);
    }
  }
  ```
  ```
  /*给出：
  Americano 0
  Latte 1
  Americano 2
  Mocha 3
  Mocha 4
  Breve 5
  Americano 6
  Latte 7
  Cappuccino 8
  Cappuccino 9
  */
  ```
  - 参数化的Supplier接口会确保get()方法返回的是参数类型
  - CoffeeSupplier同样实现了Iterable接口，因此它可以在for-in语句中使用
  - 不过它必须知道何时该停止，而这是由第二个构造器指定的

  ```java
  public class Fibonacci implements Supplier<Integer> {
    private int count = 0;
    @Override
    public Integer get() { return fib(count++); }
    private int fib(int n) {
      if(n < 2) return 1;
      return fib(n-2) + fib(n-l);
    }
    public static void main(String[] args) {
      Stream.generate(new Fibonacci())
      .limit(18)
      .map(n -> n + " ")
      .forEach(System.out::print);
    }
  }
  ```
  ```java
  /*输出:
  1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584
  */
  ```
  
  虽然我们在该类的内外部使用的都是int,但是类型参数是Integer这引出了Java泛型的限制之一：无法将基本类型作为类型参数  
  Java 5的自动装箱和自动拆箱机制实现了从基本类型到包装类型的双向转换  

# 泛型方法
  还可以对类内部的方法进行参数化。类自身可以是泛型的,也可以不是————这和是否存在参数化的方法无关  
  准则：“尽量”使用泛型方法。相比于泛型化整个类，泛型化单个方法通常来说会更淸晰  

  要定义一个泛型方法，需要将泛型参数列表放在返回类型声明之前：  
  ```java
  public class GenericMethods {
    public <T> void f(T x) {
      System.out.printin(x.getClass().getName());
    )
    public static void main(String[] args) {
      GenericMethods gm = new GenericMethods();
      gm.f("");
      gm.f(1);
      gm.f(1.0);
      gm.f(1.0F);
      gm.f('c');
      gm.f(gm);
    }
  }
  ```
  ```java
  /*输出：
  java.lang.St ring
  java.lang.Integer
  java.lang.Double
  java.lang.Float
  java.lang.Character
  GenericMethods
  */
  ```
  - 使用泛型类时，在实例化类的时候必须指定类型参数
  - 使用泛型方法的时候，通常不需要指定参数类型，因为编译器会为你检测出来————类型参数推断(type argument inference )
  - 在用基本类型调用f()方法时，自动装箱机制便会生效，将基本类型自动包装为相应的对象

## 可变参数和泛型方法
  泛型方法和可变参数列表可以和平共处:  
  ```java
  public class GenericVarargs {
    @SafeVarargs
    public static <T> List<T> makeList(T... args) {
      List<T> result = new ArrayList<>();
      for(T item : args)
        result.add(item);
      return result;
    }
    public static void main(String[] args) {
      List<String> ls = makeList("A");
      System.out.printIn(ls);
      ls = makeList("A", "B", "C");
      System.out.printIn(ls);
      ls = makeList(
        "ABCDEFFHIJKLMNOPQRSTUVWXYZ".split(""));
      System.out.println(Is);
    }
  }
  ```
  ```java
  /*输出:
  [A]
  [A, B, C]
  [A, B, C, D, E, F, F, H, I, J, K, L, M, N, 0, P, Q, R,
  S, T, U, V, W, X, Y, Z]
  */
  ```
  - 这里的makeList()方法实现了和标准库中的java.util.Arrays.asList()方法一样的功能
  - @SafeVarargs注解表示我们承诺不会对变量参数列表做任何修改

## 通用 Supplier
  以下示例中的类可以为任何具有无参构造器的类生成一个Supplier  
  ```java
  public class BasicSupplier<T> implements Supplier<T> {
    private Class<T> type;
    public BasicSupplier(Class<T> type) {
      this.type = type;
    }
    @Override public T get() {
      try {
        //假定类型是public的英:
        return type.getConstructor().newlnstance();
      } catch(InstantiationException |
              NoSuchMethodException |
              InvocationTargetException |
              IllegalAccessException e) {
        throw new RuntimeException(e);
      }
    }
    //基于类型标记生成默认的Supplier：
    public static <T> Supplier<T> create(Class<T> type) {
      return new BasicSupplier<>(type);
    }
  }
  ```
  该类提供了为符合以下条件的类生成对象的基本实现:  
  1. 该类是public的
  2. 该类具有无参构造器

  泛型的create()方法提供了更为方便的语法 BasicSupplier.create(MyType.class),  
  而不是麻烦的 new BasicSupplier<MyType>(MyType.class)  

  泛型方法减少了生成Supplier对象所必需的代码编写量。 Java泛型强制要求传入Class对象  

## 简化元组的使用
  ```java
  public class Tuple {
    public static <A, B> Tuple2<A, B> tuple(A a, B b) {
      return new Tuple2<>(a, b);
    }
    public static <A, B, C> Tuple3<A, 8, C>
    tuple(A a, B b, C c) {
      return new Tuple3<>(a, b, c);
    }
    public static <A, B, C, D> Tuple4<A, B, C, D>
    tuple(A a, B b, C c, D d) {
      return new Tuple4<>(a, b, c, d);
    }
    public static <A, B, C, D, E>
    Tuple5<A, B, C, D, E> tuple(A a, B b, C c, D d, E e) {
      return new Tuple5<>(a, b, c, d, e);
    }
  }

  public class TupleTest2 {
    static Tuple2<String, Integer> f() {
      return tuple("hi", 47);
    }
    static Tuple2 f2() { return tuple("hi", 47); }
    static Tuple3<Amphibian, String, Integer> g() {
      return tuple(new Amphibian(), "hi", 47);
    }
    static
    Tuple4<Vehiclef Amphibian, String, Integer> h() {
      return tuple(
        new Vehicle(), new Amphibian(), "hi", 47);
    }
    static
    Tuple5<Vehicle, Amphibian,
        String, Integer, Double> k() {
      return tuple(new Vehicle(), new Amphibian()，
        "hi", 47, 11.1);
    }
    public static void main(String[] args) {
      Tuple2<String, Integer> ttsi = f();
      System.out.println(ttsi);
      System.out.println(f2());
      System.out.println(g());
      System.out.println(h());
      System.out.println(k());
    }
  }
  ```
  ```java
  /*输出:
  (hi, 47)
  (hi, 47)
  (Amphibian@a298b7, hi, 47)
  (Vehicle@16d3586, Amphibian@154617c, hi, 47)
  (Vehicle@17327b6, Amphibian@14ae5a5, hi, 47, 11.1)
  */
  ```
  - f()方法返回了参数化的Tuple2对象，而f2()则返回了未参数化的Tuple2对象
  - 由于返回值并未以参数化的方式使用，因此编译器并未对f2()方法产生警告。某种意义上，它被“向上转型”成了未参数化的Tuple2。不过，如果你试图获取f2()的结果并放入参数化的Tuple2,编译器便会产生警告

## Set实用工具
  ```java
  public class Sets {
    public static <T> Set<T> union(Set<T> a, Set<T> b) {
      Set<T> result = new HashSet<>(a);
      result.addAll(b);
      return result;
    }
    public static <T>
    Set<T> intersection(Set<T> a, Set<T> b) {
      Set<T> result = new HashSet<>(a);
      result.retainAll(b);
      return result;
    }
    //从超集中减去子集：
    public static <T> Set<T>
    difference(Set<T> superset, Set<T> subset) {
      Set<T> result = new HashSet<>(superset);
      result.removeAll(subset);
      return result;
    }
    //反过来——所有不在交集中的元素：
    public static
    <T> Set<T> complement (Set<T> a, Set<T> b) {
      return difference(union(a, b), intersection(a, b));
    }
  }
  ```
  - 前三个方法将第一个参数的引用复制到了一个新的HashSet对象中，从而复制了该参数，这样作为参数的Set就不会被直接修改了  

  可以通过EnumSet轻松地根据枚举生成Set。静态方法EnumSet.range()指定了选取范围的头尾边界元素，用于创建结果Set。
  ```java
  Set<Watercolors> set2 =
    EnumSet.range(CERULEAN_BLUE_HUE, BURNT_UMBER);
  ```

  用Sets.diffeience()演示了 java.util中的各Collection和Map类之间的区别：  
  ```java
  public class CollectionMethodDifferences {
    static Set<String> methodSet(Class<?> type) {
      return Arrays.stream( type.getMethods ())
        .map(Method::getName)
        .collect(Collectors.toCollection(TreeSet::new));
    }
    static void interfaces(Class<?> type) {
      System.out .print("Interfaces in " +
        type.getSimpleName() + ":");
      System.out.println(
        Arrays.stream(type.getInterfaces())
          .map(Class::getSimpleName)
          .collect(Collectors.toList()));
    }
    static Set<String> object = methodSet(Object.class);
    static { object.add("clone"); }
    static void
    difference(Class<?> superset, Class<?> subset) {
      System.out.print(superset.getSimpleName() +
        "extends " + subset.getSimpleName() +
        "，adds: ");
      Set<String> comp = Sets.difference(
        methodSet(superset), methodSet(subset));
      comp.removeAll(object);       // 忽略 Object 类的方法
      System.out.println(comp);
      interfaces(superset);
    }
    public static void main(String[] args) (
      System.out.println("Collection: " +
        methodSet(Collection.class));
      interfaces(Collection.class);
      difference(Set.class, Collection.class);
      difference(HashSet.class, Set.class);
      difference(LinkedHashSet.class, HashSet.class);
      difference(TreeSet.class, Set.class);
      difference (List .class, Collection.class);
      difference(ArrayList.class, List.class);
      difference(LinkedList.class, List.class);
      difference(Queue.class, Collection.class);
      difference(PriorityQueue.class, Queue.class);
      System.out.println("Map: " + methodSet(Map.class));
      difference(HashMap.class, Map.class);
      difference(LinkedHashMap.class, HashMap.class);
      difference(SortedMap.class, Map.class);
      difference(TreeMap.class, Map.class);
    }
  }
  ```
  ```java
  /*输出：
  Collection: [add, addAll, clear, contains, containsAll,
  equals, forEach, hashCode, isEmpty, iterator,
  parallelstream, remove, removeAll, removelf, retainAll,
  size, spliterator, stream, toArray]
  Interfaces in Collection: [Iterable]
  Set extends Collection, adds:[]
  Interfaces in Set: [Collection]
  HashSet extends Set, adds:[]
  Interfaces in HashSet: [Set, Cloneable, Serializable]
  LinkedHashSet extends HashSet, adds:[]
  Interfaces in LinkedHashSet: [Set, Cloneable,
  Serializable]
  TreeSet extends Set, adds: [headSet,
  descendinglterator, descendingSet, pollLast, subSet,
  floor, tailSet, ceiling, last, lower, comparator,
  pollFirst, first, higher]
  Interfaces in TreeSet: [NavigableSet, Cloneable,
  Serializable]
  List extends Collection, adds: [replaceAll, get,
  indexOf, subList, set, sort, lastlndexOf, listlterator]
  Interfaces in List: [Collection]
  ArrayList extends List, adds: [trimToSize,
  ensureCapacity]
  Interfaces in ArrayList: [List, RandomAccess,
  Cloneable, Serializable]
  LinkedList extends List, adds: [offerFirst, poll,
  getLast, offer, getFirst, removeFirst, element,
  removeLastOccurrence, peekFirst, peekLast, push,
  pollFirst, removeFirstOccurrence, descendinglterator,
  pollLast, removeLast, pop, addLast, peek, offerLast,
  addFirst]
  Interfaces in LinkedList: (List, Deque, Cloneable,
  Serializable]
  Queue extends Collection, adds: [poll, peek, offer,
  element]
  Interfaces in Queue: [Collection]
  PriorityQueue extends Queue, adds: [comparator]
  Interfaces in PriorityQueue: [Serializable]
  Map: [clear, compute, computelfAbsent,
  computelfPresent, containsKey, containsValue, entrySet,
  equals, forEach, get, getOrDefault, hashCode, isEmpty,
  keyset, merge, put, putAll, putlfAbsent, remove,
  replace, replaceAll, size, values]
  HashMap extends Map, adds:[]
  Interfaces in HashMap： [Map, Cloneable, Serializable]
  LinkedHashMap extends HashMap, adds:[]
  Interfaces in LinkedHashMap: [Map]
  SortedMap extends Map, adds: [LastKey, subMap,
  comparator, firstKey, headMap, tailMap]
  Interfaces in SortedMap: [Map]
  TreeMap extends Map, adds: [descendingKeySet,
  navigableKeySet, higherEntry, higherKey, floorKey,
  subMap, ceilingKey, pollLastEntry, firstKey, lowerKey,
  headMap, tailMap, lowerEntry, ceilingEntry,
  descendingMap, pollFirstEntry, LastKey, firstEntry,
  floorEntry, comparator, lastEntry]
  Interfaces in TreeMap: [NavigableMap, Cloneable,
  Serializable]
  */
  ```

# 构建复杂模型
  泛型有个重要的好处，即具有简单旦安全地创建复杂模型的能力  
  ```java
  class Product {
    private final int id;
    private String description;
    private double price;
    Product(int idNumber, String descr, double price) {
      id = idNumber;
      description = descr;
      this.price = price;
      System.out.println(toString())；
    }
    @Override public String toString() {
      return id + "： " + description +
        ", price: $" + price;
    }
    public void priceChange(double change) (
      price += change
    }
    public static Supplier<Product> generator =
      new Supplier<Product>() {
        private Random rand = new Random(47);
        @Override public Product get() {
          return new Product(rand.nextlnt(1000), "Test",
            Math.round(
              rand.nextDouble() * 1000.0) + 0.99);
        }
      };
  }

  class Shelf extends ArrayList<Product> {
    Shelf(int nProducts) {
      Suppliers.fill(this, Product.generator, nProducts);
    }
  }
  class Aisle extends ArrayList<Shelf> {
    Aisle(int nShelves, int nProducts) {
      for(int i = 0; i < nShelves; i++)
        add(new Shelf(nProducts));
    }
  }
  class Checkoutstand {}
  class Office {}

  public class Store extends ArrayList<Aisle> {
    private ArrayList<CheckoutStand> checkouts =
      new ArrayList<>();
    private Office office  =new Office();
    public Store(
      int nAisles, int nShelves, int nProducts) {  
      for(int i = 0; i < nAisles; i++)
        add (new Aisle(nShelves, nProducts));
    }
    @Override public String toString() {
      StringBuilder result = new StringBuilder();
      for(Aisle a : this)
        for(Shelf s : a)
          for(Product p : s) {
            result.append(p);
            result.append("Xn");
          }
      return result.toString();
    }
    public static void main(String[] args) {
      System.out.println(new Store(5, 4, 3));
    }
  }
  ```
  ```java
  /* 输出：(First 8 Lines)
  258: Test, price: $490.99
  861: Test, price: $160.99
  868: Test, price: $417.99
  207: Test, price: $268.99
  551: Test, price: S114.99
  278: Test, price: $804.99
  520: Test, price: $554.99
  140: Test, price: $530.99
  ...
  */
  ```
  - 从Store.toString()方法可以看出效果：集合具有很多层.但仍然是类型安全旦便于管理的
  - Suppliers.fill()接收一个Collection类（第一个参数）,并通过Supplier（第二个参数）将n（第三个参数）个元素填充逬该Collection

# 类型擦除的奥秘
  ```java
  public class ErasedTypeEquivalence {
    public static void main(String[] args) {
      Class cl = new ArrayList<String>().getClass();
      Class c2 = new ArrayList<Integer>().getClass();
      System.out.println(cl == c2);
    }
  }
  ```
  ```java
  /*输出：
  true
  */
  ```
  - ArrayList<Stiing>和ArrayList<Integer>应该是不同的类型,然而上面的程序会认为这两者是相同的类型

  ```java
  class Frob {}
  class Fnorkle {)
  class Quark<Q> {}
  class Particle<POSITION, M0MENTUM> {}

  public class Lostlnformation {
    public static void main(String[] args) {
      List<Frob> list = new ArrayList<>();
      Map<Frob, Fnorkle> map = new HashMap<>();
      Quark<Fnorkle> quark = new Quark<>();
      Particle<Long, Double> p = new Particle<>();
      System.out.println(Arrays.toString(
        list.getClass().getTypeParameters()));
      System.out.println(Arrays.toString(
        map.getClass().getTypeParameters()));
      System.out.println(Arrays.toString(
        quark.getClass().getTypeParameters()));
      System.out.println(Arrays.toString(
        p.getClass().getTypeParameters()));
    }
  }
  ```
  ```java
  /*输出：
  [E]
  [K, V]
  [Q]
  [POSITION, MOMENTUM]
  */
  ```
  - Class.getTypeParameters()会"返回一个由 TypeVariable 对象组成的数组，代表由泛型声明所声明的类型变量
  - 然而，如程序输出所示，你只能发现作为参数占位符的标识符

  泛型代码内部并不存在有关泛型参数类型的可用信息  
  你可以知道诸如类型参数的标识符和泛型类型的边界等信息，但你就是无法知道实际用于创建具体实例的类型参数  

  Java泛型是通过类型擦除实现的。这意味着在使用泛型时，任何具体的类型信息都将被擦除  
  List<String>和List<Integer>在运行时实际上是相同的类型。两者的类型都被“擦除”为它们的原始类型(raw type ): List  

## C++的实现方法
  ```c++
  #include <iostream>
  using namespace std;

  template<class T> class Manipulator {
    T obj;
  public:
    Manipulator(T x) { obj = x; }
    void manipulate() { obj.f(); }
  };

  class HasF {
  public:
    void f() { cout << "HasF::f()" << endl; }
  }

  int main() {
    HasF hf;
    Manipulater<HasF> manipulator(hf);
    manipulator.manipulate();
  }
  ```
  ```c++
  /*输出：
  HasF::f()
  */
  ```
  - C++编译器会在你实例化模板的时候进行检査，这样在实例化Manipulator<HasF>时.编译器便会看到HasF中存在方法f()。如果情况并非如此，就会出现编译时错误，从而保证了类型的安全
  - 用C++编写这类代码很简单,因为在实例化模板的时候.模板代码知道其自身模板参数的类型

  ```java
  public class HasF {
    public void f() {
      System.out.println( "HasF. f()");
    }
  }

  //示例剩余的部分，则会无法编译
  class Manipulator<T> {
    private T obj;
    Manipulator(T x) ( obj = x; }
    // Error: cannot find symbol: method f():
    public void manipulate() { obj.f(); }
  }

  public class Manipulation {
    public static void main(String[] args) {
      HasF hf = new HasF();
      Manipulator<HasF> manipulator =
        new Manipulator<>(hf);
      manipulator.manipulate();
    }
  }
  ```
  - 由于类型擦除的缘故，Java编译器无法将“manipulate()必须调用obj上的f()”的这个要求，关联到“HasF中存在f()方法”的这个事实上
  - 要调用f(),我们就必须帮助泛型类，为它指定边界，来告诉编译器只接受符合该边界的类型

  ```java
  class Manipulator2<T extends HasF> {
    private T obj;
    Manipulator2(T x) { obj = x; )
    public void manipulate(){ obj. f (); }
  }
  ```
  - 边界＜T extends HasF＞声明了 T必须是HasF类型或者其子类。如果符合这个条件,就可以安全地调用obj上的F()方法

  我们说泛型类型参数会被擦除为其第一个边界(你稍后会看到，多重边界也是可以的)  
  可以观察到，泛型在Manipulator2.java中没有做出任何贡献

  只有在类型参数比具体类型（及其所有子类）更加“泛型（泛化）” 的时候。也就是说，在希望代码能够跨多个类型运行的时候一泛型才会有所帮助  

  如果某个类有一个返回T的方法，那么泛型就能起作用.因为泛型可以让该方法返回精确的类型  
  ```java
  class ReturnGenericType<T extends HasF> (
    private T obj;
    ReturnGenericType(T x) { obj = x; )
    public T get() { return obj; }
  }
  ```

## 迁移的兼容性
  它是在Java泛型实现中必要的一种折中，因为泛型并不是这门语言与生俱来的一部分。这种折中会给你带来痛苦，所以尽早习惯它，并理解它为什么存在吧  
  如果泛型在Java 1.0的时候就是这门语言的一部分了，这个特性就不会用类型擦除来实现，而会通过具体化（reification）来将类型参数保持为第一类实体.这样你就可以对类型参数执行基于类型的语言操作和反射操作了  
  在基于类型擦除的实现中.泛型类型被视同于第二类类型处理.无法在某些重要的上下文中使用  
  泛型类型只在静态类型检查时期存在，在这之后.程序中所有的泛型类型都会被擦除，并替换为它们的非泛型上界。举例来说，List＜T＞这样的类型注解会被擦除为List,而普通的类型变量则被擦除为Object,除非指定了边界  

  类型擦除的核心初衷是，希望让泛化的调用方程序可以依赖于非泛化的库正常使用，反之亦然。这通常称为迁移兼容性  
  因此Java泛型不仅必须支持向后兼容性（即保证已有的代码和类文件都依旧是合法的，并且能继续保持原有的含义），而且还必须支持迁移兼容性.这样库才能按它们自己的节奏变得通用,并且一旦某个库变得通用了，便不会对依赖它的代码和程序造成破坏  
  类型擦除是唯一可行的方案。通过允许非泛型的代码和泛型代码共存，类型擦除实现了向泛型的迁移  

  要实现迁移兼容性，所有的库和程序都必须在是否使用了泛型这件事上各自保持无关。所以它们不能去检测其他库是否使用了泛型  

  如果没有某种迁移的途径，那么所有已经存在了很久的库都有可能要和选择迁移到Java泛型上的开发者们说再见了。库可以说是一门编程语言最有影响力的组成部分，因此这种代价是不可接受的。类型擦除是否是最佳甚至唯一的迁移途径，只有时间能给我们答案了  

## 类型擦除存在的问题
  类型擦除使得现有的非泛型调用方代码可以在不用修改的情况下继续使用，直至调用方做好了用泛型来重写代码的准备。这个动机非常有意义，因为它不会突然间破坏掉所有已有代码  
  类型擦除的代价也很大。泛型代码无法用于需要显式引用运行时类型的操作，比如类型转换 instanceof操作，以及new表达式  
  因为关于参数的所有类型信息都丢失了，所以在编写泛型代码时，你必须时刻提醒自己，你只是看起来掌握了参数的类型信息而已  

  ```java
  class Foo<T> {
    T var;
  }
  Foo<Cat> f = new Foo<>();
  ```
  class Foo中的代码看起来应该知道它现在是在使用Cat类。而泛型语法也在强烈暗示,类中各处的类型T都已经被替换了.如同C++中一样。但是并非如此.在为该类编写代码时.你必须时刻提醒自己，“不.它仍然只是一个Object”。  

  ```java
  class GenericBase<T> {
    private T element;
    public void set(T arg) ( element = arg; }
    public T get() { return element; }
  }
  class Derived1<T> extends GenericBase<T> {}
  class Derived2 extends GenericBase {} //未产生警告

  // class Derived3 extends GenericBase<?> {}
  //奇怪的错误：
  //  unexpected type
  //  required: class or interface without bounds

  public class ErasureAndInheritance {
    @SuppressWarnings("unchecked")
    public static void main(String[] args) {
      Derived2 d2 = new Derived2();
      Object obj = d2.get();
      d2.set(obj);       //此处出现警告
    }
  }
  ```
  - Derived2 继承自 GenericBase,但并未包含泛型参数.而编译器并未给出警告：直到调用set() ,警告才出现
  - 从Derived3产生的警告可以推断出，编译器期望的是一个原始的基类

  如果你希望将类型参数当作比Object更强大的武器，就需要付出额外的精力来管理边界  

## 边界的行为
  类型擦除的存在，使我发现了泛型最容易令人困惑的方面————可以将无意义的事物表达出来  
  ```java
  public class ArrayMaker<T> {
    private Class<T> kind;
    public ArrayMaker(Class<T> kind) { this.kind = kind; }
    @SuppressWarnings("unchecked")
    T[] create(int size) {
      return (T[])Array.newInstance(kind, size);
    }
    public static void main(String[] args) {
      ArrayMaker<String> stringMaker =
        new ArrayMakero(String.class);
      String[] stringArray = stringMaker.create(9);
      System.out.printin(Arrays.toString(stringArray));
    }
  }
  ```
  ```java
  /*输出:
  [null, null, null, null, null, null, null, null, null]
  */
  ```
  尽管kind看起来是被存储为Class<T>，但是类型擦除意味着它实际上只是被存为一个不带参数的Class  
  因此，在你使用它的时候，如同创建数组一样，Array.newInstance()并不实际掌握kind含有的类型信息。它无法生成具体的结果，因此必须进行类型转换，这会产生令人不悦的警告  
  注意对Array.newInstance()的使用，这是在泛型中创建数组的推荐方式  

  ```java
  public class ListMaker<T> {
    List<T> create() { return new ArrayList<>(); }
    public static void main(String[] args) {
      ListMaker<String> stringMaker = new ListMaker<>();
      List<String> stringList = stringMaker.create();
    }
  }
  ```
  - 尽管我们知道(由于类型擦除)，在create()内部的new ArrayList<>()方法中，<T>被移除了————在运行时，类中并没有<T>
  - 将表达式修改为new ArrayList(),缉译器会产生警告

  ```java
  public class FilledList<T> extends ArrayList<T> {
    FilledList(Supplier<T> gen, int size) {
      Suppliers.fill(this, gen, size);
    }
    public FilledList(T t, int size) {
      for(int i = 0; i < size; i++)
      this.add(t);
    }
    public static void main(String[] args) {
      List<String> list = new FilledListo("Hello", 4);
      System.out.printin(list);
      //用Supplier实现的版本：
      List<Integer> ilist = new FilledListo(() -> 47, 4);
      System.out.println(ilist);
    }
  }
  ```
  ```java
  /*输出:
  [Hello, Hello, Hello, Hello] 
  [47, 47, 47, 47]
  */
  ```
  - 尽管在add()内部，编译器无法知道任何关于T的信息。但仍然可以在编译时确保向FilledList中放入的是类型T。因此.即使类型擦除移除了方法或类中的实际类型信息，编译器仍然能够确保类型使用方式的内部一致性

  由于类型擦除移除了方法体中的类型信息，运行时的关键便指向了边界————对象进入和离开某个方法的临界点。  
  编译器会在编译时在临界点执行类型检查，并插入类型转换的代码  
  ```java
  public class SimpleHolder {
    private Object obj;
    public void set(Object obj) { this.obj = obj; }
    public Object get() { return obj; )
    public static void main(String[] args) {
      SimpleHolder holder = new SimpleHolder();
      holder.set("Item");
      String s = (String)holder.get();
    }
  }
  ```
  - 而在调用get()时则会对类型转换进行检查

  ```java
  public class GenericHolder2<T> {
    private T obj;
    public void set(T obj) ( this.obj = obj; )
    public T get() { return obj; }
    public static void main(String[] args) {
      GenericHolder2<String> holder = 
        new GenericHolder2<>():
      holder.set("Item");
      String s = holder.get();
    }
  }
  ```
  - 看起来get()中不再需要进行类型转换了，但是我们仍然知道传给set()的值经过了编译期类型检查
  - set()中对传入类型的额外检查工作是编译器自动执行的。而对get()输出值的类型转换仍然存在，但并不比你自己来实现做得少

  泛型所有的行为都发生在边界。包括对传入值额外的编译时检查，和对输出值插入的类型转换；记住“边界是行为发生的地方”，这有助于减少对类型擦除产生的困惑  

# 对类型擦除的补偿
  由于类型擦除的缘故，我们失去了在泛型代码中执行某些操作的能力。任何需要在运行时知道确切类型的操作都无法运行  
  ```java
  public class Erased<T> {
    private final int SIZE = 100;
    public void f(Object arg) {
      // error: illegal generic type for instanceof
      if(arg instanceof T) {}

      // error: unexpected type
      T var = new T();

      // error: generic array creation
      T[] array = new T[SIZE];

      // warning: [unchecked] unchecked cast
      T[] array = (T[])new Object[SIZE];
    }
  }
  ```

  你可以偶尔在编程时绕过这些问题，但是有时你必须通过引入类型标签(type tag)来补偿类型擦除导致的损失  
  类型标签则可以提供动态的isInstance()能力：  
  ```java
  class Building {}
  class House extends Building {}

  public class ClassTypeCapture<T> {
    Class<T> kind;
    public ClassTypeCapture(Class<T> kind) {
      this.kind = kind;
    }
    public boolean f(Object arg) {
      return kind.isInstance(arg);
    }
    public static void main(String[] args) {
      ClassTypeCapture<Building> cttl =
        new ClassTypeCaptureo(Building.class);
      System.out.printin(cttl.f(new Building()))；
      System.out.printin(cttl.f(new House()));
      ClassTypeCapture<House> ctt2 =
        new ClassTypeCaptureo(House.class);
      System.out.println(ctt2.f(new Building()));
      System.out.println(ctt2.f(new House()));
    }
  }
  ```
  ```java
  /*输出：
  true
  true
  false
  true
  */
  ```
  编译器保证了类型标签能够和泛型参数匹配  

## 创建类型实例
  创建new T()是不会成功的，部分原因是类型擦除，另一部分原因是编译器无法验证T中是否存在无参构造器  
  传入一个工厂对象.并通过它来创建新实例, Class对象就是一个方便的工厂对象，因此如果你使用了类型标签.便可以通过newInstance()来创建该类型的新对象  
  ```java
  class ClassAsFactory<T> implements Supplier<T> {
    Class<T> kind;
    ClassAsFactory(Class<T> kind) {
      this.kind = kind;
    }
    @0verride public T get() {
      try {
        return kind.getConstructor().newInstance();
      } catch(Exception e) {
        throw new RuntimeException(e);
      }
    }
  }

  class Employee {
    public Employee() {}
    @Override public String toString() {
      return "Employee";
    }
  }
  public class InstantiateGenericType {
    public static void main(String[] args) {
      ClassAsFactory<Employee> fe =
        new ClassAsFactory<>(Employee.class);
      System.out.println(fe.get());
      ClassAsFactory<Integer> fi =
        new ClassAsFactoryo(Integer.class);
      try {
        System.out.printin(fi.get());
      } catch(Exception e) {
        System.out.printin(e.getMessage());
      }
    }
  }
  ```
  ```java
  /*输出:
  Employee
  java.lang.NoSuchMethodException:
  java.lang.Integer.<init>()
  */
  ```
  - 这样可以编译成功，但如果使用ClassAsFactory<Integer>则会失败，因为Integer中并没有无参构造器

  由于该错误并不是在编译期捕获的，因此这种方法遭到Java设计者们的反对。他们建议使用显式工厂（Supplier）,并对类型进行限制，使其仅能接收实现了该工厂的类。下面是创建工厂的两种不同方法:  
  ```java
  class IntegerFactory implements Supplier<Integer> {
    private int i = 0;
    @Override public Integer get() {
      return ++i；
    }
  }
  class Widget {
    private int id;
    widget(int n) ( id = n; }
    @Override public String toString() {
      return "Widget " + id;
    }
    public static
    class Factory implements Supplier<Widget> {
      private int i = 0;
      @Override
      public Widget get () { return new Widget(++i); }
    }
  }
  class Fudge {
    private static int count = 1;
    private int n = count++;
    @Override public String toString() {
      return "Fudge " + n;
    }
  }
  class Foo2<T> {
    private List<T> x = new ArrayList<>();
    Foo2(Supplier<T> factory) {
      Suppliers.fill(x, factory, 5);
    }
    @Override public String toString() {
      return x.toString();
    }
  }
  public class Factoryconstraint {
    public static void main(String[] args) {
      System.out.println(
        new Foo2<>(new IntegerFactory())):
      System.out.println (
        new Foo2<>(new Widget.Factory()));
      System.out.println(
        new Foo2<>(Fudge::new));
    }
  }
  ```
  ```java
  /*输出:
  [1, 2, 3, 4, 5]
  (Widget 1, Widget 2, Widget 3, Widget 4, Widget 5]
  [Fudge 1, Fudge 2, Fudge 3, Fudge 4, Fudge 5]
  */
  ```
  - 注意Fudge并不执行任何类似工厂的操作.但是传入Fudge::new仍然会产生工厂的行为，因为编译器将对函数方法::new的调用，转变成了对get()的调用

  另一种方式是使用设计模式：模板方法(Template Method)。在下面的示例中,create()就是那个模板方法，其在子类中被重写，用来生成该类型的对象  
  ```java
  abstract class GenericWithCreate<T> {
    final T element;
    GenericWithCreate() { element = create(); }
    abstract T create();
  }
  class X {}
  class XCreator extends GenericWithCreate<X> {
    @Override X create() { return new X(); }
    void f() {
      System.out.println(
        element.getClass().getSimpleName());
    }
  }
  public class CreatorGeneric {
    public static void main(String[] args) {
      XCreator xc = new XCreator();
      xc.f();
    }
  }
  ```
  ```java
  /*输出：
  x
  */
  ```

## 泛型数组
  你是无法创建泛型数组的。通用的解决办法是不管在何处,你都用AnayList来创建泛型数组：  
  ```java
  public class ListOfGenerics<T> {
    private List<T> array = new ArrayList<>();
    public void add(T item) { array.add(item); }
    public T get(int index) { return array.get(index); }
  }
  ```

  有时你仍然需要创建泛型类型的数组.你可以定义一个泛型引用，指向一个数组  
  ```java
  class Generic<T> {}

  public class ArrayOfGenericReference {
    static Generic<Integer>[] gia;
  }
  ```
  编译器接受了这种方式，没有产生警告。但是你你永远无法创建该确切类型（包括类型参数）的数组，因此这有点让人疑惑  

  所有的数组不论持有的是什么类型.都有着相同的结构（包括每个数组的大小和布局），因此你似乎可以创建一个Object数组.并将其转换
为目标数组类型 这确实可以通过编译.但会在运行时抛出ClassCastException异常：  
  ```java
  public class ArrayOfGeneric {
    static final int SIZE = 100;
    static Generic<Integer>[] gia;
    @SuppressWarnings("unchecked")
    public static void main(String[] args) {
      try {
        gia = (Generic<Integer>[])new Object(SIZE];
      } catch(ClassCastException e) {
        System.out .println(e.getMessage());
      }
      //运行时的类型是原始类型(已被擦除)：
      gia = (Generic<Integer>[] )new Generic[SIZE];
      System.out.println(gia.getClass().getSimpleName());
      gia[0] = new Generic<>();
      // gia[1] = new Object(); //编译时错误
      //在编译时发现类型不匹配：
      // gia[2] = new Generic<Double>();
    }
  }
  ```
  ```java
  /*揄出:
  [Ljava.lang.Object; cannot be cast to [LGeneric;
  Generic[]
  */
  ```
  - gia被转型为Generic<Integer>[],该信息也只会存在于编译时。在运行时，它仍然还是Object数组，而这会导致问题
  - 唯一可以成功创建泛型类型数组的方法就是创建一个类型为被擦除类型的新数组，然后再对其进行类型转换

  ```java
  public class GenericArray<T> {
    private T[] array;
    @SuppressWarnings("unchecked")
    public GenericArray(int sz) {
      array = (T[])new Object[sz];
    }
    public void put(int index, T item) {
      array[index] = item；
    }
    public T get(int index) { return array[index]; }
    //暴露了潜在表现形式的方法：
    public T[] rep() { return array; }
    public static void main(String[] args) {
      GenericArray<Integer> gai = new GenericArray<>(10);
      try {
          Integer[] ia = gai.rep():
      } catch(ClassCastException e) {
        System.out.println(e.getMessage())；
      }
      //这没问题：
      Object[] oa = gai.rep();
    }
  }
  ```
  ```java
  /*输出：
  [Ljava.lang.Object; cannot be cast to
  [Ljava.lang.Integer;
  */
  ```
  - rep()并试图将结果作为Integer[]的引用来获取，便会抛出ClassCastException异常，这仍然是因为运行时类型实际是Object[]

  数组的运行时类型只能是Object[]如果我们立刻将其转型为T[],那么在编译时，数组的实际类型便会丢失，编译器就可能会错过对某些潜在错误的检查。因此，更好的办法是在集合内使用Object[],并在使用某个数组元素的时候増加转型为T的操作  
  ```java
  public class GenericArray2<T> {
    private Object[] array;
    public GenericArray2(int sz) {
      array = new Object[sz];
    }
    public void put(int index, T item) {
      array[index] = item;
    }
    @SuppressWarnings("unchecked")
    public T get(int index) { return (T)array[index]; }
    @SuppressWarnings ("unchecked")
    public T[] rep() {
      return (T[])array;             //未检查的类型转换
    }
    public static void main(String[] args) {
      GenericArray2<Integer> gai =
        new GenericArray2<>(10);
      for(int i = 0; i < 10; i ++)
        gai.put(i, i);
      for(int i = 0; i < 10; i ++)
        System.out.print(gai.get(i) + "  ");
      System.out.println();
      try {
        Integer[] ia = gai.rep();
      } catch(Exception e) {
        System.out.println(e);
      }
    }
  }
  ```
  ```java
  /*输出：
  0  1  2  3  4  5  6  7  8  9
  java.lang.ClassCastException: [Ljava.lang.Object;
  cannot be cast to [Ljava.lang.Integer;
  */
  ```
  - 在调用get()方法时，该方法会将对象转型为T,这实际上是正确的类型，因此是安全的
  - 不过如果调用rep(),该方法会再次试图将Object[]转型为T[],这仍然是错误的.并且会产生编译时警告和运行时异常
  - 因此,没有任何办法可以推翻底层的数组类型，该类型只能是Object[]。在内部将array当作Object[]而不是T[]来进行处理.这样做的好处是，可以减少由于你忘记了数组的运行时类型，而意外产生bug的可能性

  对于新代码，应该传入一个类型标记。这种情况下的GenericArray看起来是这样的：  
  ```
  public class GenericArrayWithTypeToken<T> {
    private T[] array;
    @SuppressWarnings("unchecked")
    public
    GenericArrayWithTypeToken(Class<T> type, int sz) {
      array = (T[])Array.newInstance(type, sz);
    }
    public void put(int index, T item) {
      array[index] = item;
    }
    public T get(int index) { return array[index]; }
    //暴露潜在的表达方式：
    public T[] rep() { return array; }
    public static void main(String[] args) {
      GenericArrayWithTypeToken<Integer> gai =
        new GenericArrayWithTypeToken<>(
          Integer.class, 10);
      //现在可以正常运行了：
      Integer[] ia = gai.rep();
    }
  }
  ```
  - 这里将类型标记Class<T>传入了构造器，以用于擦除后的类型恢复，这样就能够创建实际所需类型的数组了
  - 数组的运行时类型是精确的T[]类型

  Neal Gafter（ Java 5的主要开发人员之一）在他的博客中指出过，他无法在不破坏已有接口的情况下解决某些Java库代码的问题。  
  所以即使Java库的源代码中出现了某些便用做法，这也不一定是正确的做法。你在阅读库代码的时候，不能把这些当成可以在自己的代码中遵循的范例  

# 边界
  边界让你在使用泛型的时候，可以在参数类型上增加限制  
  虽然这可以强制执行应用泛型的类型规则，但更重要的潜在效果是，你可以调用边界类型上的方法了  

  由于类型擦除移除了类型信息，对于无边界的泛型参数，你仅能调用Object中可用的方法  
  不过如果能够将参数类型限制在某个类型子集中，你就可以调用该子集上可用的方法了  
  为了应用这种限制,Java泛型复用了 extends关键字  

  相较于extends关键字的常规用法，它在泛型边界上下文中代表着完全不同的意义,理解这一点非常重要：  
  ```java
  interface HasColor { java.awt.Color getColor(); }

  class WithColor<T extends HasColor> {
    T item;
    WithColor(T item) { this.item = item; }
    T getltem() { return item; )
    //可以调用边界中的方法：
    java.awt.Color color() { return item.getColor(); }
  }

  class Coord { public int x, y, z; }

  //这样会失败：类(Coord)必須在最前面，然后才是接口(HasColor):
  // class WithColorCoord<T extends HasColor & Coord> {

  //多重边界：
  class WithColorCoord<T extends Coord & HasColor> {
    T item;
    WithColorCoord(T item) { this.item = item; }
    T getItem() { return item; }
    java.awt.Color color() { return item.getColor(); }
    int getX() { return item.x; }
    int getY() { return item.y; }
    int getZ() { return item.z; }
  }

  interface Weight { int weight(); }

  //和使用继承一样，只能继承一个具体，而可以实现多个接口
  class Solid<T extends Coord & HasColor & Weight> {
    T item;
    Solid(T item) { this.item = item; }
    T getItem() { return item; }
    java.awt.Color color() ( return item.getColor(); }
    int getX() { return item.x; }
    int getY() { return item.y; )
    int getZ() { return item.z; )
    int weight() { return item.weight(); }
  }

  class Bounded
  extends Coord implements HasColor, Weight {
    @Override
    public java.awt.Color getColor() { return null; }
    @Override public int weight() { return 0; }
  }

  public class BasicBounds {
    public static void main(String(] args) {
      Solid<Bounded> solid =
        new Solid<>(new Bounded()):
      solid.color();
      solid.getY();
      solid.weight();
    }
  }
  ```

  ```java
  //你可以这样做：
  List<? extends SuperHearing> audioPeople;
  //但不能这样做：
  // List<? extends SuperHearing & SuperSmell> dogPs;
  ```
  这里出现了通配符，只限于使用单边界  

# 通配符
  ```java
  class Fruit {}
  class Apple extends Fruit {}
  class Jonathan extends Apple {}
  class Orange extends Fruit {}

  public class CovariantArrays {
    public static void main(String[] args) {
      Fruit[] fruit = new Apple[10]:
      fruit[0] = new Apple(); // OK
      fruit[1] = new Jonathan(); // OK
      //运行时类型是Apple[],而不是 Fruit[]或Orange[]:
      try {
        //编译器允许添加Fruit：
        fruit[0] = new Fruit();            // 会导致 ArrayStoreException 异常
      } catch(Exception e) { System.out.println(e); }
      try { 
        //编译器允许添加Oranges:
        fruit[0] = new Orange();           // 会导致 ArrayStoreException 异常
      } catch(Exception e) { System.out.println(e); }
    }
  }
  ```
  ```java
  /*输出:
  java.lang.ArrayStoreException: Fruit
  java.lang.ArrayStoreException: Orange
  */
  ```
  - main()方法的第一行创建了一个Apple数组，并将其赋值给一个指向Fruit数组的引用
  - 实际的数组类型是Apple[],可以将Apple或Apple的子类放入该数组，这实际上在编译时和运行时都是没问题的
  - 将Fruit对象，或任何Fruit派生出来的对象，例如Orange （橙子），放入该数组: 在编译时，这是允许的。但是运行时的数组机制知道自己是在处理Apple[],并会在向该数组中放入异构类型时抛出异常
  - 数组对象可以维持它们包含的对象的类型规则。这就好像是数组能够意识到它们持有的是什么，所以在编译时检查和运行时检查之间，你无法对数组进行滥用

  ```java
  public class NonCovariantGenerics {
    // Compile Error: incompatible types:
    List<Fruit> flist = new ArrayList<Apple>();
  }
  ```
  - 泛型并不是只和集合有关。这里真正表达的是，“你无法将包含Apple的泛型赋值给包含Fruit的泛型”

  问题的本质在于，我们讨论的是集合自身的类型，而不是它所持有的元素类型。  
  和数组不同，泛型并没有内建的协变性。  
  数组是完全在语言内部定义的.因此可以同时拥有编译时和运行时的内建检查。  
  对于泛型，编译器和运行时系统无法得知应该怎样处理你的类型,以及该制定怎样的规则  

  ```java
  public class GenericsAndCovariance {
    public static void main(String[] args) {
      //通配符提供了协变性的能力：
      List<? extends Fruit> flist = new ArrayList<>();
      // Compile Error: can't add any type of object:
      // flist.add(new Apple());
      // flist.add(new Fruit());
      // flist.add(new Object());
      flist.add(null); //合法，但没什么意义
      //我们知道至少能返回Fruit：
      Fruit f = flist.get(0);
    }
  }
  ```
  - flist的类型现在变成了 List<? extends Fruit>, 但是这并不意味着List真的会持有任何Fruit类型
  - 通配符引用指向了某个确定的类型，因此真正的意义是“某种flist引用未指定的具体类型”
  - 因此被赋值的List必须持有某种具体的类型，例如Fruit或Apple
  - 但是为了向上转型为flist,该类型是什么并没有人关心

  你不知道List持有的是什么类型，你又如何能安全地向其中添加对象呢？  
  你不能像CovariantArrays的的“向上转型”数组这样做，除非编译器能阻止类型不匹配的操作发生，而不是等到运行时系统（再来阻止）  

  一旦你进行了这种“向上转型”，便失去了向其中传入任何对象的能力，即使是传入Object也是如此  

## 编译器有多聪明？
  ```java
  public class Compilerintelligence {
    public static void main(String[] args) {
      List<? extends Fruit> flist =
        Arrays.asList(new Apple());
      Apple a = (Apple)flist.get(0);            // 未产生警告
      flist.contains (new Apple());             // 会数是 Object
      flist.indexOf(new Apple());               // 参数是 Object
    }
  }
  ```
  - 在你声明了ArrayList<? extends Fruit>后,add()的参数便成了 ? extends Fruit
  - 编译器无法知道该处要求的是哪种具体的Fruit子类型.因此便不会接受任何Fruit的类型
  - 如果参数列表中带有通配符,编译器会直接拒绝调用方法(如add())
  - 对于contains()和indexOf()来说，参数类型是Object类型，因此并不包含通配符,编译器会允许该调用

  ```java
  public class Holder<T> {
    private T value;
    public Holder() {}
    public Holder(T vat) { value = val; }
    public void set(T val) ( value = vat; )
    public T get() ( return value; }
    @Override public boolean equals (Object o) {
      return o instanceof Holder &&
        Objects.equals(value, ((Holder)o).value);
    }
    @Override public int hashCode() {
      return Objects.hashCode(value);
    }
    public static void main(String[] args) {
      Holder<Apple> apple = new Holdero(new Apple());
      Apple d = apple.get();
      apple.set(d);
      // Holder<Fruit> Fruit = apple;               // 无法向上转型
      Holder<? extends Fruit> fruit = apple;        // OK
      Fruit p = fruit.get();
      d = (Apple)fruit.get();                       // 返回Object
      try {
        Orange c = (Orange)fruit.get();             // 无警报
      } catch(Exception e) { System.out.println(e); )
        // fruit.set (new Apple());                 // 无法调用 set()
        // fruit.set (new Fruit());                 // 无法消用 set()
        System.out.println(fruit.equals(d));        //OK
    }
  }
  ```
  ```java
  /*输出：
  java.lang.ClassCastException: Apple cannot be cast to
  Orange
  false
  */
  ```
  - 如果创建了Holder<Apple>,就无法将其向上转型为Holder<Fiuit>,但是可以向上转型为Holder<? extends Fruit>
  - 向上转型为Holder<? extends Fruit>后，如果调用get(),则只能返回Fruit
  - 如果你知道此处是什么类型，便可以转型为某个具体的Fruit类型，并旦不会产生相关的警告，但这有抛出ClassCastException的风险
  - Apple或Fruit都无法用于set()方法,因为set()方法的参数同样是 ? Extends Fruit,这意味着它可以是任意类型，而编译器无法为“任意类型”验证安全性
  - equals()方法没有问题，因为它接收Object作为参数，而不是T。因此编译器只会关心传入和返回的对象类型
  - Java 7引入了 java.util.Objects,其目的之一就是为了更容易地创建equals()和hashCode()方法

## 逆变性
  

  







