普通的类和方法一般需要依赖具体的类型：要么是基本类型，要么是类类型。如果要编写跨类型的代码.这种硬性的机制就会带来过多的限制  

多态是面向对象的一种泛化手段：你可以这么实现：编写一个方法，并以某个基类为参数，然后在使用该方法的时候就可以传入该基类的任何子类了————包括尚未创建的类  

单一继承层次结构的限制太多，因为你必须从该层継承来生成符合方法参数要求的对象。如果将方法的参数从类改成接口，就能解除该限制，从而可以泛化到支持该接口的任何实现类  

有时甚至接口也会太过严格。接口仍然要求你的代码依赖于该特定接口。如果可以让代码只需依赖于“某种不具体指定的类型”，而不是某个特定的接口或类，那么你就可以编写出更为通用的代码  

这便是泛型（Java 5最重大的变化之一）的概念。  
泛型可以生成参数化类型.这样你就可以创建适用于多种类型的组件（主要用于集合）   
术语“泛型”的意思是“适用或者可兼容大批的类”  

参数化类型机制：使用别人的泛型类型通常会比较容易，但是创建自己的泛型类型时则容易发生很多意外  

# 和C++的对比
  接下来要进行Java泛型和C++泛型之间的比较，主要基于两个原因：  
  - 第一个原因是，对C++模板（泛型的主要灵感以及基本语法的来源）某些方面的理解有助于掌握（泛型）概念的基础，以及非常重要的一点————理解Java泛型的限制和这些限制存在的原因。终极目标是使你通过对各种边界情况的清晰理解,成为更强大的程序员。而淸楚哪些事情不能做，能让你更好地利用那些你所能做的事情（部分原因是可以让你无须浪费时间走死胡同了）。
  - 第二个原因是，Java社区对C++模板的理解存在重大分歧，而这种分歧会逬一步加深你对泛型（所要实现的）目标的疑惑

# 简单泛型
  泛型最重要的初衷之一，是用于创建集合类。  
  集合是一种可以用来持有其他类型对象的对象.数组也有同样的作用，不过集合往往比简单的数组更灵活，而且具有不同的特性  
  实际上所有的程序都需要你在使用一组对象的时候拥有持有这些对象的能力，因此集合是复用性最高的库之一  

  ```java
  public class ObjectHolder {
    private Object a;
    public ObjectHolder(Object a) { this.a = a;}
    public void set(Object a) ( this.a = a; )
    public Object get() ( return a; )
    public static void main(String[] args) {
      ObjectHolder h2 =
        new ObjectHolder(new Automobile() )；
      Automobile a = (Automobile)h2.get();
      h2.set("Not an Automobile");
      String s = (String)h2.get();
      h2.set(1);               // 自动装箱为 Integer
      Integer x = (Integer)h2.get();
    }
  }
  ```
  - 这样ObjectHolder就可以持有任何东西了————在本例中，ObjectHolder持有了3个不同类型的对象

  在个别情况下，你会想要能持有多个不同类型对象的集合，但是大多数时候，你只会将一种类型的对象保存到某个特定的集合对象  
  泛型的主要目的之一是指定集合能持有的对象类型，并且通过编译器来强制执行该规范  

  因此相较于Object,我们更倾向于指定一个类型占位符，并在晩些时候再决定（具体的类型）  
  要实现这个目的，你需要在类名后的尖括号内放置一个类型参数，然后在使用该类的时候再将其替换为实际的类型  
  ```java
  public class GenericHolder<T> {
    private T a;
    public GenericHolder() {}
    public void set(T a) { this.a = a;}
    public T get() { return a; }
    public static void main(String[] args) {
      GenericHolder<Automobile> h3 =
        new GenericHolder<Automobile>();
      h3.set(new Automobile());       // 类型已检查
      Automobile a = h3.get();        //不需要转型
      //- h3.set("Not an Automobile"); // Error
      //- h3.set(1); // Error
    }
  }
  ```

  Java泛型的核心理念：只需告诉泛型所需的类型，剩下的全部细节就可以都交给它了  
  
  你会注意到h3的定义相当冗长旦多余。在等号的左侧，你声明了GenericHolderAutomobile>，然后在等号的右侧再次声明了同样的东西  
  在Java 5问世的时候，这种啰唆的方式总被解释为“必须这么做”,但是到了Java 7.设计者们修正了该问题题(而删繁就简随之便被吹嘘为优秀的特性)：  
  ```java
  public class Diamond<T> {
    public static void main(String[] args) {
      GenericHolder<Automobile> h3 = 
        new GenericHolder<>();
    }
  }
  ```
  - h3定义的右侧现在使用了 “钻石”语法，而不用再将左边的类型信息复制一遍

## 元组库
  你常常会通过一次方法调用返回多个对象。  
  由于return语句只能返回一个对象，因此解决的办法是创建一个可持有多个对象的对象，然后返回该对象  

  这个概念被称为元组(tuple),它将一组对象一起包装进了一个对象：该对象的接收方可以读取其中的元素，但不能往里放入新元素————这个概念也称为数据传输对象(Data Transfer Object)或者信使(Messenger)  

  元组一般无长度限制.其中的每个对象都可以是不同的类型；不过我们会指定每个元素的类型，并旦保证接收方读取元素值时得到的是正确的类型。对于多种不同长度的问题，我们通过创建多个不同的元组来解决。  
  ```java
  public class Tuple2<A, B> {
    public final A a1;
    public final B a2;
    public Tuple2(A a, B b) { a1 = a; a2 = b; }
    public String rep() { return a1 + ", " + a2; }
    @Override public String toString() {
      return " (" + rep() + ")";
    }
  }
  ```
  - 构造器会获取要保存的对象。元组则隐式地按顺序存放各个元素
  - a1和a2不是private的，调用方仍然可以读取这两个对象，并对它们进行任何操作，但是它们无法将a1和a2赋值给任何其他东西
  - 因此final声明的方式可以为你提供与private相等的安全性，但形式更简洁紧凑

  如要使用元组，你就需要为函数定义长度合适的元组来作为返回值.然后创建该元组并返回：  
  ```java
  public class TupleTest {
    static Tuple2<String, Integer> f() {
      //自动装箱将int转换为Integer：
      return new Tuple2<>("hi", 47);
    }
    static Tuple3<Amphibian, String, Integer> g() {
      return new Tuple3<>(new Amphibian(), "hi", 47);
    }
    static
    Tuple4<Vehicle, Amphibian, String, Integer> h() {
      return
        new Tuple4()(
          new Vehicle(), new Amphibian(), "hi", 47);
    }
    static
    Tuple5<Vehicle, Amphibian, String, Integer, Double> k() {
      return new
        Tuple5<>(
          new Vehicle(), new Amphibian(), "hi", 47, 11.1);
    }
    public static void main(String[] args) {
      Tuple2<String, Integer> ttsi = f();
      System.out.println(ttsi);
      // ttsi.al = "there"; // Compile error: final
      System.out.println(g());
      System.out.println(h());
      System.out.println(k());
    }
  }
  ```
  ```java
  /*输出:
  (hi, 47)
  (Amphibian@lc7c054, hi, 47)
  (Vehicle@14991ad, Amphibian@d93b30, hi, 47)
  (Vehicle@al4482, Amphibian(ai40el9d, hi, 47, 11.1)
  */
  ```
  
  有了泛型，只需编写该表达式，就可以很轻松地创建任何元组来返回任意一组类型  

## 栈类
  ```java
  public class LinkedStack<T> {
    private static class Node<U> {
      U item;
      Node<U> next;
      Node() { item = null; next = null; }
      Node(U item, Node<U> next) {
        this.item = item;
        this.next = next;
      }
      boolean end() {
        return item == null && next == null;
      }
    }
    private Node<T> top = new Node<>(); // 末端哨兵(end sentinel)
    public void push(T item) {
      top = new Node<>(item, top);
    }
    public T pop() {
      T result = top.item;
      if(!top.end())
        top = top.next;
      return result;
    }
    public static void main(String[] args) {
      LinkedStack<String> lss = new LinkedStack<>();
      for(String s : "Phasers on stun!".split(" "))
        lss.push(s);
      String s;
      while((s = lss.pop()) != null)
        System.out.println(s);
    }
  }
  ```
  ```java
  /*输出：
  stun！
  on
  Phasers
  */
  ```
  - 内部类Node同样也是泛型,并且有着自己的类型参数
  - 以上示例利用了末端哨兵(end sentinel)来检查栈何时为空

## RandomList
  ```java
  public class RandomList<T> extends ArrayList<T> {
    private Random rand = new Random(47);
    public T select() {
      return get(rand.nextInt(size()));
    }
    public static void main(String[] args) {
      RandomList<String> rs = new RandomList<>();
      Arrays.stream(
        ("The quick brown fox jumped over " +
        "the lazy brown dog").split(" "))
        .forEach(rs::add);
      IntStream.range(0, 11).forEach(i ->
        System.out.print(rs.select() + " "));
    }
  }
  ```
  ```java
  /*输出：
  brown over fox quick quick dog brown The brown lazy brown
  */
  ```
  - 由于RandomList (随机列表)继承自ArrayList,因此它拥有ArrayList中的全部内建行为

# 泛型接口
  泛型同样可用于接口  
  生成器(generator)是一种用于创建对象的类。生成器实际上是工厂方法(Factory Method )设计模式的一种特殊形式，只是在向生成器
请求创建新对象时，无须向其传入任何参数，而通常在使用工厂方法时都会向其中传入参数  
  java.util.function库将生成器定义为Supplier,其中的生成方法则称为get()。get()的返回类型被参数化为T  
  ```java
  public class CoffeeSupplier
  implements Supplier<Coffee>, Iterable<Coffee> {
    private Class<?>[] types = { Latte.class, Mocha.class,
      Cappuccino.class, Americano.class, Breve.class, };
    private static Random rand = new Random(47);
    public CoffeeSupplier() {}
    //迭代：
    private int size = 0;
    public CoffeeSupplier(int sz) { size = sz; }
    @Override public Coffee get() {
      try {
        return (Coffee)
          types [rand.nextInt(types.length)]
          .getConstructor().newInstance();
      //报告运行时程序错误：
        } catch(InstantiationException |
                NoSuchMethodException |
                InvocationTargetException |
                IllegalAccessException e) {
        throw new RuntimeException(e);
      }
    }
    class CoffeeIterator implements Iterator<Coffee> {
      int count = size;
      @Override
      public boolean hasNext() { return count > 0; }
      @Override public Coffee next() {
        count--;
        return CoffeeSupplier.this.get();
      }
      @Override
      public void removed {         // 未实现
        throw new UnsupportedOperationException();
      }
    }
    @Override public Iterator<Coffee> iterator() {
      return new CoffeeIterator();
    }
    public static void main(String[] args) {
      Stream.generate(new CoffeeSupplier())
        .limit(5)
        .forEach(System.out::println);
      for(Coffee c : new CoffeeSupplier(5))
          System.out.println(c);
    }
  }
  ```
  ```
  /*给出：
  Americano 0
  Latte 1
  Americano 2
  Mocha 3
  Mocha 4
  Breve 5
  Americano 6
  Latte 7
  Cappuccino 8
  Cappuccino 9
  */
  ```
  - 参数化的Supplier接口会确保get()方法返回的是参数类型
  - CoffeeSupplier同样实现了Iterable接口，因此它可以在for-in语句中使用
  - 不过它必须知道何时该停止，而这是由第二个构造器指定的

  ```java
  public class Fibonacci implements Supplier<Integer> {
    private int count = 0;
    @Override
    public Integer get() { return fib(count++); }
    private int fib(int n) {
      if(n < 2) return 1;
      return fib(n-2) + fib(n-l);
    }
    public static void main(String[] args) {
      Stream.generate(new Fibonacci())
      .limit(18)
      .map(n -> n + " ")
      .forEach(System.out::print);
    }
  }
  ```
  ```java
  /*输出:
  1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584
  */
  ```
  
  虽然我们在该类的内外部使用的都是int,但是类型参数是Integer这引出了Java泛型的限制之一：无法将基本类型作为类型参数  
  Java 5的自动装箱和自动拆箱机制实现了从基本类型到包装类型的双向转换  

# 泛型方法
  还可以对类内部的方法进行参数化。类自身可以是泛型的,也可以不是————这和是否存在参数化的方法无关  
  准则：“尽量”使用泛型方法。相比于泛型化整个类，泛型化单个方法通常来说会更淸晰  

  要定义一个泛型方法，需要将泛型参数列表放在返回类型声明之前：  
  ```java
  public class GenericMethods {
    public <T> void f(T x) {
      System.out.printin(x.getClass().getName());
    )
    public static void main(String[] args) {
      GenericMethods gm = new GenericMethods();
      gm.f("");
      gm.f(1);
      gm.f(1.0);
      gm.f(1.0F);
      gm.f('c');
      gm.f(gm);
    }
  }
  ```
  ```java
  /*输出：
  java.lang.String
  java.lang.Integer
  java.lang.Double
  java.lang.Float
  java.lang.Character
  GenericMethods
  */
  ```
  - 使用泛型类时，在实例化类的时候必须指定类型参数
  - 使用泛型方法的时候，通常不需要指定参数类型，因为编译器会为你检测出来————类型参数推断(type argument inference)
  - 在用基本类型调用f()方法时，自动装箱机制便会生效，将基本类型自动包装为相应的对象

## 可变参数和泛型方法
  泛型方法和可变参数列表可以和平共处:  
  ```java
  public class GenericVarargs {
    @SafeVarargs
    public static <T> List<T> makeList(T... args) {
      List<T> result = new ArrayList<>();
      for(T item : args)
        result.add(item);
      return result;
    }
    public static void main(String[] args) {
      List<String> ls = makeList("A");
      System.out.println(ls);
      ls = makeList("A", "B", "C");
      System.out.println(ls);
      ls = makeList(
        "ABCDEFFHIJKLMNOPQRSTUVWXYZ".split(""));
      System.out.println(ls);
    }
  }
  ```
  ```java
  /*输出:
  [A]
  [A, B, C]
  [A, B, C, D, E, F, F, H, I, J, K, L, M, N, 0, P, Q, R,
  S, T, U, V, W, X, Y, Z]
  */
  ```
  - 这里的makeList()方法实现了和标准库中的java.util.Arrays.asList()方法一样的功能
  - @SafeVarargs注解表示我们承诺不会对变量参数列表做任何修改

## 通用 Supplier
  以下示例中的类可以为任何具有无参构造器的类生成一个Supplier  
  ```java
  public class BasicSupplier<T> implements Supplier<T> {
    private Class<T> type;
    public BasicSupplier(Class<T> type) {
      this.type = type;
    }
    @Override public T get() {
      try {
        //假定类型是public的英:
        return type.getConstructor().newlnstance();
      } catch(InstantiationException |
              NoSuchMethodException |
              InvocationTargetException |
              IllegalAccessException e) {
        throw new RuntimeException(e);
      }
    }
    //基于类型标记生成默认的Supplier：
    public static <T> Supplier<T> create(Class<T> type) {
      return new BasicSupplier<>(type);
    }
  }
  ```
  该类提供了为符合以下条件的类生成对象的基本实现:  
  1. 该类是public的
  2. 该类具有无参构造器

  泛型的static的create()方法提供了更为方便的语法 BasicSupplier.create(MyType.class),  
  而不是麻烦的 new BasicSupplier<MyType>(MyType.class)  

  泛型方法减少了生成Supplier对象所必需的代码编写量。 这里的`Class<T> type`强制要求传入Class对象  

## 简化元组的使用
  ```java
  public class Tuple {
    public static <A, B> Tuple2<A, B> tuple(A a, B b) {
      return new Tuple2<>(a, b);
    }
    public static <A, B, C> Tuple3<A, B, C>
    tuple(A a, B b, C c) {
      return new Tuple3<>(a, b, c);
    }
    public static <A, B, C, D> Tuple4<A, B, C, D>
    tuple(A a, B b, C c, D d) {
      return new Tuple4<>(a, b, c, d);
    }
    public static <A, B, C, D, E>
    Tuple5<A, B, C, D, E> tuple(A a, B b, C c, D d, E e) {
      return new Tuple5<>(a, b, c, d, e);
    }
  }

  public class TupleTest2 {
    static Tuple2<String, Integer> f() {
      return tuple("hi", 47);
    }
    static Tuple2 f2() { return tuple("hi", 47); }
    static Tuple3<Amphibian, String, Integer> g() {
      return tuple(new Amphibian(), "hi", 47);
    }
    static
    Tuple4<Vehicle, Amphibian, String, Integer> h() {
      return tuple(
        new Vehicle(), new Amphibian(), "hi", 47);
    }
    static
    Tuple5<Vehicle, Amphibian,
        String, Integer, Double> k() {
      return tuple(new Vehicle(), new Amphibian()，
        "hi", 47, 11.1);
    }
    public static void main(String[] args) {
      Tuple2<String, Integer> ttsi = f();
      System.out.println(ttsi);
      System.out.println(f2());
      System.out.println(g());
      System.out.println(h());
      System.out.println(k());
    }
  }
  ```
  ```java
  /*输出:
  (hi, 47)
  (hi, 47)
  (Amphibian@a298b7, hi, 47)
  (Vehicle@16d3586, Amphibian@154617c, hi, 47)
  (Vehicle@17327b6, Amphibian@14ae5a5, hi, 47, 11.1)
  */
  ```
  - f()方法返回了参数化的Tuple2对象，而f2()则返回了未参数化的Tuple2对象
  - 由于返回值并未以参数化的方式使用，因此编译器并未对f2()方法产生警告。某种意义上，它被“向上转型”成了未参数化的Tuple2。不过，如果你试图获取f2()的结果并放入参数化的Tuple2,编译器便会产生警告

## Set实用工具
  ```java
  public class Sets {
    public static <T> Set<T> union(Set<T> a, Set<T> b) {
      Set<T> result = new HashSet<>(a);
      result.addAll(b);
      return result;
    }
    public static <T>
    Set<T> intersection(Set<T> a, Set<T> b) {
      Set<T> result = new HashSet<>(a);
      result.retainAll(b);
      return result;
    }
    //从超集中减去子集：
    public static <T> Set<T>
    difference(Set<T> superset, Set<T> subset) {
      Set<T> result = new HashSet<>(superset);
      result.removeAll(subset);
      return result;
    }
    //反过来——所有不在交集中的元素：
    public static
    <T> Set<T> complement (Set<T> a, Set<T> b) {
      return difference(union(a, b), intersection(a, b));
    }
  }
  ```
  - 前三个方法将第一个参数的引用复制到了一个新的HashSet对象中，从而复制了该参数，这样作为参数的Set就不会被直接修改了  

  可以通过EnumSet轻松地根据枚举生成Set。静态方法EnumSet.range()指定了选取范围的头尾边界元素，用于创建结果Set。
  ```java
  Set<Watercolors> set2 =
    EnumSet.range(CERULEAN_BLUE_HUE, BURNT_UMBER);
  ```

  用Sets.difference()演示了 java.util中的各Collection和Map类之间的区别：  
  ```java
  public class CollectionMethodDifferences {
    static Set<String> methodSet(Class<?> type) {
      return Arrays.stream( type.getMethods())
        .map(Method::getName)
        .collect(Collectors.toCollection(TreeSet::new));
    }
    static void interfaces(Class<?> type) {
      System.out.print("Interfaces in " +
        type.getSimpleName() + ":");
      System.out.println(
        Arrays.stream(type.getInterfaces())
          .map(Class::getSimpleName)
          .collect(Collectors.toList()));
    }
    static Set<String> object = methodSet(Object.class);
    static { object.add("clone"); }
    static void
    difference(Class<?> superset, Class<?> subset) {
      System.out.print(superset.getSimpleName() +
        "extends " + subset.getSimpleName() +
        "，adds: ");
      Set<String> comp = Sets.difference(
        methodSet(superset), methodSet(subset));
      comp.removeAll(object);       // 忽略 Object 类的方法
      System.out.println(comp);
      interfaces(superset);
    }
    public static void main(String[] args) {
      System.out.println("Collection: " +
        methodSet(Collection.class));
      interfaces(Collection.class);
      difference(Set.class, Collection.class);
      difference(HashSet.class, Set.class);
      difference(LinkedHashSet.class, HashSet.class);
      difference(TreeSet.class, Set.class);
      difference (List.class, Collection.class);
      difference(ArrayList.class, List.class);
      difference(LinkedList.class, List.class);
      difference(Queue.class, Collection.class);
      difference(PriorityQueue.class, Queue.class);
      System.out.println("Map: " + methodSet(Map.class));
      difference(HashMap.class, Map.class);
      difference(LinkedHashMap.class, HashMap.class);
      difference(SortedMap.class, Map.class);
      difference(TreeMap.class, Map.class);
    }
  }
  ```
  ```java
  /*输出：
  Collection: [add, addAll, clear, contains, containsAll,
  equals, forEach, hashCode, isEmpty, iterator,
  parallelstream, remove, removeAll, removelf, retainAll,
  size, spliterator, stream, toArray]
  Interfaces in Collection: [Iterable]
  Set extends Collection, adds:[]
  Interfaces in Set: [Collection]
  HashSet extends Set, adds:[]
  Interfaces in HashSet: [Set, Cloneable, Serializable]
  LinkedHashSet extends HashSet, adds:[]
  Interfaces in LinkedHashSet: [Set, Cloneable,
  Serializable]
  TreeSet extends Set, adds: [headSet,
  descendinglterator, descendingSet, pollLast, subSet,
  floor, tailSet, ceiling, last, lower, comparator,
  pollFirst, first, higher]
  Interfaces in TreeSet: [NavigableSet, Cloneable,
  Serializable]
  List extends Collection, adds: [replaceAll, get,
  indexOf, subList, set, sort, lastlndexOf, listlterator]
  Interfaces in List: [Collection]
  ArrayList extends List, adds: [trimToSize,
  ensureCapacity]
  Interfaces in ArrayList: [List, RandomAccess,
  Cloneable, Serializable]
  LinkedList extends List, adds: [offerFirst, poll,
  getLast, offer, getFirst, removeFirst, element,
  removeLastOccurrence, peekFirst, peekLast, push,
  pollFirst, removeFirstOccurrence, descendinglterator,
  pollLast, removeLast, pop, addLast, peek, offerLast,
  addFirst]
  Interfaces in LinkedList: (List, Deque, Cloneable,
  Serializable]
  Queue extends Collection, adds: [poll, peek, offer,
  element]
  Interfaces in Queue: [Collection]
  PriorityQueue extends Queue, adds: [comparator]
  Interfaces in PriorityQueue: [Serializable]
  Map: [clear, compute, computelfAbsent,
  computelfPresent, containsKey, containsValue, entrySet,
  equals, forEach, get, getOrDefault, hashCode, isEmpty,
  keyset, merge, put, putAll, putlfAbsent, remove,
  replace, replaceAll, size, values]
  HashMap extends Map, adds:[]
  Interfaces in HashMap： [Map, Cloneable, Serializable]
  LinkedHashMap extends HashMap, adds:[]
  Interfaces in LinkedHashMap: [Map]
  SortedMap extends Map, adds: [LastKey, subMap,
  comparator, firstKey, headMap, tailMap]
  Interfaces in SortedMap: [Map]
  TreeMap extends Map, adds: [descendingKeySet,
  navigableKeySet, higherEntry, higherKey, floorKey,
  subMap, ceilingKey, pollLastEntry, firstKey, lowerKey,
  headMap, tailMap, lowerEntry, ceilingEntry,
  descendingMap, pollFirstEntry, LastKey, firstEntry,
  floorEntry, comparator, lastEntry]
  Interfaces in TreeMap: [NavigableMap, Cloneable,
  Serializable]
  */
  ```

# 构建复杂模型
  泛型有个重要的好处，即具有简单旦安全地创建复杂模型的能力  
  ```java
  class Product {
    private final int id;
    private String description;
    private double price;
    Product(int idNumber, String descr, double price) {
      id = idNumber;
      description = descr;
      this.price = price;
      System.out.println(toString())；
    }
    @Override public String toString() {
      return id + "： " + description +
        ", price: $" + price;
    }
    public void priceChange(double change) (
      price += change
    }
    public static Supplier<Product> generator =
      new Supplier<Product>() {
        private Random rand = new Random(47);
        @Override public Product get() {
          return new Product(rand.nextlnt(1000), "Test",
            Math.round(
              rand.nextDouble() * 1000.0) + 0.99);
        }
      };
  }

  class Shelf extends ArrayList<Product> {
    Shelf(int nProducts) {
      Suppliers.fill(this, Product.generator, nProducts);
    }
  }
  class Aisle extends ArrayList<Shelf> {
    Aisle(int nShelves, int nProducts) {
      for(int i = 0; i < nShelves; i++)
        add(new Shelf(nProducts));
    }
  }
  class Checkoutstand {}
  class Office {}

  public class Store extends ArrayList<Aisle> {
    private ArrayList<CheckoutStand> checkouts =
      new ArrayList<>();
    private Office office  =new Office();
    public Store(
      int nAisles, int nShelves, int nProducts) {  
      for(int i = 0; i < nAisles; i++)
        add(new Aisle(nShelves, nProducts));
    }
    @Override public String toString() {
      StringBuilder result = new StringBuilder();
      for(Aisle a : this)
        for(Shelf s : a)
          for(Product p : s) {
            result.append(p);
            result.append("\n");
          }
      return result.toString();
    }
    public static void main(String[] args) {
      System.out.println(new Store(5, 4, 3));
    }
  }
  ```
  ```java
  /* 输出：(First 8 Lines)
  258: Test, price: $490.99
  861: Test, price: $160.99
  868: Test, price: $417.99
  207: Test, price: $268.99
  551: Test, price: $114.99
  278: Test, price: $804.99
  520: Test, price: $554.99
  140: Test, price: $530.99
  ...
  */
  ```
  - 从Store.toString()方法可以看出效果：集合具有很多层.但仍然是类型安全旦便于管理的
  - Suppliers.fill()接收一个Collection类（第一个参数）,并通过Supplier（第二个参数）将n（第三个参数）个元素填充进该Collection

# 类型擦除的奥秘
  ```java
  public class ErasedTypeEquivalence {
    public static void main(String[] args) {
      Class cl = new ArrayList<String>().getClass();
      Class c2 = new ArrayList<Integer>().getClass();
      System.out.println(cl == c2);
    }
  }
  ```
  ```java
  /*输出：
  true
  */
  ```
  - `ArrayList<Stiing>`和`ArrayList<Integer>`应该是不同的类型,然而上面的程序会认为这两者是相同的类型

  ```java
  class Frob {}
  class Fnorkle {)
  class Quark<Q> {}
  class Particle<POSITION, M0MENTUM> {}

  public class Lostlnformation {
    public static void main(String[] args) {
      List<Frob> list = new ArrayList<>();
      Map<Frob, Fnorkle> map = new HashMap<>();
      Quark<Fnorkle> quark = new Quark<>();
      Particle<Long, Double> p = new Particle<>();
      System.out.println(Arrays.toString(
        list.getClass().getTypeParameters()));
      System.out.println(Arrays.toString(
        map.getClass().getTypeParameters()));
      System.out.println(Arrays.toString(
        quark.getClass().getTypeParameters()));
      System.out.println(Arrays.toString(
        p.getClass().getTypeParameters()));
    }
  }
  ```
  ```java
  /*输出：
  [E]
  [K, V]
  [Q]
  [POSITION, MOMENTUM]
  */
  ```
  - Class.getTypeParameters()会"返回一个由 TypeVariable 对象组成的数组，代表由泛型声明所声明的类型变量
  - 然而，如程序输出所示，你只能发现作为参数占位符的标识符

  泛型代码内部并不存在有关泛型参数类型的可用信息  
  你可以知道诸如类型参数的标识符和泛型类型的边界等信息，但你就是无法知道实际用于创建具体实例的类型参数  

  Java泛型是通过类型擦除实现的。这意味着在使用泛型时，任何具体的类型信息都将被擦除  
  `List<String>`和`List<Integer>`在运行时实际上是相同的类型。两者的类型都被“擦除”为它们的原始类型(raw type ): List  

## C++的实现方法
  ```c++
  #include <iostream>
  using namespace std;

  template<class T> class Manipulator {
    T obj;
  public:
    Manipulator(T x) { obj = x; }
    void manipulate() { obj.f(); }
  };

  class HasF {
  public:
    void f() { cout << "HasF::f()" << endl; }
  }

  int main() {
    HasF hf;
    Manipulater<HasF> manipulator(hf);
    manipulator.manipulate();
  }
  ```
  ```c++
  /*输出：
  HasF::f()
  */
  ```
  - C++编译器会在你实例化模板的时候进行检査，这样在实例化Manipulator<HasF>时.编译器便会看到HasF中存在方法f()。如果情况并非如此，就会出现编译时错误，从而保证了类型的安全
  - 用C++编写这类代码很简单,因为在实例化模板的时候.模板代码知道其自身模板参数的类型

  ```java
  public class HasF {
    public void f() {
      System.out.println( "HasF.f()");
    }
  }

  //示例剩余的部分，则会无法编译
  class Manipulator<T> {
    private T obj;
    Manipulator(T x) ( obj = x; }
    // Error: cannot find symbol: method f():
    public void manipulate() { obj.f(); }
  }

  public class Manipulation {
    public static void main(String[] args) {
      HasF hf = new HasF();
      Manipulator<HasF> manipulator =
        new Manipulator<>(hf);
      manipulator.manipulate();
    }
  }
  ```
  - 由于类型擦除的缘故，Java编译器无法将“manipulate()必须调用obj上的f()”的这个要求，关联到“HasF中存在f()方法”的这个事实上
  - 要调用f(),我们就必须帮助泛型类，为它指定边界，来告诉编译器只接受符合该边界的类型

  ```java
  class Manipulator2<T extends HasF> {
    private T obj;
    Manipulator2(T x) { obj = x; )
    public void manipulate(){ obj. f (); }
  }
  ```
  - 边界<T extends HasF>声明了 T必须是HasF类型或者其子类。如果符合这个条件,就可以安全地调用obj上的F()方法

  我们说泛型类型参数会被擦除为其第一个边界(你稍后会看到，多重边界也是可以的)  
  可以观察到，泛型在Manipulator2.java中没有做出任何贡献

  只有在类型参数比具体类型（及其所有子类）更加“泛型（泛化）” 的时候。也就是说，在希望代码能够跨多个类型运行的时候一泛型才会有所帮助  

  如果某个类有一个返回T的方法，那么泛型就能起作用.因为泛型可以让该方法返回精确的类型  
  ```java
  class ReturnGenericType<T extends HasF> (
    private T obj;
    ReturnGenericType(T x) { obj = x; )
    public T get() { return obj; }
  }
  ```

## 迁移的兼容性
  它是在Java泛型实现中必要的一种折中，因为泛型并不是这门语言与生俱来的一部分。这种折中会给你带来痛苦，所以尽早习惯它，并理解它为什么存在吧  
  如果泛型在Java 1.0的时候就是这门语言的一部分了，这个特性就不会用类型擦除来实现，而会通过具体化（reification）来将类型参数保持为第一类实体.这样你就可以对类型参数执行基于类型的语言操作和反射操作了  
  在基于类型擦除的实现中.泛型类型被视同于第二类类型处理.无法在某些重要的上下文中使用  
  泛型类型只在静态类型检查时期存在，在这之后.程序中所有的泛型类型都会被擦除，并替换为它们的非泛型上界。举例来说，List<T>这样的类型注解会被擦除为List,而普通的类型变量则被擦除为Object,除非指定了边界  

  类型擦除的核心初衷是，希望让泛化的调用方程序可以依赖于非泛化的库正常使用，反之亦然。这通常称为迁移兼容性  
  因此Java泛型不仅必须支持向后兼容性（即保证已有的代码和类文件都依旧是合法的，并且能继续保持原有的含义），而且还必须支持迁移兼容性.这样库才能按它们自己的节奏变得通用,并且一旦某个库变得通用了，便不会对依赖它的代码和程序造成破坏  
  类型擦除是唯一可行的方案。通过允许非泛型的代码和泛型代码共存，类型擦除实现了向泛型的迁移  

  要实现迁移兼容性，所有的库和程序都必须在是否使用了泛型这件事上各自保持无关。所以它们不能去检测其他库是否使用了泛型  

  如果没有某种迁移的途径，那么所有已经存在了很久的库都有可能要和选择迁移到Java泛型上的开发者们说再见了。库可以说是一门编程语言最有影响力的组成部分，因此这种代价是不可接受的。类型擦除是否是最佳甚至唯一的迁移途径，只有时间能给我们答案了  

## 类型擦除存在的问题
  类型擦除使得现有的非泛型调用方代码可以在不用修改的情况下继续使用，直至调用方做好了用泛型来重写代码的准备。这个动机非常有意义，因为它不会突然间破坏掉所有已有代码  
  类型擦除的代价也很大。泛型代码无法用于需要显式引用运行时类型的操作，比如类型转换 instanceof操作，以及new表达式  
  因为关于参数的所有类型信息都丢失了，所以在编写泛型代码时，你必须时刻提醒自己，你只是看起来掌握了参数的类型信息而已  

  ```java
  class Foo<T> {
    T var;
  }
  Foo<Cat> f = new Foo<>();
  ```
  class Foo中的代码看起来应该知道它现在是在使用Cat类。而泛型语法也在强烈暗示,类中各处的类型T都已经被替换了，如同C++中一样，但是并非如此。在为该类编写代码时，你必须时刻提醒自己————“不.它仍然只是一个Object”。  

  ```java
  class GenericBase<T> {
    private T element;
    public void set(T arg) ( element = arg; }
    public T get() { return element; }
  }
  class Derived1<T> extends GenericBase<T> {}
  class Derived2 extends GenericBase {} //未产生警告

  // class Derived3 extends GenericBase<?> {}
  //奇怪的错误：
  //  unexpected type
  //  required: class or interface without bounds

  public class ErasureAndInheritance {
    @SuppressWarnings("unchecked")
    public static void main(String[] args) {
      Derived2 d2 = new Derived2();
      Object obj = d2.get();
      d2.set(obj);       //此处出现警告
    }
  }
  ```
  - Derived2 继承自 GenericBase,但并未包含泛型参数.而编译器并未给出警告：直到调用set() ,警告才出现
  - 从Derived3产生的警告可以推断出，编译器期望的是一个原始的基类

  如果你希望将类型参数当作比Object更强大的武器，就需要付出额外的精力来管理边界  

## 边界的行为
  类型擦除的存在，使我发现了泛型最容易令人困惑的方面————可以将无意义的事物表达出来  
  ```java
  public class ArrayMaker<T> {
    private Class<T> kind;
    public ArrayMaker(Class<T> kind) { this.kind = kind; }
    @SuppressWarnings("unchecked")
    T[] create(int size) {
      return (T[])Array.newInstance(kind, size);
    }
    public static void main(String[] args) {
      ArrayMaker<String> stringMaker =
        new ArrayMakero(String.class);
      String[] stringArray = stringMaker.create(9);
      System.out.printin(Arrays.toString(stringArray));
    }
  }
  ```
  ```java
  /*输出:
  [null, null, null, null, null, null, null, null, null]
  */
  ```
  尽管kind看起来是被存储为Class<T>，但是类型擦除意味着它实际上只是被存为一个不带参数的Class  
  因此，在你使用它的时候，如同创建数组一样，Array.newInstance()并不实际掌握kind含有的类型信息。它无法生成具体的结果，因此必须进行类型转换，这会产生令人不悦的警告  
  注意对Array.newInstance()的使用，这是在泛型中创建数组的推荐方式  

  ```java
  public class ListMaker<T> {
    List<T> create() { return new ArrayList<>(); }
    public static void main(String[] args) {
      ListMaker<String> stringMaker = new ListMaker<>();
      List<String> stringList = stringMaker.create();
    }
  }
  ```
  - 尽管我们知道(由于类型擦除)，在create()内部的new ArrayList<>()方法中，<T>被移除了————在运行时，类中并没有<T>
  - 将表达式修改为new ArrayList(),编译器会产生警告

  ```java
  public class FilledList<T> extends ArrayList<T> {
    FilledList(Supplier<T> gen, int size) {
      Suppliers.fill(this, gen, size);
    }
    public FilledList(T t, int size) {
      for(int i = 0; i < size; i++)
      this.add(t);
    }
    public static void main(String[] args) {
      List<String> list = new FilledList<>("Hello", 4);
      System.out.printin(list);
      //用Supplier实现的版本：
      List<Integer> ilist = new FilledList<>(() -> 47, 4);
      System.out.println(ilist);
    }
  }
  ```
  ```java
  /*输出:
  [Hello, Hello, Hello, Hello] 
  [47, 47, 47, 47]
  */
  ```
  - 尽管在add()内部，编译器无法知道任何关于T的信息。但仍然可以在编译时确保向FilledList中放入的是类型T。因此.即使类型擦除移除了方法或类中的实际类型信息，编译器仍然能够确保类型使用方式的内部一致性

  由于类型擦除移除了方法体中的类型信息，运行时的关键便指向了边界————对象进入和离开某个方法的临界点。  
  编译器会在编译时在临界点执行类型检查，并插入类型转换的代码  
  ```java
  public class SimpleHolder {
    private Object obj;
    public void set(Object obj) { this.obj = obj; }
    public Object get() { return obj; )
    public static void main(String[] args) {
      SimpleHolder holder = new SimpleHolder();
      holder.set("Item");
      String s = (String)holder.get();
    }
  }
  ```
  - 而在调用get()时则会对类型转换进行检查

  ```java
  public class GenericHolder2<T> {
    private T obj;
    public void set(T obj) ( this.obj = obj; )
    public T get() { return obj; }
    public static void main(String[] args) {
      GenericHolder2<String> holder = 
        new GenericHolder2<>():
      holder.set("Item");
      String s = holder.get();
    }
  }
  ```
  - 看起来get()中不再需要进行类型转换了，但是我们仍然知道传给set()的值经过了编译期类型检查
  - set()中对传入类型的额外检查工作是编译器自动执行的。而对get()输出值的类型转换仍然存在，但并不比你自己来实现做得少

  泛型所有的行为都发生在边界。包括对传入值额外的编译时检查，和对输出值插入的类型转换；记住“边界是行为发生的地方”，这有助于减少对类型擦除产生的困惑  

# 对类型擦除的补偿
  由于类型擦除的缘故，我们失去了在泛型代码中执行某些操作的能力。任何需要在运行时知道确切类型的操作都无法运行  
  ```java
  public class Erased<T> {
    private final int SIZE = 100;
    public void f(Object arg) {
      // error: illegal generic type for instanceof
      // if(arg instanceof T) {}

      // error: unexpected type
      // T var = new T();

      // error: generic array creation
      // T[] array = new T[SIZE];

      // warning: [unchecked] unchecked cast
      // T[] array = (T[])new Object[SIZE];
    }
  }
  ```

  你可以偶尔在编程时绕过这些问题，但是有时你必须通过引入类型标签(type tag)来补偿类型擦除导致的损失  
  类型标签则可以提供动态的isInstance()能力：  
  ```java
  class Building {}
  class House extends Building {}

  public class ClassTypeCapture<T> {
    Class<T> kind;
    public ClassTypeCapture(Class<T> kind) {
      this.kind = kind;
    }
    public boolean f(Object arg) {
      return kind.isInstance(arg);
    }
    public static void main(String[] args) {
      ClassTypeCapture<Building> cttl =
        new ClassTypeCaptureo(Building.class);
      System.out.printin(cttl.f(new Building()))；
      System.out.printin(cttl.f(new House()));
      ClassTypeCapture<House> ctt2 =
        new ClassTypeCaptureo(House.class);
      System.out.println(ctt2.f(new Building()));
      System.out.println(ctt2.f(new House()));
    }
  }
  ```
  ```java
  /*输出：
  true
  true
  false
  true
  */
  ```
  编译器保证了类型标签能够和泛型参数匹配  

## 创建类型实例
  创建new T()是不会成功的，部分原因是类型擦除，另一部分原因是编译器无法验证T中是否存在无参构造器  
  传入一个工厂对象.并通过它来创建新实例, Class对象就是一个方便的工厂对象，因此如果你使用了类型标签.便可以通过newInstance()来创建该类型的新对象  
  ```java
  class ClassAsFactory<T> implements Supplier<T> {
    Class<T> kind;
    ClassAsFactory(Class<T> kind) {
      this.kind = kind;
    }
    @0verride public T get() {
      try {
        return kind.getConstructor().newInstance();
      } catch(Exception e) {
        throw new RuntimeException(e);
      }
    }
  }

  class Employee {
    public Employee() {}
    @Override public String toString() {
      return "Employee";
    }
  }
  public class InstantiateGenericType {
    public static void main(String[] args) {
      ClassAsFactory<Employee> fe =
        new ClassAsFactory<>(Employee.class);
      System.out.println(fe.get());
      ClassAsFactory<Integer> fi =
        new ClassAsFactoryo(Integer.class);
      try {
        System.out.printin(fi.get());
      } catch(Exception e) {
        System.out.printin(e.getMessage());
      }
    }
  }
  ```
  ```java
  /*输出:
  Employee
  java.lang.NoSuchMethodException:
  java.lang.Integer.<init>()
  */
  ```
  - 这样可以编译成功，但如果使用ClassAsFactory<Integer>则会失败，因为Integer中并没有无参构造器

  由于该错误并不是在编译期捕获的，因此这种方法遭到Java设计者们的反对。他们建议使用显式工厂（Supplier）,并对类型进行限制，使其仅能接收实现了该工厂的类。下面是创建工厂的两种不同方法:  
  ```java
  class IntegerFactory implements Supplier<Integer> {
    private int i = 0;
    @Override public Integer get() {
      return ++i；
    }
  }
  class Widget {
    private int id;
    widget(int n) ( id = n; }
    @Override public String toString() {
      return "Widget " + id;
    }
    public static
    class Factory implements Supplier<Widget> {
      private int i = 0;
      @Override
      public Widget get () { return new Widget(++i); }
    }
  }
  class Fudge {
    private static int count = 1;
    private int n = count++;
    @Override public String toString() {
      return "Fudge " + n;
    }
  }
  class Foo2<T> {
    private List<T> x = new ArrayList<>();
    Foo2(Supplier<T> factory) {
      Suppliers.fill(x, factory, 5);
    }
    @Override public String toString() {
      return x.toString();
    }
  }
  public class Factoryconstraint {
    public static void main(String[] args) {
      System.out.println(
        new Foo2<>(new IntegerFactory())):
      System.out.println (
        new Foo2<>(new Widget.Factory()));
      System.out.println(
        new Foo2<>(Fudge::new));
    }
  }
  ```
  ```java
  /*输出:
  [1, 2, 3, 4, 5]
  (Widget 1, Widget 2, Widget 3, Widget 4, Widget 5]
  [Fudge 1, Fudge 2, Fudge 3, Fudge 4, Fudge 5]
  */
  ```
  - 注意Fudge并不执行任何类似工厂的操作.但是传入Fudge::new仍然会产生工厂的行为，因为编译器将对函数方法::new的调用，转变成了对get()的调用

  另一种方式是使用设计模式：模板方法(Template Method)。在下面的示例中,create()就是那个模板方法，其在子类中被重写，用来生成该类型的对象  
  ```java
  abstract class GenericWithCreate<T> {
    final T element;
    GenericWithCreate() { element = create(); }
    abstract T create();
  }
  class X {}
  class XCreator extends GenericWithCreate<X> {
    @Override X create() { return new X(); }
    void f() {
      System.out.println(
        element.getClass().getSimpleName());
    }
  }
  public class CreatorGeneric {
    public static void main(String[] args) {
      XCreator xc = new XCreator();
      xc.f();
    }
  }
  ```
  ```java
  /*输出：
  x
  */
  ```

## 泛型数组
  你是无法创建泛型数组的。通用的解决办法是不管在何处,你都用AnayList来创建泛型数组：  
  ```java
  public class ListOfGenerics<T> {
    private List<T> array = new ArrayList<>();
    public void add(T item) { array.add(item); }
    public T get(int index) { return array.get(index); }
  }
  ```

  有时你仍然需要创建泛型类型的数组.你可以定义一个泛型引用，指向一个数组  
  ```java
  class Generic<T> {}

  public class ArrayOfGenericReference {
    static Generic<Integer>[] gia;
  }
  ```
  编译器接受了这种方式，没有产生警告。但是你你永远无法创建该确切类型（包括类型参数）的数组，因此这有点让人疑惑  

  所有的数组不论持有的是什么类型.都有着相同的结构（包括每个数组的大小和布局），因此你似乎可以创建一个Object数组.并将其转换
为目标数组类型 这确实可以通过编译.但会在运行时抛出ClassCastException异常：  
  ```java
  public class ArrayOfGeneric {
    static final int SIZE = 100;
    static Generic<Integer>[] gia;
    @SuppressWarnings("unchecked")
    public static void main(String[] args) {
      try {
        gia = (Generic<Integer>[])new Object(SIZE];
      } catch(ClassCastException e) {
        System.out .println(e.getMessage());
      }
      //运行时的类型是原始类型(已被擦除)：
      gia = (Generic<Integer>[] )new Generic[SIZE];
      System.out.println(gia.getClass().getSimpleName());
      gia[0] = new Generic<>();
      // gia[1] = new Object(); //编译时错误
      //在编译时发现类型不匹配：
      // gia[2] = new Generic<Double>();
    }
  }
  ```
  ```java
  /*揄出:
  [Ljava.lang.Object; cannot be cast to [LGeneric;
  Generic[]
  */
  ```
  - gia被转型为Generic<Integer>[],该信息也只会存在于编译时。在运行时，它仍然还是Object数组，而这会导致问题
  - 唯一可以成功创建泛型类型数组的方法就是创建一个类型为被擦除类型的新数组，然后再对其进行类型转换

  ```java
  public class GenericArray<T> {
    private T[] array;
    @SuppressWarnings("unchecked")
    public GenericArray(int sz) {
      array = (T[])new Object[sz];
    }
    public void put(int index, T item) {
      array[index] = item；
    }
    public T get(int index) { return array[index]; }
    //暴露了潜在表现形式的方法：
    public T[] rep() { return array; }
    public static void main(String[] args) {
      GenericArray<Integer> gai = new GenericArray<>(10);
      try {
          Integer[] ia = gai.rep():
      } catch(ClassCastException e) {
        System.out.println(e.getMessage())；
      }
      //这没问题：
      Object[] oa = gai.rep();
    }
  }
  ```
  ```java
  /*输出：
  [Ljava.lang.Object; cannot be cast to
  [Ljava.lang.Integer;
  */
  ```
  - rep()并试图将结果作为Integer[]的引用来获取，便会抛出ClassCastException异常，这仍然是因为运行时类型实际是Object[]

  数组的运行时类型只能是Object[]如果我们立刻将其转型为T[],那么在编译时，数组的实际类型便会丢失，编译器就可能会错过对某些潜在错误的检查。因此，更好的办法是在集合内使用Object[],并在使用某个数组元素的时候増加转型为T的操作  
  ```java
  public class GenericArray2<T> {
    private Object[] array;
    public GenericArray2(int sz) {
      array = new Object[sz];
    }
    public void put(int index, T item) {
      array[index] = item;
    }
    @SuppressWarnings("unchecked")
    public T get(int index) { return (T)array[index]; }
    @SuppressWarnings ("unchecked")
    public T[] rep() {
      return (T[])array;             //未检查的类型转换
    }
    public static void main(String[] args) {
      GenericArray2<Integer> gai =
        new GenericArray2<>(10);
      for(int i = 0; i < 10; i ++)
        gai.put(i, i);
      for(int i = 0; i < 10; i ++)
        System.out.print(gai.get(i) + "  ");
      System.out.println();
      try {
        Integer[] ia = gai.rep();
      } catch(Exception e) {
        System.out.println(e);
      }
    }
  }
  ```
  ```java
  /*输出：
  0  1  2  3  4  5  6  7  8  9
  java.lang.ClassCastException: [Ljava.lang.Object;
  cannot be cast to [Ljava.lang.Integer;
  */
  ```
  - 在调用get()方法时，该方法会将对象转型为T,这实际上是正确的类型，因此是安全的
  - 不过如果调用rep(),该方法会再次试图将Object[]转型为T[],这仍然是错误的.并且会产生编译时警告和运行时异常
  - 因此,没有任何办法可以推翻底层的数组类型，该类型只能是Object[]。在内部将array当作Object[]而不是T[]来进行处理.这样做的好处是，可以减少由于你忘记了数组的运行时类型，而意外产生bug的可能性

  对于新代码，应该传入一个类型标记。这种情况下的GenericArray看起来是这样的：  
  ```
  public class GenericArrayWithTypeToken<T> {
    private T[] array;
    @SuppressWarnings("unchecked")
    public
    GenericArrayWithTypeToken(Class<T> type, int sz) {
      array = (T[])Array.newInstance(type, sz);
    }
    public void put(int index, T item) {
      array[index] = item;
    }
    public T get(int index) { return array[index]; }
    //暴露潜在的表达方式：
    public T[] rep() { return array; }
    public static void main(String[] args) {
      GenericArrayWithTypeToken<Integer> gai =
        new GenericArrayWithTypeToken<>(
          Integer.class, 10);
      //现在可以正常运行了：
      Integer[] ia = gai.rep();
    }
  }
  ```
  - 这里将类型标记Class<T>传入了构造器，以用于擦除后的类型恢复，这样就能够创建实际所需类型的数组了
  - 数组的运行时类型是精确的T[]类型

  Neal Gafter（ Java 5的主要开发人员之一）在他的博客中指出过，他无法在不破坏已有接口的情况下解决某些Java库代码的问题。  
  所以即使Java库的源代码中出现了某些便用做法，这也不一定是正确的做法。你在阅读库代码的时候，不能把这些当成可以在自己的代码中遵循的范例  

# 边界
  边界让你在使用泛型的时候，可以在参数类型上增加限制  
  虽然这可以强制执行应用泛型的类型规则，但更重要的潜在效果是，你可以调用边界类型上的方法了  

  由于类型擦除移除了类型信息，对于无边界的泛型参数，你仅能调用Object中可用的方法  
  不过如果能够将参数类型限制在某个类型子集中，你就可以调用该子集上可用的方法了  
  为了应用这种限制,Java泛型复用了 extends关键字  

  相较于extends关键字的常规用法，它在泛型边界上下文中代表着完全不同的意义,理解这一点非常重要：  
  ```java
  interface HasColor { java.awt.Color getColor(); }

  class WithColor<T extends HasColor> {
    T item;
    WithColor(T item) { this.item = item; }
    T getltem() { return item; )
    //可以调用边界中的方法：
    java.awt.Color color() { return item.getColor(); }
  }

  class Coord { public int x, y, z; }

  //这样会失败：类(Coord)必須在最前面，然后才是接口(HasColor):
  // class WithColorCoord<T extends HasColor & Coord> {

  //多重边界：
  class WithColorCoord<T extends Coord & HasColor> {
    T item;
    WithColorCoord(T item) { this.item = item; }
    T getItem() { return item; }
    java.awt.Color color() { return item.getColor(); }
    int getX() { return item.x; }
    int getY() { return item.y; }
    int getZ() { return item.z; }
  }

  interface Weight { int weight(); }

  //和使用继承一样，只能继承一个具体，而可以实现多个接口
  class Solid<T extends Coord & HasColor & Weight> {
    T item;
    Solid(T item) { this.item = item; }
    T getItem() { return item; }
    java.awt.Color color() ( return item.getColor(); }
    int getX() { return item.x; }
    int getY() { return item.y; )
    int getZ() { return item.z; )
    int weight() { return item.weight(); }
  }

  class Bounded
  extends Coord implements HasColor, Weight {
    @Override
    public java.awt.Color getColor() { return null; }
    @Override public int weight() { return 0; }
  }

  public class BasicBounds {
    public static void main(String(] args) {
      Solid<Bounded> solid =
        new Solid<>(new Bounded()):
      solid.color();
      solid.getY();
      solid.weight();
    }
  }
  ```

  ```java
  //你可以这样做：
  List<? extends SuperHearing> audioPeople;
  //但不能这样做：
  // List<? extends SuperHearing & SuperSmell> dogPs;
  ```
  这里出现了通配符，只限于使用单边界  

# 通配符
  ```java
  class Fruit {}
  class Apple extends Fruit {}
  class Jonathan extends Apple {}
  class Orange extends Fruit {}

  public class CovariantArrays {
    public static void main(String[] args) {
      Fruit[] fruit = new Apple[10]:
      fruit[0] = new Apple(); // OK
      fruit[1] = new Jonathan(); // OK
      //运行时类型是Apple[],而不是 Fruit[]或Orange[]:
      try {
        //编译器允许添加Fruit：
        fruit[0] = new Fruit();            // 会导致 ArrayStoreException 异常
      } catch(Exception e) { System.out.println(e); }
      try { 
        //编译器允许添加Oranges:
        fruit[0] = new Orange();           // 会导致 ArrayStoreException 异常
      } catch(Exception e) { System.out.println(e); }
    }
  }
  ```
  ```java
  /*输出:
  java.lang.ArrayStoreException: Fruit
  java.lang.ArrayStoreException: Orange
  */
  ```
  - main()方法的第一行创建了一个Apple数组，并将其赋值给一个指向Fruit数组的引用
  - 实际的数组类型是Apple[],可以将Apple或Apple的子类放入该数组，这实际上在编译时和运行时都是没问题的
  - 将Fruit对象，或任何Fruit派生出来的对象，例如Orange （橙子），放入该数组: 在编译时，这是允许的。但是运行时的数组机制知道自己是在处理Apple[],并会在向该数组中放入异构类型时抛出异常
  - 数组对象可以维持它们包含的对象的类型规则。这就好像是数组能够意识到它们持有的是什么，所以在编译时检查和运行时检查之间，你无法对数组进行滥用

  ```java
  public class NonCovariantGenerics {
    // Compile Error: incompatible types:
    List<Fruit> flist = new ArrayList<Apple>();
  }
  ```
  - 泛型并不是只和集合有关。这里真正表达的是，“你无法将包含Apple的泛型赋值给包含Fruit的泛型”

  问题的本质在于，我们讨论的是集合自身的类型，而不是它所持有的元素类型。  
  和数组不同，泛型并没有内建的协变性。  
  数组是完全在语言内部定义的.因此可以同时拥有编译时和运行时的内建检查。  
  对于泛型，编译器和运行时系统无法得知应该怎样处理你的类型,以及该制定怎样的规则  

  ```java
  public class GenericsAndCovariance {
    public static void main(String[] args) {
      //通配符提供了协变性的能力：
      List<? extends Fruit> flist = new ArrayList<>();
      // Compile Error: can't add any type of object:
      // flist.add(new Apple());
      // flist.add(new Fruit());
      // flist.add(new Object());
      flist.add(null); //合法，但没什么意义
      //我们知道至少能返回Fruit：
      Fruit f = flist.get(0);
    }
  }
  ```
  - flist的类型现在变成了 List<? extends Fruit>, 但是这并不意味着List真的会持有任何Fruit类型
  - 通配符引用指向了某个确定的类型，因此真正的意义是“某种flist引用未指定的具体类型”
  - 因此被赋值的List必须持有某种具体的类型，例如Fruit或Apple
  - 但是为了向上转型为flist,该类型是什么并没有人关心

  你不知道List持有的是什么类型，你又如何能安全地向其中添加对象呢？  
  你不能像CovariantArrays的的“向上转型”数组这样做，除非编译器能阻止类型不匹配的操作发生，而不是等到运行时系统（再来阻止）  

  一旦你进行了这种“向上转型”，便失去了向其中传入任何对象的能力，即使是传入Object也是如此  

## 编译器有多聪明？
  ```java
  public class Compilerintelligence {
    public static void main(String[] args) {
      List<? extends Fruit> flist =
        Arrays.asList(new Apple());
      Apple a = (Apple)flist.get(0);            // 未产生警告
      flist.contains(new Apple());             // 参数是 Object
      flist.indexOf(new Apple());               // 参数是 Object
    }
  }
  ```
  - 在你声明了ArrayList<? extends Fruit>后,add()的参数便成了 ? extends Fruit
  - 编译器无法知道该处要求的是哪种具体的Fruit子类型.因此便不会接受任何Fruit的类型
  - 如果参数列表中带有通配符,编译器会直接拒绝调用方法(如add())
  - 对于contains()和indexOf()来说，参数类型是Object类型，因此并不包含通配符,编译器会允许该调用

  ```java
  public class Holder<T> {
    private T value;
    public Holder() {}
    public Holder(T vat) { value = val; }
    public void set(T val) ( value = vat; )
    public T get() ( return value; }
    @Override public boolean equals (Object o) {
      return o instanceof Holder &&
        Objects.equals(value, ((Holder)o).value);
    }
    @Override public int hashCode() {
      return Objects.hashCode(value);
    }
    public static void main(String[] args) {
      Holder<Apple> apple = new Holdero(new Apple());
      Apple d = apple.get();
      apple.set(d);
      // Holder<Fruit> Fruit = apple;               // 无法向上转型
      Holder<? extends Fruit> fruit = apple;        // OK
      Fruit p = fruit.get();
      d = (Apple)fruit.get();                       // 返回Object
      try {
        Orange c = (Orange)fruit.get();             // 无警报
      } catch(Exception e) { System.out.println(e); )
        // fruit.set (new Apple());                 // 无法调用 set()
        // fruit.set (new Fruit());                 // 无法消用 set()
        System.out.println(fruit.equals(d));        //OK
    }
  }
  ```
  ```java
  /*输出：
  java.lang.ClassCastException: Apple cannot be cast to
  Orange
  false
  */
  ```
  - 如果创建了`Holder<Apple>`,就无法将其向上转型为`Holder<Fiuit>`,但是可以向上转型为Holder<? extends Fruit>
  - 向上转型为Holder<? extends Fruit>后，如果调用get(),则只能返回Fruit
  - 如果你知道此处是什么类型，便可以转型为某个具体的Fruit类型，并旦不会产生相关的警告，但这有抛出ClassCastException的风险
  - Apple或Fruit都无法用于set()方法,因为set()方法的参数同样是 ? Extends Fruit,这意味着它可以是任意类型，而编译器无法为“任意类型”验证安全性
  - equals()方法没有问题，因为它接收Object作为参数，而不是T。因此编译器只会关心传入和返回的对象类型

  Java 7引入了 java.util.Objects,其目的之一就是为了更容易地创建equals()和hashCode()方法

## 逆变性
  超类通配符(supertype wildcard ):是为通配符增加了边界限制，边界范围是某个类的任何基类，具体方式为<? super MyClass>或者甚至是使用类型参数<? super T>  
  (不过你无法给泛型参数设置超类边界，也就是说，无法这样声明：<T super MyClass> )  
  ```java
  public class SuperTypeWildcards {
    static void writeTo(List<? super Apple> apples) {
      apples.add(new Apple());
      apples.add(new Jonathan());
      // apples.add (new Fruit()); // 错误
    }
  }
  ```
  - 因此你知道可以安全地向其中添加Apple类型或其子类。不过其下界(lower bound)是Apple
  - 你并不知道是否可以安全地向这样一个List中添加Fruit.因为这会使得List对其他非Apple的类型也敞开怀抱，而这违反了静态类型的安全性————添加不确定类型对象

  ```java
  public class GenericReading {
    static List<Apple> apples =
      Arrays.asList(new Apple());
    static List<Fruit> fruit = Arrays.asList(new Fruit());
    static <T> T readExact(List<T> list) {
      return list.get(0);
    }
    //兼容每种调用的静态方法：
    static void f1() {
      Apple a = readExact(apples);
      Fruit f = readExact(fruit);
      f = readExact(apples);
    }
    //类被实例化后，其类型即被确定：
    static class Reader<T> {
      T readExact(List<T> list) { return Ust.get(0); }
    }
    static void f2() {
      Reader<Fruit> fruitReader = new Reader<>();
      Fruit f = fruitReader.readExact(fruit);
      //- Fruit a = fruitReader.readExact(apples);
      // error: incompatible types: List<Apple>
      //无法转型为List<Fruit>
    }
    static class CovariantReader<T> {
      T readCovariant(List<? extends T> list) {
        return list.get(0);
      }
    }
    static void f3() {
      CovariantReader<Fruit> fruitReader =
        new CovariantReader<>();
      Fruit f = fruitReader.readCovariant(fruit);
      Fruit a = fruitReader.readCovariant(apples);
    }
    public static void main(String[] args) {
      fl()； f2(); f3();
    }
  }
  ```
  - 静态泛型方法readExact()对毎个方法调用都可以有效地兼容
  - 如你在门f1()中所见，从List<Apple>中返回Apple,以及从List<Fruit>中返回Fruit
  - 如果使用泛型类的话，在你为该类实例化一个对象的时候，其参数即被确定下来
  - 如f2()所示，因为fruitReader的具体类型是Fruit,所以它可以从List<Fruit>中读取单个Fruit。但是List<Apple>应该也能生成Fruit对象，而fruitReader并不允许这样
  - CovaiiantReader.readCovaiiant()方法接收了 List<? extends T>作为参数。从该list中读取T是安全的，因为你知道里面的所有元素都至少是T,也可能是T的某种子类。在f3()中，你可以看到现在可以从List<Apple>中读取Fruit了。

## 无界通配符
  无界通配符(unbounded wildcard) <?>似乎意味着“任何类型”，”，所以使用无界通配符似乎就等于使用某个原始类型  
  ```java
  public class UnboundedWildcardsl {
    static List listl;
    static List<?> list2;
    static List<? extends Object> list3;
    static void assign1(List list) {
      listl = list;
      list2 = list;
      //- list3 = list;
      // required: List<? extends Object>
      // found:    List
    }
    static void assign2(List<?> list) {
      listl = list;
      list2 = list;
      list3 = list;
    }
    static void assign3(List<? extends Object> list) {
      listl = list;
      list2 = list;
      list3 = list;
    }
    public static void main (String [] args) {
      assignl(new ArrayList())；
      assign2(new ArrayList());
      //- assign3(new ArrayList());
      // required: List<? extends Object>
      // found: ArrayList

      assign1(new ArrayList<>());
      assign2(new ArrayList<>());
      assign3(new ArrayList<>());
      //两种形式都可以作为List<?>被接受：
      List<?> wildList = new ArrayList();
      wildList = new ArrayList<>();
      assignl(wildList);
      assign2(wildList);
      assign3(wildList);
    }
  }
  ```
  - 编译器可以不用那么关心你用的是原始类型还是<?>。在那些场景下，可以把<?>认为是一种装饰
  - 实际上它的潜台词是，“我写这段代码时考虑了 Java泛型，但并不是说要使用原始类型,只是在当前场景下。泛型参数可以持有任何类型”

  在处理多重泛型参数的时候.有时需要在将参数初始化为某种具体类型时，允许其中某个参数可以是任何类型：  
  ```java
  public class UnboundedWildcards2 {
    static Map mapl;
    static Map<?,?> map2;
    static Map<String,?> map3;
    static void assignl(Map map) { mapl = map; }
    static void assign2(Map<?,?> map) ( map2 = map; }
    static void assign3(Map<String, ?> map) ( map3 = map; }
    public static void main(String[] args) {
      assign1(new HashMap())；
      assign2(new HashMap());
      //- assign3(new HashMap());
      //  required: Map<String,?>
      //  found: HashMap
   
      assignl(new HashMap<>());
      assign2(new HashMap<>());
      assign3(new HashMap<>());
    }
  }
  ```
  - 泛型参数会被擦除为其第一个边界类型,，List<?>会看起来等同于List<Object>,而List也实际上相当于List<Object>————只是这两种说法都并不完全正确
  - List实际上是指“持有任意Object类型的原生List”，而List<?>是指“持有某种具体类型的非原生List”，但我们并不知道是什么类型

  示例内部包含若干不同形式的以Holder为参数的方法————以原始类型方式、带有具体的类型参数，以及带有无界通配符的参数:  
  ```java
  public class Wildcards {
    //原始类型：
    static void rawArgs(Holder holder, Object arg) {
      //- holder.set(arg);
      // warning: [unchecked] unchecked call to set(T)
      // as a member of the raw type Holder

      //这样不行，并没有'T' ：
      // T t = holder.get();

      //这样可以，但是丢失了类型信息:
      Object obj = holder.get();
    }
    //和rawArgs()类似，但是会产生错误而不是警告：
    static void
    unboundedArg(Holder<?> holder, Object arg) {
      //- holder.set(arg);
      //    required: CAP#1
      //    found: Object
      
      //这样不行，并没有'T'
      // T t = holder.get();

      //这样可以，但是去失了类型信息:
      Object obj = holder.get();
    }
    static <T> T exactl(Holder<T> holder) {
      return holder.get();
    }
    static <T> T exact2(Holder<T> holder, T arg) {
      holder.set(arg);
      return holder.get();
    }
    static <T>
    T wildSubtype(Holder<? extends T> holder, T arg) (
      //- holder.set(arg):
      // required: CAP#1
      // found: T#1
 
      return holder.get();
    }
    static <T>
    void wildSupertype(Holder<? super T> holder, T arg) {
      holder.set(arg)
      // T t = holder.get();
      // error: incompatible types:
      // CAP#1 cannot be converted to T
     
      //这样可以，但是丢失了类型信息:
      Object obj = holder.get();
    }
    public static void main(String[] args) {
      Holder raw =new Holder<>();
      //或者：
      raw = new Holder()；
      Holder<Long> qualified = new Holder<>();
      Holder<?> unbounded = new Holder<>();
      Holder<? extends Long> bounded = new Holder<>();
      Long lng = 1L;

      rawArgs(raw, lng);
      rawArgs(qualified, lng);
      rawArgs(unbounded, lng);
      rawArgs(bounded, lng);

      unboundedArg(raw, lng);
      unboundedArg(qualified, lng);
      unboundedArg(unbounded, lng);
      unboundedArg(bounded, lng);

      // Object rl = exactl(raw);
      // required: Holder<T>
      // found: Holder

      Long r2 = exactl(qualified);
      Object r3 = exactl(unbounded);       // 必须返回 Object
      Long r4 = exactl(bounded);

      // Long r5 = exact2(raw, lng);
      // required: Holder<T>,T 
      // found: Holder,Long

      Long r6 = exact2(qualified, lng);

      // Long r7 = exact2(unbounded, lng);
      // required: Holder<T>,T
      // found: Holder<CAP#1>,Long

      // Long r8 = exact2(bounded, lng);
      // required: Holder<T>,T
      // found: Holder<CAP#1>,Long

      // Long r9 = wildSubtype(raw, Ing);
      // required: Holder<? extends T>,T
      // found: Holder,Long

      Long rl0 = wildSubtype(qualified, lng);
      //这样可以，但是只能返回Object：
      Object rll = wildSubtype(unbounded, lng);
      Long rl2 = wildSubtype(bounded, lng);

      // wildSupertype(raw, lng);
      // required: Holder<? super T>,T
      // found: Holder,Long

      wildSupertype(qualified, lng);

      // wildSupertype(unbounded, lng);
      // required: Holder<? super T>,T
      // found: Holder<CAP#l>,Long

      // wildSupertype(bounded, lng)
      // required: Holder<? super T>,T
      // found: Holder<CAP#l>,Long
    }
  }
  ```
  - 在rawArgs()中,编译器知道Holder是泛型类型，即使它在这里被表示为原始类型。因为它是原始类型，所以可以向set()中传入任何类型的对象，该对象会被向上转型为Object。因此不论何时，要使用原始类型就意味着要放弃编译时检查  
    对get()的调用也有同样的问题：因为没有T,所以结果只能是 Object  
  - Holder和Holder<?>两者是不同的。这是因为原生Holder可以持有任何类型的组合，而Holder<?>则只能持有由某种具体类型组成的单类型集合，因此你不能只传入一个 Object
  - wildSubtype()中，对Holder类型的限制被放宽了，以允许持有符合extends T条件的任意类型的Holder  
    调用set()(或任何以该类型参数为参数的方法)是不允许的。不过，你仍然知道从Holder<? extends Fruit>中读取出的任何元素都至少是Fruit,因此调用get()(或任何以该类型参数为返回值的方法)是允许的  
  - wildSupertype()方法中出现了超类通配符，holder可以是一个持有T的任意基类的集合。因此，set()可以将T作为参数：这是
因为可以使用基类的地方，由于多态性的缘故，就一定也可以使用派生类(因此使用T)。不过，调用get()的意义不大,因为holder持有的类型可以是任意超类，所以唯一安全的类型是Object
  - 对于unboundedArg()中的无界参数.什么样的操作是允许的，什么样的操作是不允许的，限制在于：你无法get()或者set()一个T,因为这里并不存在T
  - main()中,为了迁移兼容性,rawArgs()可以接收Holder的所有不同变种,而不产生警告。unboundedArg()方法同样可以接收所有的Holder类型，不过就像之前提到过的，该方法在内部对这些参数的处理是不同的
  - 如果你向某个以“具体的”泛型类型(无通配符)为参数的方法传入了原生Holder类型的引用.就会产生瞥告，因为具体参数所需的信息在原生类型中并不存在
  - exact2()所受的限制最大，因为它明确地需要传入Holder<T>和类型参数T。如果未给该方法指定具体的参数.就会产生错误或警告
  - 但如果显得过于严格，你也可以使用通配符，这取决于你是要从泛型参数(如wildSubtype()中所示)获得类型化的返回值，还是要向泛型参数中传入类型化参数(如wildSupertype()中所示)
  - 使用确切类型而不是通配符类型，其好处在于，你可以用泛型参数做更多的事。但是通配符可以将更大范围的参数化类型作为参数

## 捕获转换
  如果向某个使用了<?>的方法传入了原生类型，编译器有可能会推断出具体的类型参数，因此该方法可以转而调用另一个使用了该具体类型的方法  
  捕获转换(capture conversion ): 捕获未指定的通配符类型，并将其转化为某个具体类型  
  ```java
  public class CaptureConversion {
    static <T> void f1(Holder<T> holder) {
      T t = holder.get();
      System.out.println(t.getClass().getSimpleName());
    }
    static void f2(Holder<?> holder) {
      f1(holder);         //用捕获的类型来调用方法
    }
    @SuppressWarnings("unchecked")
    public static void main(String[] args) {
      Holder raw = new Holder<>(1);
      f1(raw);
      // required: Holder<T>
      // found: Holder
  
      f2(raw);             //不产生警告
      Holder rawBasic = new Holder();

      rawBasic.set(new Object());
      // warning: [unchecked] unchecked call to set(T)
      // as a member of the raw type Holder

      f2(rawBasic);           //不产生警告
      //向上转型为Holder<?>,仍可推断出具体类型：
      Holder<?> wildcarded = new Holder<>(1.0);
      f2(wildcarded);
    }
  }
  ```
  ```java
  /*输出：
  Integer
  Integer
  Object
  Double
  */
  ```
  - f1()中的类型参数都是具体的类型，而未使用通配符或边界
  - 在f2()中，Holder参数是无边界通配符
  - 在f2()中.对f1()逬行了调用,而f1()需要已知类型的参数,所以这里面实际上是在调用f2()的过程中捕获了参数的类型，并将其用于对f1()的调用
  - 写入场景，而这需要你在传入Holder<?>的同时，额外传入一个具体的类型
  - 捕获转换仅适用于“在方法中必须使用确切类型”的情况
  - 你无法从f2()方法中返回T,因为对于f2()来说，T是未知的

# 问题

## 基本类型不可作为类型参数
  Java泛型的限制之一，是你无法将基本类型作为类型参数，因此你无法创建例如ArrayList<int>这样的类型  
  解决的办法是使用基本类型的包装类，并结合自动装箱机制  
  ```java
  public class ListOflnt {
    public static void main(String[] args) {
      List<Integer> li = IntStream.range(38, 48)
        .boxed ()             //将int元素转换为Integer类型
        .collect(Collectors. toListO);
      System.out.println(li);
    }
  }
  ```
  ```java
  /*输出：
  [38, 39, 48, 41, 42, 43, 44, 45, 46, 47]
  */
  ```

  ```java
  public class ByteSet {
    Byte[] possibles = { 1,2,3,4,5,6,7,8,9 };
    Set<Byte> mySet = 
      new HashSet<>(Arrays.asList(possibles));
    //但你不能这样：
    // Set<Byte> mySet2 = new HashSet<>(
    //   Arrays.<Byte>asList(l,2,3,4,5,6,7,8,9));
  }
  ```

  ```java
  //用生成器填充数组
  interface FillArray {
    static <T> T[] fill(T[] a, Supplier<T> gen) {
      Arrays.setAll(a, n -> gen.get());
      return a;
    }
    static int[] fill(int[] a, IntSupplier gen) {
      Arrays.setAll(a, n -> gen.getAsInt());
      return a;
    }
    static long[] fill(long[] a, LongSupplier gen) {
      Arrays.setAll(a, n -> gen.getAsLong());
      return a;
    }
    static double[] fill(double[] a, DoubleSupplier gen) {
      Arrays.setAll(a, n -> gen.getAsDouble());
      return a;
    }
  }

  public class PrimitiveGenericTest {
    public static void main(String[] args) {
      String[] strings = FillArray.fill(
        new String[5], new Rand.String(9));
      System.out.printin(Arrays.toString(strings));
      int[] integers = FillArray.fill(
        new int[9], new Rand.Pint());
      System.out.println(Arrays.toString(integers));
    }
  }
  ```
  ```java
  /*输出:
  [btpenpccu, xszgvgmei, nneeloztd, vewcippcy, gpoalkljl]
  [635, 8737, 3941, 4720, 6177, 8479, 6656, 3768, 4948]
  */
  ```
  - 自动装箱机制不会对数组生效，因此我们需要实现FillArray.fill()重载版.或者实现一个生成器，来生成包装后的输出结果

## 实现参数化接口
  一个类无法实现同一个泛型接口的两种变体：由于类型擦除的缘故，这两个变体其实是相同的接口:  
  ```java
  interface Payable<T> {}
  class Employee implements Payable<Employee> {}
  class Hourly extends Employee
  implements Payable<Hourly> {}
  ```
  - 因为类型擦除将Payable<Employee>和Payable<Hourly> 降级为相同的类Payable。所以上述代码意味着你会将同一个接口实现两次.因此Hourly是无法编译的

## 类型转换和警告
  对类型参数使用类型转换或instanceof是没有效果的：  
  ```java
  class FixedSizeStack<T> {
    private final int size;
    private Object[] storage;
    private int index = 0;
    FixedSizeStack(int size) {
      this.size = size;
      storage = new Object[size];
    }
    public void push(T item) {
      if(index < size)
      storage[index++] = item;
    }
    @SuppressWarnings("unchecked")
    public T pop() {
      return index == 0 ? null : (T)storage[--index];
    }
    @SuppressWarnings("unchecked")
    Stream<T> stream() {
      return (Stream<T>)Arrays.stream(storage);
    }
  }
  public class GenericCast {
    static String[] letters =
      "ABCDEFGHIJKLMNOPQRSK.split("");
    public static void main(String[] args) {
      FixedSizeStack<String> strings =
        new FixedSizeStack<>(letters.length);
      Arrays.stream("ABCDEFGHIJKLMNOPQRS".split(""))
        .forEach(strings::push);
      System.out.println(strings.pop())；
      strings.stream()
        .map(s -> s + " ")
        .forEach(System.out::print);
    }
  }
  ```
  ```java
  /*输出：
  S
  A B C D E F G H I J K L M N O P Q R S
  */
  ```
  - 如果没有@SuppressWarnings注解，编译器会在调用pop()和stream()时产生"unchecked cast"的警告
  - 由于类型擦除的缘故，编译器无法知道类型转换是否是安全的。T会被擦除为自身的第一个边界，默认情况下则是Object,因此pop()实际上只是将Object 转换成 Object

  有时使用泛型并不意味着不需要转型，而这会导致编译器产生不正确的警告  
  ```java
  public class NeedCasting {
    @SuppressWarnings ("unchecked")
    public void f(String[] args) throws Exception {
      ObjectInputStream in = new ObjectInputStream(
        new FilelnputStream(args[0])):
      List<Widget> shapes = (List<Widget>)in. readObject();
    }
  }
  ```
  - readObject()无法得知它正在读取的是什么,所以它返回 Object.而我们必须对该Object进行转型

  如果你注释掉@SuppressWarnings注解后再编译该程序.则会产生警告:  
  你会被强制转型，而此时你还并未告知要这么做。要解决这个问题，你需要使用Java 5中引入的转型方式.通过泛型类来转型：  
  ```java
  public class ClassCasting {
    @SuppressWarnings("unchecked")
    public void f(String[] args) throws Exception {
      ObjectInputstream in = new ObjectInputStream(
        new FileInputStream(args[0]));
        //无法翻译：
        // List<Widget> lwl =  
        // List<>.class.cast(in.readObject());
      List<Widget> lw2 = List.class.cast(in.readObject());
    }
  }
  ```
  - 你无法转型为实际的类型（List<Widget>）。也就是说，你无法这么做: List<Widget>.class.cast(in.readObject())
  - 而且即使你像这样再增加一层转型: (List<Widget>)List.class.cast(in.readObject()) 也还是会产生警告

## 重载
  下面这样的代码是无法编译的，即使看上去很合理:  
  ```java
  public class UseList<W, T> {
    void f(List<T> v) {}
    void f(List<W> v) {}
  }
  ```
  由于类型擦除的缘故,重载该方法会产生相同类型的签名  
  
  相反，在被擦除的参数无法生成独有的参数列表的情况下，你需要提供各不相同的方法名:  
  ```
  public class UseList2<W, T> {
    void fl(List<T> v) {}
    void f2(List<W> v) {}
  }
  ```

## 基类会劫持接口
  ```java
  public class ComparablePet
  implements Comparable<ComparablePet> {
    @Override
    public int compareTo(ComparablePet arg) {
      return 0;
    }
  }
  class Cat
  extends ComparablePet implements Comparable<Cat>{
    // error: Comparable cannot be inherited with
    // different arguments: <Cat> and〈ComparablePet

    public int compareTo(Cat arg) { return 0; }
  }
  ```
  - 一旦为Comparable确定了 ComparablePet参数，其他的实现类就再也不能和ComparablePet之外的对象进行比较了

  ```java
  class Hamster extends ComparablePet
  implements Comparable<ComparablePet> {
    @Override
    public int compareTo(ComparablePet arg) {
      return 0;
    }
  }
  // 或者直接这样:
  class Gecko extends ComparablePet {
    public int compareTo(ComparablePet arg) {
      return 0;
    }
  }
  ```
  - 从Hamster能看出，可以重复实现ComparablePet中的相同接口，只要接口是完全相同的即可，包括参数类型

# 自限定类型
  class SelfBounded<T extends SelfBounded<T>> { // ...

## 奇异递归泛型
  奇异递归泛型(curiously recurring generics, CRG )。其中“奇异递归”指的是你的类奇怪地在自身的基类中出现的现象  
  “我要创建一个新类，它继承自将该新类类名作为自身参数的泛型类型”  
  泛型基类在拿到子类类名后，能做些什么呢？  
  Java泛型的重点在于参数和返回类型，因此可以生成将派生类型作为参数和返回值的基类  
  ```java
  public class BasicHolder<T> {
    T element;
    void set(T arg) { element = arg; }
    T get() { return element; }
    void f() {
      System.out.println(
        element.getClass().getSimpleName());
    }
  }

  class Subtype extends BasicHolder<Subtype> {}
  public class CRGWithBasicHolder {
    public static void main(String[] args) {
      Subtype
        st1 = new Subtype(),
        st2 = new Subtype();
      st1.set(st2);
      Subtype st3 = stl.getf);
      st1.f();
  ```
  ```java
  /*
  Subtype
  */
  ```
  - 这便是CRG的精髓了：基类用子类替换了其参数
  - 这意味着泛型基类变成了一种为其子类实现通用功能的模板,但是所实现的功能会将派生类型用于所有的参数和返回值
  - 也就是说,最终类中使用的是具体的类型而不是基类

## 自限定
  BasicHolder可以将任何类型作为其泛型参数:  
  ```java
  class Other {}
  class BasicOther extends BasicHolder<Other> {}

  public class Unconstrained {
    public static void main(String[] args) {
      BasicOther b = new BasicOther();
      BasicOther b2 = new BasicOther();
      b.set(new Other());
      Other other =  b.get();
      b.f();
    }
  }
  ```
  ```java
  /*输出
  Other
  */
  ```

  自限定执行了额外的一步，强制将泛型作为自己的边界参数使用:  
  ```java
  class SelfBounded<T extends SelfBounded<T>> {
    T element;
    SelfBounded<T> set(T arg) {
      element = arg;
      return this;
    }
    T get() { return element; }
  }

  class A extends SelfBounded<A> {}
  class B extends SelfBounded<A> {} // 这杵也可以

  class D {}
  //不能这样做：
  // class E extends SelfBounded<D> {}
  // Compile error:
  // Type parameter D is not within its bound

  //你可以这样做，所以你无法强制使用这种用法:
  class F extends SelfBounded {}

  public class SelfBounding {
    public static void main(String[] args) {
      A a = new A();
      a.set(new A());
      a = a.set(new A()).get();
      a = a.get();
      C c = new C();
      c = c.setAndGet(new C());
    }
  }
  ```
  - 从试图定义E的那一行可以看出，你无法将非SelfBounded的类型作为继承的SelfBounded类的类型参数
  - 遗憾的是，编译器并未对F产生警告.因此自限定的用法并不是强制执行的

  自限定要求类处于继承关系中:  
  `class A extends SelfBounded<A> {}`  
  这会强制要求你必须将你要定义的类作为参数传给基类  

  自限定的限制只服务于强制继承关系。如果你使用自限定，你会知道该类使用的类型参数和使用该参数的类是同一种基类  

  将自限定用于泛型方法:  
  ```java
  public class SelfBoundingMethods {
    static <T extends SelfBounded<T>> T f(T arg) {
      return arg.set(arg).get();
    }
    public static void main(String[] args) {
      A a = f(new A());
    }
  }
  ```
  - 这使得该方法无法应用于除所示形式的自限定参数外的任何对象

## 参数协变性
  自限定类型的价值在于它可以生成协变参数类型(covariant argument type )————方法参数的类型会随着子类而变化  
  Java 5 中引入了协变返回类型(covariant return type )：  
  ```java
  class Base {}
  class Derived extends Base {}

  interface OrdinaryGetter {
    Base get();
  }
  interface DerivedGetter extends OrdinaryGetter {
    //重写方法的返回类型可以变化：
    @Override Derived get();
  }
  ```
  - DerivedGetter中的get()方法重写自OrdinaryGetter中的get()方法，并返回OrdinaryGettei.get()的返回类型的子类
  - 但这在更早的Java版本中是非法的

  自限定泛型实际上会生成精确的派生类型作为返回值，如下面的get()中所示:  
  ```java
  interface GenericGetter<T extends GenericGetter<T>> {
    T get();
  }
  interface Getter extends GenericGetter<Getter> {}
  public class GenericsAndReturnTypes {
    void test(Getter g) {
      Getter result = g.get();
      GenericGetter gg = g.get();         // 也可以是基类
    }
  }
  ```

  在非泛型的代码中，参数的类型无法随子类型变化  

  使用自限定类型的时候,子类中只有一个方法，而该方法将派生类型作为自身参数，而不是基类类型:  
  ```java
  interface SelfBoundSetter<T extends SelfBoundSetter<T>> {
    void set(T arg);
  }
  interface Setter extends SelfBoundSetter<Setter> {}
  public class SelfBoundingAndCovariantArguments {
    void testA(Setter s1, Setter s2, SelfBoundSetter sbs) {
      sl.set(s2);
      //- sl.set(sbs);
      // required: Setter
      // found: SelfBoundSetter
    }
  }
  ```
  - 编译器无法识别出想要将基类类型作为参数传入set()的意图，因为并不存在匹配这种签名的方法
  - 该参数实际上已经被重写了

  如果没有使用自限定，普通的继承机制就会介入，并且会进行重载  

# 动态类型安全
  由于你可以向Java5之前的版本代码传递泛型集合，因此老式的代码仍然有可能破坏你的集合  
  Java 5在java.util.Collections中加入一组实用工具————静态方法：  
  - checkedCollection()
  - checkedList()
  - checkedMap()
  - checkedSet()
  - checkedSortedMap()
  - checkedSortedSet()  
  这些方法都将集合作为第一个参数，以进行动态检查.并将要强制确保的类型作为第二个参数  

  如果试图向checked (经过了检查的)集合插入不匹配的对象，就会抛出ClassCastException异常，而泛型出现之前的(原生)集合则相反，它会在你从中取岀对象时通知你出了问题  
  ```java
  public class CheckedList {
    @SuppressWarnings("unchecked")
    static void oldStyleMethod (List probablyDogs) {
      probablyDogs.add(new Cat());
    }
    public static void main(String[] args) {
      List<Dog> dogsl = new ArrayList<>();
      oldStyleMethod(dogs1);             // 可以安静地传入 Cat
      List<Dog> dogs2 = Collections.checkedList(
        new ArrayList<>(), Dog.class);
      try {
        oldStyleMethod(dogs2);         // 会抛出异常
      } catch(Exception e) {
        System.out.println("Expected: " + e);
      }
      //派生类型可以正常工作：
      List<Pet> pets = Collections.checkedList(
        new ArrayList<>(), Pet.class);
      pets.add(new Dog());
      pets.add(new Cat());
    }
  }
  ```
  ```java
  /*输出:
  Expected: java.lang.ClassCastException: Attempt to
  insert class reflection.pets.Cat element into collection
  with element type class reflection.pets.Dog
  */
  ```
  - dogs2则立刻针对插入不正确类型的行为抛出了异常

# 异常
  由于类型擦除的缘故，catch子句无法捕获到泛型类型的异常，这是因为在编译时和运行时，都必须知晓异常的确切类型才行  
  泛型类无法直接或间接地继承Throwable（这还可以进一步防止你试图定义无法捕获的泛型异常）  

  不过，类型参数可以用于方法声明中的throws子句。这意味着你可以编写能够随受检查的异常类型而变化的泛型代码：  
  ```java
  interface Processor<T, E extends Exception> {
    void process(List<T> resultCollector) throws E;
  }
  class ProcessRunner<T, E extends Exception>
  extends ArrayList<Processor<T, E>> {
    List<T> processAll() throws E {
      List<T> resultcollector = new ArrayList<>();
      for(Processor<T, E> processor : this)
        processor.process(resultCollector);
      return resultCollector;
    }
  }
  class Failure1 extends Exception {}
  class Processor1
  implements Processor<String, Failure1>{
    static int count = 3;
    @Override
    public void process (List<String> resultCollector)
    throws Failurel {
      if(count-- > 1)
        resultCollector.add("Hep!");
      else
        resultCollector.add("Ho!");
      if(count < 0)
        throw new Failure1();
    }
  }
  class Failure2 extends Exception {}
  class Processor2
  implements Processor<Integer, Failure2> {
    static int count = 2;
    @Override
    public void process(List<Integer> resultCollector)
    throws Failure2 {
      if(count-- == 0)
        resultCollector.add(47);
      else {
        resultCollector.add(11);
      }
      if(count < 0)
        throw new Failure2();
    }
  }
  public class ThrowGenericException {
    public static void main(String[] args) {
      ProcessRunner<String, Failure1> runner = 
        new ProcessRunner<>();
      for(int i = 0; i < 3; i++)
        runner.add(new Processor1());
      try {
        System.out.printin(runner.processAll());
      } catch(Failure1 e) {
        System.out.println(e);
      }
      ProcessRunner<Integer, Failure2> runner2 =
        new ProcessRunner<>();
      for(int i = 0; i < 3; i++)
        runner2.add(new Processor2());
      try {
        System.out.println(runner2.processAll());
      } catch(Failure2 e) {
        System.out.println(e);
      }
    }
  }
  ```
  ```java
  /*输出:
  [Hep!, Hep!, Ho!]
  Failure2
  */
  ```
  - 除非可以参数化抛出的异常，否则由于检查型异常，你无法泛化地编写该代码

# 混型
  混型(mixin): 其最基本的概念是混合多个类的能力，以生成一个可以代表混型中所有类型的类  
  混型的价值之一是，可以将多种特性和行为一致地应用于多个类之上  
  它们还有额外的好处，如果你对某个混型类做了变更，该变更会应用于所有使用了该混型的类中  
  混型有一些面向切面编程(aspect-oriented programming )的味道，而切面则常常被推荐用于解决混型问题  

## C++中的混型
  C++可以这样简单的创建混型：  
  ```java
  int main() {
    TimeStamped<Serial.Numbered<Basic» mixin1, mixin2;
    mixin1.set("test string 1");
    mixin2.set("test string 2");
    cout << mixin1.get() << " " << mixin1.getStamp() <<
    " " << mixin1.getSerialNumber() << endl;
    cout << mixin2.get() << " " << mixin2.getStamp() <<
    " " << mixin2.getSerialNumber() << endl;
  }
  ```
  可以将混型想象为一种将已有的类映射到新的子类上的功能  

  Java泛型不允许这样。类型擦除丢弃了基类的类型。因此:  
  泛型类无法直接继承自泛型参数  


## 与接口混合
  ```java
  interface TimeStamped { long getStamp(); }
  class TimeStampedImp implements TimeStamped {
    private final long timeStamp;
    TimeStampedlmp() {
    timeStamp = new Date().getTime();
    }
    @Override
    public long getStamp() { return timeStamp; }
  }
  interface SerialNumbered { long getSerialNumber(); }
  class SerialNumberedImp implements SerialNumbered {
    private static long counter = 1;
    private final long serialNumber = counter++;
    @0verride
    public long getSerialNumber() { return serialNumber; }
  }
  interface Basic {
    void set(String val);
    String get();
  }
  class Basiclmp implements Basic {
    private String value;
    @Override
    public void set(String val) ( value = val; }
    @Override
    public String get() { return value; }
  }
  class Mixin extends Basiclmp
  implements TimeStamped, SerialNumbered {
    private TimeStamped timeStamp = new TimeStampedImp();
    private SerialNumbered serialNumber =
      new SerialNumberedImp();
    @Override public long getStamp() (
      return timestamp.getStamp():
    }
    @Override public long getSerialNumber() {
      return serialNumber.getSerialNumber();
    }
  }
  public class Mixins {
    public static void main(String[] args) {
      Mixin mixin1 = new Mixin(), mixin2 = new Mixin();
      mixin1.set("test string 1")；
      mixin2.set("test string 2");
      System.out.println(mixin1. get() + " " +
        mixin1.getStamp() + " " +
        mixin1.getSerialNumber());
      System.out.println(mixin2.get() + " " +
      mixin2.getStamp() + " " +
      mixin2.getSerialNumber());
    }
  }
  ```
  ```java
  /*输出:
  test string 1 1611503367257 1
  test string 2 1611503367258 2
  */
  ```
  - Mixin类基本上是使用了代理模式,因此每个被混入的类型都需要在Mixin中有一个字段，而你必须在Mixin中编写所有必要的方法来将调用转发到合适的对象上

## 使用装饰器模式
  装饰器是通过组合和规范的结构(可装饰物+装饰器的层次結构)实现的，而混型是基于继承的  
  可以将基于参数化类型的混型想象成一种泛型装饰器的机制.这种机制不要求具有装饰器设计模式的继承结构
  
  ```java
  class Basic {
    private String value;
    public void set(String val) { value = val; }
    public String get() { return value; }
  }
  class Decorator extends Basic {
    protected Basic basic;
    Decorator(Basic basic) { this.basic = basic; }
    @Override
    public void set(String val) { basic.set(val); }
    @Override
    public String get() ( return basic.get(); }
  }
  class TimeStamped extends Decorator {
    private final long timestamp;
    TimeStamped(Basic basic) {
      super(basic);
      timestamp = new Date().getTime();
    }
    public long getStamp() { return timeStamp; }
  }
  class SerialNumbered extends Decorator {
    private static long counter = 1;
    private final long serialNumber = counter++;
    SerialNumbered(Basic basic) { super(basic); }
    public long getSerialNumber() { return serialNumber; }
  }
  public class Decoration {
    public static void main(String[] args) {
      TimeStamped t = new TimeStamped(new Basic());
      TimeStamped t2 = new TimeStamped(
        new SerialNumbered(new Basic()));
      //- t2.getSerialNumber();           // 不可用
      SerialNumbered s = new SerialNumbered(new Basic());
      SerialNumbered s2 = new SerialNumbered(
        new TimeStamped(new Basic()));
      //- s2.getStamp();                 // 不可用
    }
  }
  ```
  - 使用适配器产生的对象类型是该对象最后一层被装饰的类型
  - 也就是说，虽然可以添加不止一层，但是最后一层才是实际的类型，因此只有最后一层的方法是可见的
  - 装饰器的一个显著缺点是它只能有效应用于一层装饰（也就是最后那层）之上

## 与动态代理混合
  可以用动态代理来创建一种比装饰器更接近于现代混型的机制  
  如果使用了动态代理.结果类的动态类型就是被混合后的合并类型  
  ```java
  class MixinProxy implements InvocationHandler {
    Map<String, Object> delegatesByMethod;

    @SuppressWarnings("unchecked")
    MixinProxy(Tuple2<Object, Class<?>>... pairs) {
      delegatesByMethod = new HashMap<>();
      for(Tuple2<Object, Class<?>> pair : pairs) {
        for(Method method : pair.a2.getMethods ()) {
            String methodName = method.getName();
          // map中的第一个接口实现了该方法
          if(!delegatesByMethod.containsKey(methodName))
            delegatesByMethod.put(methodName, pair.a1);
        }
      }
    }
    @Override
    public Object invoke(Object proxy, Method method,
      Object[] args) throws Throwable {
      String methodName = method.getName();
      Object delegate = delegatesByMethod.get(methodName);
      return method.invoke(delegate, args);
    }

    @SuppressWarnings ("unchecked")
    public static Object newInstance(Tuple2... pairs) {
      Class[] interfaces = new Class[  pairs.length];
      for(int i = 0; i < pairs.length; i++) {
        interfaces[i] = (Class)pairs[i].a2;
      }
      ClassLoader c1 =
        pairs[0].al.getClass().getClassLoader();
      return Proxy.newProxyInstance(
        cl, interfaces, new MixinProxy(pairs));
    }
  }

  public class DynamicProxyMixin {
    public static void main(String[] args) {
      @SuppressWarnings("unchecked")
      Object mixin = MixinProxy.newInstance(
        tuple(new BasicImp(), Basic.class),
        tuple(new TimeStampedImp(), TimeStamped.class),
        tuple(new SerialNumberedImp(),
          SerialNumbered.class));
      Basic b = (Basic)mixin;
      TimeStamped t = (TimeStamped)mixin;
      SerialNumbered s = (SerialNumbered)mixin;
      b.set("Hello");
      System.out.printin(b.get());
      System.out.println(t.getStamp());
      System.out.println(s.getSerialNumber());
    }
  }
  ```
  ```java
  /*输出：
  Hello
  1611503350927
  1
  */
  ```
  - 因为只有动态类型包含了所有的混入类型，而静态类型并没有，所以这种方式仍然不如C++的优秀，因为在调用方法之前，要强制向下转型为合适的类型

# 潜在类型机制
  类型擦除会强制在代码中指定泛型类型的边界，以安全地调用泛型对象上的具体方法  
  这是对“泛型”概念的一个很大的限制，因为你必须约束你的泛型类型，这样它们才能继承特定的类或实现特定的接口。  
  在某些情况下，你可能最终会改用普通的类或接口.因为带边界的泛型可能和指定某个类或接口没有区别  

  潜在类型机制（latent typing），也叫结构化类型机制（structural typing）、鸭子类型机制（duck typing）  
  展幵来说就是“如果某个事物走路像鸭 ,说话也像鸭子.那么你就可以把它也当成鸭子”  

  具有潜在类型机制的语言可以仅通过实现一套方法的子集，而不用实现某个特定的类或接口.来解除这个限制（从而使代码更通用）  
  潜在类型机制可以越过类的层次结构，调用并不属于某个公共接口的方法  

  潜在类型机制是一套关于代码组织和复用的机制。利用它.你可以编写比之前更容易复用的代码  

  支持潜在类型机制的语言有Python、C++、Ruby、SmallTalk以及Go, Python是一种动态类型语言（实际上所有的类型检查都发生在运行时），而C++和Go是静态类型语言（类型检查发生在编译时）。因此类型检查究竟是静态的还是动态的，在类型机制对此并没有要求  

## Python中的潜在类型机制
  ```python
  class Dog：
    def speak(self):
      print("Arf!")
    def sit(self):
      print("Sitting")
    def reproduce(self):
      pass

  class Robot:
    def speak(self):
      print("Click!")
    def sit(self):
      print("Clank!")
    def oilChange(self):
      pass

  def perform(anything):
    anything.speak()
    anything.sit()

  a = Dog()
  b = Robot()
  perform(a)
  perform(b)

  output = """
  Arf!
  Sitting
  Click!
  Clank!
  """
  ```
  - Python通过代码缩进来控制语句作用域(所以不需要大括号)，并用冒号来幵始一段新的作用域
  - #表该行是一段注释，就像Java中的//。类中的方法将相当于this的引用显式地指定为第一个参数，一般习惯命名为self
  - 调用构造器不需要任何类型的new关键字，而旦Python允许常规函数(非成员函数，即定义在类之外的独立函数)
  - output的赋值语句使用了三重引号来创建内嵌换行的字符串

## C++中的潜在类型机制
  ```java
  class Dog {
  public:
    void speak() ( cout << "Arf!" << endl; }
    void sit() { cout << "Sitting!" << endl; }
    void reproduce() {}
  };

  class Robot {
  public:
    void speak() { cout << "Click!" << endl; }
    void sit() { cout << "Clank!" << endl; }
    void oilChange() {}
  };

  template<class T> void perform(T anything) {
    anything.speak();
    anything.sit();
  }

  int main() {
    Dog d;
    Robot r;
    perform(d);
    perform(r);
  }
  ```
  ```c++
  /*输出
  Arf!
  Sitting!
  Click!
  Clank!
  */
  ```
  在Python和C++中，Dog和Robot没有任何共同之处一它们只是恰巧有两个结构完全相同的方法  
  从类型的角度看，它们是两个完全不同的类型。但是，perform()并不关心其参数的具体类型，潜在类型机制使它可以同时接受这两个类型的对象  
  虽然C++和Python检查并抛出错误的时机不同————前者在编译时，后者在运行时。但是这两种语言都保证了类型不会错用.因此也都可以被认为是强类型的语言。潜在类型机制并不会违背强类型机制  

## Go中的潜在类型机制
  ```go
  import "fmt"

  type Dog struct {}
  func (this Dog) speak() { fmt.Printf("Arf!\n")}
  func (this Dog) sit() ( fmt.Printf("Sitting!\n")}
  func (this Dog) reproduce() {}

  type Robot struct {}
  func (this Robot) speak() { fmt.Printf("Click!\n") }
  func (this Robot) sit() { fmt.Printf("Clank!\n") }
  func (this Robot) oilChange() {}

  func perform(speaker interface ( speak(); sit() }) {
    speaker.speak();
    speaker.sit();
  }

  func main() {
    perform(Dog{))
    perform(Robot{))
  }
  ```
  ```go
  /*输出
  Arf!
  Sitting!
  Click!
  Clank!
  */
  ```
  - 每个方法都由func关键字开头，然后再把方法附着到类上————用圆括号将对象引用包起来，对象引用可以是任何标识符，但这里用了 this,以提醒你这就像C++或Java中的this一样
  - 这里在行内匿名地创建了 interface,正如你在perform()的参数列表中所见
  - 语法Dog{}和Robot{}创建了匿名的Dog和Robot的struct

## Java中的直接潜在类型机制
  相较于支持潜在类型机制的语言，Java的泛型机制起初看来“不够泛型”（Java用类型擦除实现的泛型有时称为第二类泛型类型）  

# 对于缺少（直接的）潜在类型机制的补偿
  虽然Java没有直接支持潜在类型机制，但这并不意味着泛型代码就无法跨类型层次应用。你可以创建出真正意义上的泛型代码，但是需要花些额外的功夫

## 反射
  是实现了潜在类型机制的反射perform():  
  ```java
  class Mime {
    public void walkAgainstTheWind() {}
    public void sit() {
      System.out.println("Pretending to sit");
    }
    public void pushlnvisibleWalls() {}
    @Override public String toString() { return "Mime"; }
  }
  //并未实现Performs接口：
  class SmartDog {
    public void speak() { System.out.println("Woof!"); )
    public void sit() { System.out.println("Sitting"); }
    public void reproduce() {}
  }
  class CommunicateReflectively {
    public static void perform (Object speaker) {
      Class<?> spkr = speaker.getClass();
      try {
        try {
          Method speak = spkr.getMethod("speak");
          speak.invoke(speaker);
        } catch(NoSuchMethodException e) (
          System.out.println(speaker + " cannot speak");  
        }
        try {
          Method sit = spkr.getMethod("sit");
          sit.invoke(speaker);
        } catch(NoSuchMethodException e) {
          System.out.println(speaker + " cannot sit");
        )
      } catch(SecurityException |
                  IllegalAccessException |
                  IllegalArgumentException |
                  InvocationTargetException e) {
        throw new RuntimeException(speaker.toString(), e);
      }
    }
  }
  public class LatentReflection {
    public static void main(String[] args) {
      CommunicateReflectively.perform(new SmartDog());
      CommunicateReftectively.perform(new Robot());
      CommunicateReflectively.perform(new Mime());
    }
  }
  ```
  ```java
  /*输出：
  Woof!
  Sitting
  Click!
  Clank!
  Mime cannot speak
  Pretending to sit
  */
  ```
  - 这两个类之间并无直接 联.也没有共同的基类(除了 Object)或接口
  - 通过反射，CommunicateReflectively.perform()可以动态地确定所需的方法是否可用.然后进行调用

## 将方法应用于序列
  是可以同时拥有编译时类型检查以及潜在类型机制吗？  
  ```java
  public class Apply {
    public static <T, S extends Iterable<T>>
    void apply(S seq, Method f, Object... args) {
      try {
        for(T t: seq)
          f.invoke(t, args);
      } catch(IllegalAccessException |
            IllegalArgumentException |
            InvocationTargetException e) {
      //失败是由程序员造成的错误
        throw new RuntimeException(e);
      }
    }
  }
  ```
  - invoke()有着可以接收任何数量的参数的优点，因此apply()也同样具有此优点。在某些情况下，这样的灵活性可能非常重要

  尽管反射的方式看起来很优雅，我们必须注意到，反射的运行速度通常会慢于非反射的实现，因为在运行时需要处理的东西太多了  
  大部分时候你应该首要考虑使用Java 8的函数式方式，只在某些仅有反射可以处理的特殊需求场景下，才考虑使用反射  
  ```java
  public class ApplyFunctional {
    public static void main(String[] args) {
      Stream.of(
        Stream.generate(Shape::new) .limit(2),
        Stream.generate(Square::new).limit(2))
        .flatMap(c -> c)           //扁平化到一条流
        .peek(Shape::rotate)
        .forEach(s -> s.resize(7));

      new FilledList<>(Shape::new, 2)
        .forEach(Shape::rotate);
      new FifledList<>(Square::new, 2)
        .forEach(Shape::rotate);

      SimpleQueue<Shape> shapeQ = Suppliers.fill(
        new SimpleQueue<>(), SimpleQueue::add,
        Shape::new, 2);
      Suppliers.fill(shapeQ, SimpleQueue::add,
        Square::new, 2);
      shapeQ.forEach(Shape::rotate);
    }
  }
  ```
  - 有了 Java 8,就不再需要 Apply.apply()了
  - 两个流(Stream)————一个Shape流，一个Square流————然后将它们扁平化(flatten)到一个流中
  - 尽管Java缺少函数式语言中常见的flatten(),但还是可以用flatMap(c -> c)起到同样的作用，这种方式通过标识映射,将操作简化为“扁平化”
  - 用peek()封装了rotate()调用，因为peek()可以先执行某些操作(这里是为了它的副作用),然后保持对象的原样継续向下传递

# Java 8中的辅助潜在类型机制
  Java 8中的未绑定方法引用使得我们可以实现某种形式的潜在类型机制.以满足创建跨不相关类型工作的单个代码段的需求  
  ```java
  class PerformingDogA extends Dog {
    public void speak() { System.out.println("Woof!"); }
    public void sit() { System.out.println("Sitting"); }
    public void reproduce() {}
  }
  class RobotA {
    public void speak() { System.out.println("Click!"); )
    public void sit() { System.out.println("Clank!"); )
    public void oilChange() {}
  }
  class CommunicateA {
    public static <P> void perform(P performer,
      Consumer<P> action1, Consumer<P> action?) {
      actionl.accept(performer);
      action2.accept(performer);
    }
  }
  public class DogsAndRobotMethodReferences {
    public static void main(String[] args) {
      CommunicateA.perform(new PerformingDogA(),
        PerformingDogA::speak, PerformingDogA::sit);
      CommunicateA.perform(new RobotA(),
        RobotA::speak, RobotA::sit);
      CommunicateA.perform(new Mime(),
        Mime::walkAgainstTheWind,
        Mime::pushInvisibleWalls);
    }
  }
  ```
  ```java
  /*输出：
  Woof!
  Sitting
  Click!
  Clank!
  */
  ```
  - CommunicateA.perform()在无限制的P上被泛型化。它可以是任何类型，只要有供其可用的Consumer<P>即可————此处，那些Consumer<P>表示不带参数的P的方法的未绑定方法引用
  - 在调用Consumer的accept()方法时，会将该方法的引用绑定到具体的执行对象，再调用该方法

  称它为“辅助”的原因是你必须显式地为perform()提供要使用的方法引用，它无法仅靠方法名来调用方法  

  虽然传递未绑定方法引用可能看起来像是做了很多额外的工作，但实现潜在类型机制的最终目标还是达到了  
  创建了单个代码段CommunicateA.perform(),可以用于任何签名兼容的方法引用的类型  
  和我们见过的其他语言中的潜在类型机制不同，因为这些语言不仅要求签名一致，还要求方法名也一致。因此，这种方法甚至可以说是产生了更为通用的代码  

## 使用Supplier的泛型方法
  ```java
  public class Suppliers {
    //创建并填充一个集合：
    public static <T, C extends Collection<T>>   C
    create(Supplier<C> factory, Supplier<T> gen, int n) {
      return Stream.generate(gen)
        .limit(n)
        .collect(factory, C::add, C::addAll);
    }
    //填充已有集合：
    public static <T, C extends Collection<T>>
    C fill(C coll, Supplier<T> gen, int n) {
      Stream.generate(gen)
        .limit(n)
        .forEach(coll::add);
      return coll;
    }
    //使用未绑定的方法引用生成更为通用的方法：
    public static <H, A> H fill(H holder,
      BiConsumer<H, A> adder, Supplier<A> gen, int n) {
      Stream.generate(gen)
        .limit(n)
        .forEach(a -> adder, accept(holder, a));
      return holder;
    }
  }
  ```
  - create()可以为你生成新的集合子类
  - 第一个版本的fill()会向已有的集合子类放入元素
  - 前两个方法一般仅限用于集合的子类。第二个版本的fill()可用于任意类型的holder
  - 未绑定的方法引用adder通过辅助潜在类型机制，fill()可用于任意类型的holder,只要该holder内含有用于添加元素的方法
  - 由于该未绑定方法adder必须接收一个参数（要添加到holder中的元素），adder必须是一个BiConsumer<H, A>
  - H是要绑定的目标holder对象的类型，而A则是要添加的元素类型
  - 对accept()的调用会以a为参数，在对象holder上调用未绑定方法adder

  ```java
  class Customer {
    private static long counter = 1;
    private final long id = counter++;
    @Override public String toString() {
      return "Customer " + id;
    }
  }
  class Teller {
    private static long counter = 1;
    private final long id = counter++;
    @Override public String toString() {
      return "Teller " + id;
    }
  }
  class Bank {
    private List<BankTeller> tellers = 
      new ArrayList<>();
    public void put(BankTeller bt) {
      tellers.add(bt);
    }
  }
  public class BankTeller {
    public static void serve(Telter t, Customer c) {
      System.out.println(t + " serves " + c);
    }
    public static void main(String[] args) {
      // 演示 create()：
      RandomList<TeHer> tellers =
        Suppliers.create(
          RandomList::new, Teller::new, 4);
      // 演示 fill()：
      List<Customer> customers = Suppliers.fill(
        new ArrayList<>(), Customer::new, 12);
      customers.forEach(c ->
        serve(tellers.select(), c));
      //演示辅助类型机制：
      Bank bank = Suppliers.fill(
        new Bank(), Bank::put, BankTeller::new, 3);
      //也可以使用第二个版本的fill()：
      List<Customer> customers2 = Suppliers.fill(
        new ArrayList<>(),
        List::add, Customer::new, 12);
    }
  }
  ```
  ```java
  /*输出：
  Teller 3 serves Customer 1
  Teller 2 serves Customer 2
  Teller 3 serves Customer 3
  Teller 1 serves Customer 4
  Teller 1 serves Customer 5
  Teller 3 serves Customer 6
  Teller 1 serves Customer 7
  Teller 2 serves Customer 8
  Teller 3 serves Customer 9
  Teller 3 serves Customer 10
  Teller 2 serves Customer 11
  Teller 4 serves Customer 12
  */
  ```
  - create()生成了一个新的集合对象，同时则向已有堤合添加元素
  - 第二个版本的fill()不仅可以用于无关联的新Bank类型，而且还可以用于List
  
# 总结：转型真的这么糟糕吗?
  最没有争议的泛型类型机制的适用场景之一.就是用于诸如List、Set、Map等集合类 
  在Java 5之前，你要向集合中放入一个对象时，该对象会被向上转型为Object,因此丢失了类型信息。取出时需要向下转型，若不匹配则在运行时抛出异常  
  
  有人争辩：  
  如果程序中的某个部分（或某些部分）向集合插入对象，而你只能在程序的某个不相关的地方通过异常发现集合中被放入了一个错误的对象，然后你必须去找到这个错误是在哪里发生的。  

  实际上问题又能隐藏多久呢？似乎你一旦幵始用真实数据测试代码，就能很快发现异常  

  我相信这个以通用性为目标的、被称为“泛型”的语言特性，其目的是为了实现更强大的表达能力，而不仅仅是为了创建类型安全的集合。类型安全的集合只是更通用的代码创建能力的副产品  

  泛型正如它的名字所示,是一种编写更“泛型”（ 和“通用”是同一个英文词,generic）的代码的方法，使得代码可以更少受到适用类型的限制，因此一段代码可以应用于更多的类型  
  编写真正泛型的holder类（Java泛型便是）是相当简单的  
  编写操作泛型参数的泛型代码，不论是类的创建者还是使用者，都需要付出额外的努力，两者都需要理解这种代码的概念和具体实现  
  这些额外的努力降低了该特性的易用性，并因此减少了它在某些本可以带来更多价值的场合下的适用性  

  泛型是用逆向工程的方式引入Java的，而不是在一开始就设计好的特性，因此某些集合无法像它们本应做到的那样稳健  
  举例来说，看看Map,特别是containsKey(Object key)和get(Object key)方法。如果这些类是基于预先存在的泛型设计的，那么它们将使用参数化类型，而不是Object,这样就可以提供泛型本应提供的编译时检查能力了    

  在Java中，泛型是在这门语言发布了几乎10年后才引人的  
  
