# package:包（库/库单元/命名空间）：避免不同库相同类名造成的冲突
  使用import关键字导入包  
  ```mermaid
  graph TD;
  命名空间 --> 多个.Java源文件-编译单元;
  多个.Java源文件-编译单元 --> 1个与源文件同名的public类;
  多个.Java源文件-编译单元 --> 任意个非public类;

  JAR-Java档案文件 --> .class输出文件-JVM元空间;
  .class输出文件-JVM元空间 --> 1个与源文件同名的public类;
  .class输出文件-JVM元空间 --> 任意个非public类;
  ```
  访问性从大到小：  
  1. public
  2. protected
  3. 包内访问：没有关键字（默认）
  4. private

  `package package_name;`  必须出现在".Java"文件的第一个非注释处（开头），将".Java"文件加入package  
  一个包并不会真正被“打包”到一个文件中，多个".Java"文件显得混乱，所以设置默认将一个包下的".class"文件放入一个目录中。（设置CLASSPATH路径到存放目录）  

## 使用import改变行为
  通过更改导入的package，将代码从调试版本更改为生产版本  

# Java访问权限修饰符
  - public
  - protected
  - 包内访问，无关键字
  - private

  修饰成员：  
  - 类
  - 字段
  - 方法

  PS：protected和private不能修饰类

## 包访问：成员前不使用3个修饰符，则默认为包访问
  一个包中的所有类均可以访问包访问权限修饰的成员。  
  若一个类不在包中，其包访问权限修饰的成员可以被同一个目录中的所有其他类使用。  
  该成员相当于放入了隐含的“默认包”  

## public：接口访问权限
  public修饰的成员对所有类均可使用  
  但public修饰的类的成员要根据各自的修饰符来控制访问  
  例：  
  ```java
  public class Cookie {
    public cookie(){...}         //cookie()可被所有类使用
    void bite(){...}             //bite()只能被同一包中的类使用
  }
  ```

## private
  除了所在类和所在方法允许访问，其他类不得访问  

## protected：继承访问权限
  继承：基类 <—— 子类  
  例：class B extends A  
  protected可以让子类在任何位置访问protected修饰的成员。  
  同时提供包访问权限，同一个包内的类可以访问被修饰成员。  

## 包访问权限类和public构造器
  ```java
  class A{                 //此种定义实质上是错误的
    public A(){}           //因为包外的类无法访问A，也就无法访问A()

  }
  ```

# 接口和实现
  访问控制被称为实现隐藏。  
  封装：数据和方法包装在类中，并与访问控制结合。  

  1. 确定客户程序员可以/不可以使用的内容
  2. 将接口和实现分离，自由更改非public代码，不破坏客户端代码

  推荐创建类的风格：先public，然后protected、包访问权限、private  
  例：  
  ```java
  public class A{
    public void a(){...}
    private void b(){...}
    private int i;
  }
  ```

# 类的访问权限
  - public：允许客户程序员访问该类
  - 包访问权限：只用来处理任务，不与客户程序员直接交互，同时允许任意修改代码。

  每个编译单元（文件）只能有一个public类，代表公共接口，每个文件可有任意个包访问权限的类。  
  public的类名要与编译单元的文件名完全相同。没有public类的文件名可任意取，但不建议乱取名。  
  
  类不可用protected/private修饰，会导致其他所有类均无法访问（报错）。  

## 将所有构造器设为private，防止任意创建该类的对象，可在类的static方法中创建对象
  例1：  
  ```java
  class Soup1{
    private Soup1()  {}
    public static Soup1 makeSoup(){
      return new Soup1();               //生成Soup1的新对象并返回引用
    }                                   //可在返回对象前进行额外操作，例如计数/日志
  }
  ```
  例2：  
  ```java
  class Soup2{
    private Soup2()  {}
    private static Soup2 ps1 = new Soup2();    //作为静态成员被创建，有且仅有一个（类成员）
    public static Soup2 access(){
      return ps1;                              //单例模式：返回唯一对象的引用，只能通过static方法获取
    }
  }
  ```

# 模块
  - 解决了组件的依赖问题            //Java没有支持告诉编译器组件的依赖，导致每次都使用整个Java库
  - 解决了隐藏和不可用组件问题      //但是客户程序员仍然可使用反射避开访问控制来访问隐藏组件
    
  模块允许客户程序员使用组件时仅使用组件的模块和依赖，不含其他模块。  
  继续使用隐藏组件，你必须开启“逃生舱口（escape hatch）”，明白Java不对使用不可用组件负责。  

  可以将模块系统用于自己的系统，但除了大型第三方库项目，使用模块系统的收益会很低。
