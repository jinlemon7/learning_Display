Java使用异常提供了一个一致的错误报告模型，从而使组件可以将问题可靠地传递给客户代码。  
异常处理是Java报告错误的唯一正式的方式，由Java编译器强制实施。  

# 概念
  c语言和其他早期语言的错误处理机制都是通过“约定”建立而非编程语言的一部分。  
  通常返回一个特殊值或设置一个标志，需要程序员在程序的多个地方进行检查与处理。  

  异常（exception）可以确保有异常处理机制自动捕捉它，程序员只在异常处理程序（exception handler）中处理问题。  
  这将节省代码，并且分离开正常执行代码和出现问题时执行代码。  

# 基本的异常
  异常情形（exception condition）：阻止当前方法或作用域继续执行的问题。  
  
  抛出异常流程：  
  1. 异常对象创建，使用new，放在堆上                          //例：new NullPointerException()
  2. 当前执行路径停止，指向这个对象的引用被从当前上下文推出来
  3. 异常处理机制接管控制，寻找“异常处理程序”。
  4. 在更大的上下文中，“异常处理程序”从问题中恢复，程序尝试另一条路径或继续进行。

## 异常参数
  标准异常处理程序都有两个构造器
  1. 无参构造器
  2. 有参构造器，嗯接受一个String参数，在异常类中放置相关信息
  ```java
  if(t == null)
    throw new NullPointerException("t = null");
  ```
  可抛出任何Throwable, 是异常类型的根类。通常为每种不同类型错误抛出不同异常类。  
  错误信息既包含在异常对象中，又隐含在异常类的名字中。             //通常情况下异常对象仅有的信息就是异常类型的名字  

# 捕捉异常
  被守护区域（guarded region）：一段可能产生异常的代码，后面跟着处理这些异常的代码。  

## try块
  一个方法中抛出异常，该方法将在抛出异常的过程中退出。  
  如果不希望退出，在其中设置一个特殊的块来捕捉异常。  
  try块：这里“尝试”各种方法调用

  ```java
  try{           //可能产生异常代码
    ...
  }
  ```

  类似C这样不支持异常处理的语言往，往需要临时机制，在每个函数调用后直接放置错误测试代码，并立即检查结果。  
  try块将所有方法调用放在一起，并在try块里捕获所有异常。  

  优点：代码更容易编写和阅读，正常执行代码不会被错误检查所混淆。  

## 异常处理程序
  被抛出的异常总是要在某个地方结束，这个“地方”即异常处理程序。  
  可为每个异常类型编写一个，紧跟在try块后面用关键字catch表示  

  ```java
  try{
    ...
  }catch(Type1 : d1){             //仅接受一个特定类型的参数
    ...
  }catch(Type2 : d2){
    ...
  }
  ```

  异常被抛出，异常处理机制会查找参数与异常类型相匹配的第一个处理程序，catch子句完成对处理程序的搜索就会停止。  

  - 终止模型
  - 恢复模型


# 创建自己的异常
  不必拘泥于Java已有的异常，我们可以创建自己的异常。  
  创建自己的异常类，最好继承与我们要定义的新异常含义接近的异常（通常不可能）  

  例1：让编译器创建无参构造器     //并且自动隐式调用基类的无参构造器
      `class SimpleException extends Exception{}`  
      
  例2：使异常类接受一个String参数的构造器
  ```java
  class MyException extends Exception{
    MyException(){}
    MyException(String msg){super(mag);}    // super显式调用基类的带String参数的构造器
  }
  ```

  错误信息可通过：  
  1. System.err  (更好的选择)      ————发送到标准错误流
  2. System.out  (可能会被重定向)  ————发送到标准输出流

  Exception类继承Throwable而来，Throwable的printStcakTrance()会打印到达异常发生点的方法调用引用序列。  
  此时构造器的string参数也会打印而清风。  
  进一步在自己的异常类中重写Throwable.getMessage()方法，制作String参数的保存模版    //getMessage()类似异常类的toString()  

## 异常与日志记录
  ```java
  import Java.util.logging.*;
  import Java.io.*;
  
  class LoggingException entends Exception{        //新建自己的异常类
    private static Logger logger = Logger.getLogger("LoggingException");    //Logger会将其输出发送到System.err
    LoggingException(){
      StringWritter trace = new StringWritter();
      printStackTrace(new PrintWriter(trace));    //使用重载的printStackTrace(),传入PrintWriter，可把输出提取成一个String
      logger.severe(trace.toString());              //severe()生成用于日志记录消息的String
    }                                             //消息格式：severe:(ExceptionName)
  }                                               //at
                                                  //(Location)
  ```                                             

  捕捉别人的异常,将其记录到日志中,需要在异常处理程序中生成日志信息  
  在自己的类中，新建一个日志生成方法（介绍一个异常作为参数）
  ```java
  static void logException(Exception e){
    String trace = new StringWriter();
    e.printStackTrace(new PrintWriter(trace));
    logger.severe(trace.toString());
  }
  ```

# 异常说明
  Java需礼貌地告知客户程序员这个方法会抛出的异常以方便客户程序员处理他们。  
  这就是异常说明（exception specification），是方法声明的组成部分，出现在参数列表之后。  
  
  `void f() throws TooBig, TooSmall, DivZero{...}`    //throw关键字  
  如果无throws，则意味该方法不会抛出异常（Runtime Exception除外，这是可以在任何地方抛出而不需要说明的异常）  
  这种在编译时被检查并强制实施的异常叫检查型异常（checked exception）：基于泛型，与“向下转型”检查一样属于RuntimeException  

# 捕捉任何异常
  通过捕捉的异常类型的基类 —— Exception，可以创建一个能捕捉任何类型异常的处理程序。  
  Exception不会告诉我们很多具体信息，需调用Exception基类Throwable的方法  
  - String getMessage()                            获取详细信息
  - String getLocalMessage()                       针对特定区域设置调整过的信息
  - String toString()                              返回Throwable的简短描述,使用println(e)调用
  - void printStackTrace()                         调用栈轨迹,打印到标准错误流
  - void printStackTrace(PrintStream)              调用栈轨迹,打印到PrintStram
  - void printStackTrace(java.io.PrintWriter)      调用栈轨迹,打印到PrintWriter

  Throwable fillInStackTrace()  返回记录栈帧当前状态信息的Throwable对象，在重新抛出错误/异常时很有用。
  PS：二次抛出异常位置的栈轨迹，覆盖到异常对象，返回一个throwable对象  

  Throwable的基类Object有一些方法：  
  - getClass()          返回表示这个对象的类的class对象
  - getName()           返回包路径+类名
  - getSimpleName()     返回类名

## 多重捕捉
  Java7之前，必须为每一个异常写一个catch子句，Java7的多重捕捉（multi-catch）处理程序允许在一个catch子句中用'|'操作符  
  把不同类型以异常连接起来。  
  ```java
  void x() throws Except1, Except2, Except3 {}
  void f() {
    try{
      x();
    }catch(Except1 | Except2 | Except3 e){    //多个类型并列，同时2个异常生效，后一个覆盖前一个，造成异常丢失
      ...
    }
  }
  ```

## 栈轨迹
  getStackTrace()可以访问printStackTrace()提供的信息，返回一个由栈轨迹元素组成的数组  
  外层调用在数组末尾位置，内层调用在数组首部位置  

  ```java
  try{
    throw new Exception();
  }catch(Exception e){
    for(StackTraceElement ste: e.getStackTrace() )
      System.out.println(ste.getMethodName() );      //直接打印ste会得到更多信息
  }
  ```

## 重新抛出异常（覆盖抛出）
  有时需要重新抛出异常，有了指向当前异常的引用（在catch子句中），所以可重新抛出  
  重新抛出异常，关于这个异常的所有信息（栈轨迹）都会保留，交给上一层作用域的异常处理程序  
  上一层作用域的异常处理程序：在这里printStackTrace栈轨迹定位从最初异常抛出位置开始。  

  如果想以重新抛出异常的位置建立异常信息，调用e.fillInSatckTrace()，将当前栈信息覆盖到原来的异常对象中，返回一个Throwable对象  

  重新抛出一个与已所捕获异常类型不同的异常，栈轨迹从重新抛出位置开始，作用与e.fillInStackTrace()类似  
  ```java
  try{
    ...
  }catch(Excepton e){
    throw (NewException)e.fillInStackTrace();
  }
  ```

## 异常链（异常链抛出）
  捕捉一个异常并抛出另一个，但仍然保留原始异常信息。  
  Throwable子类都可以选择在构造器中接受一个Cause对象(Throwable(String message, Throwable cause) )  
  Cause作为原始异常，将它传进构造器，维护追溯到源头的栈轨迹。  
  - Error(JVM用来报告系统错误)、Exception、RuntimeException提供代Cause参数的构造器
  - 其他子类使用initCause(cause)方法

  ```java
  if(value == null){
    DynamicFieldException dfe = new DynamicFieldException();
    dfe.initCause(new NullPointerException);    //插入NullPointerException到DynamicFieldException
    throw dfe;                                  //使用printStackTrace()会打印DynamicFieldException的栈轨迹
  }                                             //再打印"Cause by"-NullPointerException的栈轨迹
  ```

  ```java
  try{
    result = getField(id);
  }catch(NoSuchFieldException e){
    throw new RumtimeException(e);    //直接使用接受Cause参数的构造器，，无需使用initCause()方法
  }
  ```

# 标准Java异常
  Throwable:  
  - Error  代表编译时错误和系统错误，一般不关心其捕获（极个别情况除外）
  - Exception    基本类型，可以从任何标准的Java库方法，自定义方法及运行时事故中抛出

  异常的名字代表了所发生的问题，所以他应该是不言而喻的。  
  异常定义在Java.lang.utils/net/io等其他库，例如所有的IO异常都继承自Java.io.IOException  
  Java中异常数量不断增长,把它们放在一起基本上是没有意义的。  
  第三方库供应商的任何新库可能都有自己的异常，所以重要的是理解这个概念以及如何处理这些异常。  

  特例： RuntimeException这个类别有一整组的异常类型(放在RuntimeException基类之下)  
  它们由Java自动抛出，不需要放在异常说明中，不需要被异常处理程序捕获    //因为指示的是bug，被Java自动处理  
  RuntimeException代表编程错误：
  1. 无法预料的错误，如null引用
  2. 应该在代码中检查的错误(例：ArrayIndexOfBoundsException)

# 新特性：更好的NullPointerException报告机制
  JDK15会报告对象链中哪处产生了null，例：`new C(new B(null) )报告"c.b.a" is null`  
  JDK15之前只会报告null  

# 使用finally执行清理
  finally子句：不管try块中是否抛出异常并执行异常处理，finally子句的代码必须执行。  
  包括：  
  1. 内存恢复以外的恢复操作
  2. Try块放在循环中时，finally子句内放置一些循环放弃前的尝试办法
  3. 程序抛出某个未在catch子句捕获的异常，在异常处理机制向更高一层上下文搜索前，finally子句也会执行
  4. try块中涉及break和continue语句时，finally子句也会执行（跳出try块时）  
     带标签的break/continue和finally子句配合, Java中不再需要goto语句了  
  5. try块中任何位置return之前，finally子句均会执行

## 缺陷：异常丢失
  在内层try块的finally子句中抛出异常，外层catch子句同时捕捉多个异常  
  ```java
  try{
    try{
      throw Exception1();
    }finally{
      throw Exception2();
    }
  }catch(Exception1 | Exception2 e){
    System.out.println(e);            //输出：Exception2，Exception1被覆盖
  }                                   //根本原因在于多重捕获异常
  ```
  
  在finally块中用return，会把任何抛出的异常都压制下来，所以不要在finally子句中使用return
  ```java
  try{
    throw RuntimeExcepton();
  }finally{
    return;                          //没有任何输出
  }
  ```

# 异常的约束
  在继承体系结构中,重写方法只能抛出基类版本方法中说明的异常(及其子类)范围中的异常  
  但不允许新增异常（异常说明只能缩小，不能扩大，与继承规则不同————基类方法必须存在于子类：只能扩大，不能缩小）  

  目的：配合基类工作的代码，可以自动配合基类派生的任何子类对象工作，尤其是异常  
  1. 重写的普通方法，必须遵守基类该方法的约束，不能抛出基类方法未声明的异常  
     重写的普通方法，接口不能增加基类方法未声明的新异常声明（接口方法与该方法签名一致）  
     重写的普通方法，可以抛出基类版本声明异常的子类异常  
     重写的普通方法，可以选择不抛出任何异常  
  2. 子类构造器方法可以添加新异常声明，但必须声明基类构造器已声明的全部异常  
     子类构造器中会隐式/显式调用基类构造器,不论基类构造器有参/无参  
     子类构造器不能捕捉基类构造器抛出的异常：异常处理机制只会同级捕获和向上再抛出  
  3. 子类“向上转型”，编译器会强制程序员捕捉基类声明的异常，包括：  
     - 类定义时声明  
     - 方法定义是声明

# 异常发生在构造器
  构造器内创建一个需要清理的对象（例：打开一个文件）  
  如果在构造器内抛出异常，这些清理行为可能不会正确执行    ————编写构造器必须特别警惕  
  例：可能造成提前清理  
  ```java
  class A{
    A(){
      try{
        ...                              //创建行为：打开文件
      }catch(FileNotFoundException e){   
        ...
      }catch(Exception e){
        try{
          ...                            //在这里关闭文件：发生文件打开失败异常之外的其他异常,均需关闭文件
        }catch(IOException e){
          ...
        }
      }finally{                          //在这里关闭文件，导致每次构造完成后它就会关闭文件
        ...                              //然而我们希望的是在A对象生命周期内文件都是打开的
      }
  }
  ```

  如何正确清理? finalize()不确保被调用，也不知什么时候被调用  
  Java缺点：除了内存清理外，其他清理都不会自动发生 ——> 告知客户程序员，由他们自己处理  

  对于可能在构造器过程中抛出异常且需要清理的类  
  最安全的用法是使用嵌套的try块（放在创建可能抛出异常的类的其他类中，清理放在成功执行创建后的try块中）  
  ```java
  class CleanUp{
    public static void main(String[] args){
      try{
        a = new A();                     //外层try块创建对象                     
        try{                             //内层try块执行风险代码
          ...                  
        }catch(Exception e){
          ...                            //抛出异常
        }finally{
          ...                            //对象成功创建后，风险代码完毕，执行清理
        }
      }catch(Exception e){               //如果构造失败，就会逬入外部的catch子句，不会调用清理
        ...                              //没有成功创建对象，无需清理
      }
    }
  }
  ```

## 清理惯用法：在创建了一个需要清理的对象之后，直接跟一个try-finally块

### 如果对象构造不会失败，也就不需要catch子句  ————创建语句不用放在try块中

### 对于构造不会失败的对象，多个对象的构造和清理可以分别组织到一起
  ```java
  A a1 = new A();
  A a2 = new A();
  try{
    ...
  }finally{
    a1.dispose();
    a2.dispose();
  }
  ```

### 构造可能会抛出异常并且需要清理的对象
  将每个构造用他自己的try-catch包围起来, 处理"可能抛出的异常"  
  每个对象的构造操作后必须有一个try-finally语句块来保证清理, 处理"需要清理"  
  异常处理如此复杂, 所以应该创建不可能失败的构造器  

# try-with-resource子句
  ```java
  try(InputStream in = new FileInputStream(new File("xxx")) ){
    int Contents = in.read();
  }catch(IOException){
    ...
  }
  ```
  1. try()括号中内容为资源说明头，多个用";" 分隔
  2. 此处in在try块的其他部分均可用
  3. try()中对象创建成功后，不管如何退出try块（正常方式还是异常），都会执行try()中创建对象的清理工作————close()
  4. try-with-resource块可独立存在，没有catch或finally

## 底层原理
  try-with-resource的try()中创建的对象必须实现Java.lang.AutoCloseable接口  
  该接口只有一个方法————close()

  ```
  class Reporter implements AutoCloseable{
    String name =  getClass().getSimpleName();
    Reporter(){
      System.out.println("Creating" + name);
    }
    @Override
    public void close(){
      System.out.println("Closing" + name);
    }
  }
  ```
  特性：  
  1. 退出try块时调用多个对象的close方法，且会以与创建顺序相反的顺序关闭
  2. try()中对象创建时, 构造器抛出异常并退出try块, 对象的close()没有被调用, 因为构造器失败了, 不能假定可以在这个对象上安全执行任何操作  
     不会内存泄露，因为没有成功创建，无需close()  
  3. 未在try()中创建的对象(在{}中创建的})，在{}中抛出异常并退出try块(未在finally子句执行清理), 该对象永远不会得到清理(GC自动清理除外)

## 新特性(JDK9):try-with-resources中的实际上的最终变量
  JDK9增加了在try之前定义这些变量的能力，只要它们被显式声明为final变量，或实际上是final变量即可  
  在 Java 中，没有显式 final 修饰但实际是 final 的变量主要包括：  
  - try-with-resources 中的资源变量
  - foreach 循环（for-in语法）中的迭代变量
  - lambda/匿名类中捕获的外部变量

  ```java
  final InputStram r1 = new InputStram();]
  InputStram r1 = new InputStram();
  try(r1, r2){
    ...
  }
  r1.read();
  r2.read();
  ```
  1. 这种变量在try-with-resources释放后可能再次被引用，此时会触发异常(因为try()确保放入的对象已经被清理了)
  2. 完全避免使用这个特性可能是个好主意，将检查从编译时移到运行时纯副作用，同时失去了catch子句

# 异常匹配
  异常处理系统会按照处理程序的编写顺序来寻找“最近的”那个  
  当找到第一个匹配的处理程序时，他会认为异常已经得到了处理，从而不再进一步搜索  
  子类的对象可以匹配其基类的处理程序  
  向一个方法中加入更多的派生异常，只要客户程序员的代码捕捉的是基类异常，那就不需要修改  

# 其他可选方式
  检查型异常强（制编写异常处理catch子句）：强迫客户程序员添加catch子句，尽管我们可能未准备好错误处理。 ————导致“吞食有害”问题  
  C语言编程习惯是忽略代码中的错误，使用调试器来追踪错误  
  Java的检查异常包含编译时异常，确保实际抛出的是所说明的异常，并且异常说明是完整的(它要精确描述所有可能抛出的异常)  

## 检查型异常和静态类型检查对于稳健的程序开发来说是必不可少的
  1. 通过异常实现的是统一的错误报告模型，无论编译器是否会强制程序员处理它们
  2. 类型检查，不管什么时候进行。只要确保类型的正确使用，关于是在编译时还是运行时实施，这并不重要还是

## “检查型异常”转换为“非检查型异常”
  将检查型异常包在RuntimeException之中的技术  
  ```java
  try{
    switch(type){
      case 0: throw new FileNotfoundException();          //throwRuntimeException()方法不会抛出任何检查型异常当我们准确捕捉异常时将方法调用放在try块中取出包含的异常分别捕捉                               
      case 1: throw new IOException();        
      case 2: throw new RuntimeException("Where am I");
      default: return;
    }
  }catch(IOExcepton | FileNotfoundException e){
    throw new RuntimeException(e);
  }
  ```
  ```
  for( int i = 0; i < 3, i++){
    try{
      a.throwRuntimeExcepton(i);
    }catch(RuntimeExcepton re){
      try{
        throw re.getCause();
      }
    }catch(FileNotfoundException e){
      ...
    }catch(IOExcepton e){
      ...
    }catch(Throwable e){
      ...
    }
  }
  ```










  




