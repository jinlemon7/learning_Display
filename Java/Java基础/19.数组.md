对于数组的日常使用来说，只需要创建数组并往里填充元素，然后使用int类型的索引来取出元素，同时数组的大小不会因此改变  
大多数时候你只需要知道这些就足够了，但是有时你还需要对数组做一些更复杂的操作，同时可能还需要在数组和更复杂的Collection （集合）类型之间做评估选型  

随着Java的Collection和Stream拥有越来越多的高级特性，在日常编程中需要用到数组的场景变得越来越少，所以你可以暂时放心地略读甚至跳过本章  

# 数组为何特殊
  数组和Collection中的类型主要有三方面的区别：效率、类型、以及保存基本类型数据的能力   
  数组是Java中保存和随机访问对象引用序列最高效的方法  
  数组是一种简单的线性序列，使得访问元素的速度非常快  
  速度的代价则是数组的大小是固定的，一旦创建后就永远无法改变  

  通常你都应该首先考虑Collection中的ArrayList类 ，该类型实际是在内部维护了一个数组。在必要时，该类型会自动申请更多的数组空间，创建一个新数组，并将旧数组中的所有引用都移动到新数组中  
  这种灵活的机制是有性能损耗的，所以ArrayList没有数组高效  

  不论使用数组还是Collection,如果你越界访问了，就会抛出RuntimeException异常，指明程序存在错误。  

  相比于泛型之前的Collection,数组的优点在于，数组创建后只能用于保存特定类型的对象.这意味着你将得到编译时类型检查的机制保障，因此不会将错误的类型保存到数组中.亦不会在读取数组元素时搞错元素类型  

  数组可以保存基本类型，而泛型之前的Collection则不行  
  依靠泛型，Collection类型可以指定并检查它们所保存对象的类型；依靠自动装箱的自动类型转换，Collection也可以变相的保存基本类型  

  ```java
  int[] integers = { 0, 1, 2, 3, 4, 5 };
  System.out.println(integers[4]);

  List<Integer> intList = new ArrayList<>(
    Arrays.asList(0, 1, 2, 3, 4, 5)):
  intList.add(97);
  System.out.println(intList);
  System.out.println(intList.get(4));
  ```
  ```java
  /*输出：
  4
  [0, 1, 2, 3, 4, 5, 97]
  4
  */
  ```
  这两种保存对象的方法都会检查类型，唯一明显的区别是，数组使用[]来访问元素.而List使用如add()和get()这样的方法  

## 一个用于显示数组的常用工具程序
  Java提供了 Arrays.toString()这个方法来将数组转化为可读的字符串，从而可以将数组在控制台中打印(显示)  
  
# 数组是一等对象
  不论使用哪种类型的数组，数组的标识符［］实际上都是对某个在堆上创建的真实对象的引用，因此数组就是一种保存对其他对象的引用的对象，它可以作为数组初始化语句中的一部分来隐式地创建，也可以使用new关键字来显式地创建  
  唯一可读的字段或方法是只读的length成员属性，代表数组中可保存的元素数量，此外[]语句就是访问数组对象的唯一途径了  

  对象数组和基本类型数组的使用方式大体上是一样的。唯一的区别在于.对象数组保存的是引用.而基本类型数组保存的是基本类型的值  
  ```java
  public class Arrayoptions {
    public static void main(String[] args) {
      //对象数组：
      BerylliumSphere[] a;           //未初始化的本地变量，只是个数组符号引用
      BerylliumSphere[] b = new BerylliumSphere[5];            //已分配堆空间，执行Java默认初始化——赋值为null

      //数组内部的引用被自动初砖化为null：
      show("b", b);
      BeryHiumSphere[] c = new BerylliumSphere[4];
      for(int i = 0; i < c.length; i++)
        if(c[i] == null) //可以校查是否为空引用
          c[i] = new BerylliumSphere();

      //批量初始化：
      BerylliumSphe[] d = {
        new BerylliumSphere(),
        new BerylliumSphere(),
        new BerylliumSphere()
      }

      //动态批量初始化:
      a = new BerylliumSphere[]{
        new BerylliumSphere(), new BerylliumSphere(),
      };
    }
  }
  ```
  - 数组a是个未初始化的本地变量，如果你没有正确地初始化它，编译器就会阻止你对该引用做任何操作
  - 数组b则被初始化为对BerylliumSphere对象数组的引用，但实际上并没有任何BerylliumSphere对象被保存在b里，不过由于b指向了一个合法的对象，因此你仍然可以查询数组的大小
  - 当一个数组对象被创建后，其中所有元素的引用都会自动初始化为null
  - 对于数值类型，基本类型数组中的元素会自动初始化为0；对于char类型，会初始化为(char)0；对于boolean类型，会初始化为false

  ```java
  hide(d);

  你还可以在传入参数的地方，直接动态地创建一个数组:

  hide(new BerylliumSphere[]{
    new BerylliumSphere(),
    new BerylliumSphere()
  })
  ```

# 返回数组
  使用像C或者C++这样的语言会很难实现，因为无法直接返回一个数组，只能返回一个指向数组的指针。这会带来不少麻烦，因为对数组的生命周期管理会变得很复杂，十分容易导致内存泄漏  
  
  在Java中，你可以直接返回一个数组 你永远不需要操心数组的内存管理————只要数组还在使用，它就一直存在，而垃圾收集器则会在你使用完之后自动将它回收  

  推荐使用Java 8中的SplittableRandom,不仅支持并行操作（你迟早会学到），而且还能生成更高质量的随机数  

# 多维数组
  如果要创建多维的基本类型数组，你需要使用大括号来分隔数组中的每个向量:  
  ```java
  public class MultidimensionalPrimitiveArray {
    public static void main(String[] args) {
      int[][] a = {
          {1, 2, 3,},
          {4, 5, 6,},
      }；
      System.out.printin(Arrays.deepToString (a));
    }
  }
  ```
  ```java
  /*输出:
  [[1, 2, 3], [4, 5, 6]]
  */
  ```

  也可以使用关键字new来创建数组：，下例便以此方法创建了一个三维数组:  
  ```java
  public class ThreeDWithNew {
    public static void main(String[] args) {
    //固定长度的三维敦畑：
      int(][][] a = new int[2][2][4];
      System.out.printIn(Arrays.deepToString(a));
    }
  }
  ```
  ```java
  /*输出:
  [[[0, 0, 0, 0], [0, 0, 0, 0]], [[0, 0, 0, 0], [0, 0, 0, 0]]]
  */
  ```

  数组中构成矩阵的每组向量的大小没有限制[称为不规则数组(ragged array)]：  
  ```java
  public class Array {
    static int val = 1;

    public static void main(String[] args) {
      SplittableRandom rand = new SplittableRandom(47); // 可变向量的三维数组:
      int[][][] a = new int[rand.nextInt(7)][][];
      for (int i = 0; i < a.length; i++) {
        a[i] = new int[rand.nextInt(5)][];
        for (int j = 0; j < a[i].length; j++) {
          a[i][j] = new int[rand.nextInt(5)];
          Arrays.setAll(a[i][j], n -> val++);         // [1]
        }
      }
      System.out.println(Arrays.deepToString(a));
    }
  }
  ```
  ```java
  /*输出：
  [[[1], []] [[2, 3, 4, 5], [6]], [[7, 8, 9], [10, 11, 12], []]]
  */
  ```
  - Java 8新增了 Arrays.setAll()方法，其使用一个生成器来生成数值并填充到数组中
  - 该生成器和函数式接口IntUnaryOpeiator一致，只有一个非默认方法applyAsInt(int operand)
  - 第一个new创建了一个数组，其中第一个元素的长度是随机的，而剰下的则未定义
  - 第一层for循环中的new负责填充数组的第二个元素，第二个for循环中的new负责填充第三个元素

  Arrays.deepToString()方法同时适用于基本类型数组和对象数组:  
  ```java
  public class MultiDimWrapperArray {
    public static void main(String[] args) {
      Integer[] [] a1 = {           // 自动装箱
        {1, 2, 3,},
        {4, 5, 6,},
      };
      System.out.println(
        "al: " + Arrays.deepToString(al));
  ```
  ```java
  /*
  a1： [[1, 2, 3], [4, 5, 6]]
  */
  ```

# 数组和泛型
  通常来说，数组和泛型并不能很好地结合.例如你无法实例化一个参数化类型的数组:  
  `Peel<Banana>[] peels = new Peel<Banana>[10];`  // 非法代码  
  类型擦除移除了参数的类型信息，所以数组必须清楚地知道自身所保存的具体类型，以保证类型安全  
  数组自身的类型是可以参数化的:  
  ```java
  class ClassParameter<T> {
    public T[] f(T[] arg) { return arg; }
  }
  class MethodParameter {
    public static <T> T[] f(T[] arg) ( return arg; }
  }
  ```
  - 相较于参数化类，参数化方法通常更方便
  - 你无法每次都选择使用参数化方法而不是参数化类，但前者通常都会更好一些

  编译器不会允许你实例化一个泛型数组，但它允许你创建对此类数组的引用:  
  `List<String>[] ls;`  
  尽管你无法创建一个能实际持有泛型的数组对象，但还是可以创建非泛型的数组，然后强制类型转换:  
  ```java
  public class ArrayOfGenerics {
    @SuppressWarnings("unchecked")
    public static void main(String[] args) {
      List<String>[] ls;
      List[] la = new List[10];
      ls = (List<String>[])la;           //未经检查的类型转换
      ls[0] = new ArrayList<>();

      //- ls[1] = new ArrayList<Integer>()；
      //错误：类型不匹配
      // ArrayList<Integer> 无法转换为 List<String>
  
      //问题：List<String> 是Object类型的子类
      Object[] objects = ls; // 可以这样分配
      //顺利地编译及运行：
      objects[1] = new ArrayList<>();

      //不过如果你的需求很直接，可以创建一个泛型的数组（虽然会发出unchecked cast警告）：
      List<BerylliumSphere>[] spheres =
        (List<BerylliumSphere>[])new List[10];
      Arrays.setAll(spheres, n -> new ArrayList<>());
    }
  }
  ```
  
  如果你确定不会向上转型，需求也相对简单，那么你或许可以创建一个泛型数组，它也会提供基本的编译时类型检查  
  然而通常来说，泛型集合是比泛型数组更好的选择  

  泛型在类和方法的边界上是有效的；而在内部，类型擦除通常会使泛型变得不可用  
  因此你会受到一些限制，比如无法创建泛型类型的数组：  
  ```java
  public class ArrayOfGenericType<T> {
    T[] array;         // OK
    @SuppressWarnings ("unchecked")
    public ArrayOfGenericType(int size) {
      //错误：创建泛型数组
      //- array = new T[size];
      array = (T[] )new Object[size];             // 未检查的类型转换
    }
    //错误：创建泛型数组
    //- public <U> U[] makeArray() ( return new U[10]; }
  }
  ```
  - 以上示例试图创建已被擦除类型（因此是未知类型）的数组:你可以创建Object类型的数组，然后逬行强制类型转换

# Arrays.fill()
  在Java标准库Arrays中有一个小方法,它可以将一个数值复制到数组的所有位置；对于对象数组，它可以将一个引用复制到数组的所有位置  
  ```java
  String[] a9 = new String[size];
  Arrays.fill(a9, "Hello");
  show("a9", a9);
  //操作数组的范围：
  Arrays.fill(a9, 3, 5, "World");
  show("a9", a9);
  ```
  ```java
  a9: [Hello, Hello, Hello, Hello, Hello, Hello]
  a9: [Hello, Hello, Hello, World, World, Hello]
  ```
  - 你可以填充整个数组，或者像以上示例的最后两行语句那样，填充数组的指定范围

# Arrays.setAll()
  Arrays.setAll()是Java 8中新引入的方法，它能利用生成器生成不同的值，具体的生成方式则由数组的索引元素决定(生成器通过访问当前索引来读取并修改数组的值)
  - void setAll(int[] a, IntUnaryOperator gen)
  - void setAll(long[] a, IntToLongFunction gen)
  - void setAll(double[] a, IntToDoubleFunction gen)
  - <T> void setAll(T[] a, IntFunction<? extends T> gen)
  生成器并非Supplier,因为Suppliu并不接收参数，而生成器则必须传入int型的数组索引作为参数
  ```java
  class Bob {
    final int id;
    Bob(int n) ( id = n; }
    @Override
    public String toString() { return "Bob" + id; )
  }
  public class SimpleSetAll {
    public static final int SZ = 8;
    static int val = 1;
    static char[] chars = "abcdefghijklmnopqrstuvwxyz"
      .toCharArray();
    static char getChar(int n) { return chars[n]; }
    public static void main(String[] args) {
      int[] ia = new int[SZ];
      Arrays.setAll(ia, n -> n); // [1]
      show(ia);
      Arrays.setAll(ia, n -> val++); // [2]
      show(ia);

      Bob[] ba = new Bob[SZ];
      Arrays.setAll(ba, Bob::new); // [3]
      show(ba);

      Character[] ca = new Character[SZ];
      Arrays.setAll(ca, SimpleSetAll::getChar); // [4]
      show(ca);
    }
  }
  ```
  ```java
  /*输出：
  [0, 1, 2, 3, 4, 5, 6, 7]
  [1, 2, 3, 4, 5, 6, 7, 8]
  [Bob0, Bob1, Bob2, Bob3, Bob4, Bob5, Bob6, Bob7]
  [a, b, c, d, e, f, g, h]
  */
  ```
  - [3]本方法引用是有效的，因为Bob的构造器接收int类型参数,只要我们传入的函数能接收int类型参数并生成预期的结果，这种方式就有效
  - [4]]要处理int、long和double之外的基本类型，则需要为该基本类型编写相匹配的包装类型数组，然后使用泛型版本的setAll()

# 增量生成器
  由于使用了包装类的名字作为内部类的名字，因此必须在实际的包装类名前加上包名java.lang:  
  ```java
  public interface Count {
    class Boolean
    implements Supplier<java.lang.Boolean>{
      private boolean b = true;
      @Override
      public java.lang.Boolean get() {
        b = !b;
        return java.lang.Boolean.valueOf(b);
      }
      public java.lang.Boolean get(int n) {
        return get();
      }
      public java.lang.Boolean[] array(int sz) {
        java.lang.Boolean[] result =
          new java.lang.Boolean[sz];
        Arrays.setAll(result, n -> get());
        return result;
      }
    }
    class Pboolean {
      private boolean b = true;
      public boolean get() {
        b = !b;
        return b;
      }
      public boolean get(int n) { return get(); }
      public boolean[] array(int sz) {
        return primitive(new Boolean().array(sz));
      }
    }
  }
  ```

  下面是一段测试Count的程序，同时也示范了该如何使用它  
  ```java
  public class TestCount {
    static final int SZ = 5;
    public static void main(String[] args) {
      System.out.prinfln( "Boolean");
      Boolean[] a1 = new Boolean[SZ];
      Arrays.setAll(a1, new Count.Boolean()::get);
      show(a1);
      a1 = Stream.generate(new Count.Boolean())
        .limit (SZ + 1).toArray(Boolean[]::new);
      show(a1);
      a1 = new Count.Boolean().array(SZ + 2);
      show(al);
      boolean[] alb =
        new Count.boolean().array(SZ + 3);
      show(alb);
    }
  }
  ```
  ```java
  /*输出：
  Boolean
  [false, true, false, true, false]
  [false, true, false, true, false, true]
  [false, true, false, true, false, true, false]
  [false, true, false, true, false, true, false, true]
  */
  ```
  - 由Stream.generate()创建的包装类数组演示了toArray()方法的flj纹用法，它是通过要创建的数组类型所对应的构造器来实现的

# 随机数生成器
  ```java
  public interface Rand {
    int MOD = 10_000;
    class Boolean
    implements Supplier<java.lang.Boolean> {
      SplittableRandom r = new SplittableRandom(47);
      @0verride
      public java.lang.Boolean get() {
        return r.nextBoolean();
      }
      public java.lang.Boolean get(int n) {
        return get();
      }
      public java.lang.Boolean[] array(int sz) {
        java.lang.Boolean[] result =
          new java.lang.Boolean[sz];
        Arrays.setAll(result, n -> get());
        return result;
      }
    }
    class Pboolean {
      public boolean[] array(int sz) {
        return primitive(new Boolean().array(sz));
      }
    }
  }
  ```

  下面是针对完整Rand工具的测试代码:  
  ```java
  public class TestRand {
    static final int SZ = 5;
    public static void main(String[] args) {
      System.out.println("Boolean");
      Boolean[] a1 = new Boolean[SZ]:
      Arrays.setAll(a1, new Rand.Boolean()::get);
      show(a1);
      a1 = Stream.generate(new Rand.Boolean())
        .limit(SZ + 1).toArray(Boolean[]::new);
      show(a1);
      a1 = new Rand.Boolean().array(SZ + 2);
      show(al);
      boolean[] a1b =
        new Rand.Pboolean().array(SZ + 3);
      show(a1b);
    }
  }
  ```
  ```java
  /*输出：
  Boolean
  [true, false, true, true, true]
  [true, false, true, true, true, false]
  [true, false, true, true, true, false, false]
  [true, false, true, true, true, false, false, true]
  */
  ```

# 泛型和基本类型数组
  从基本类型数组强制类型转换为包装类型数组，或者反向转换:  
  ```java
  public interface ConvertTo {
    static boolean[] primitive(Boolean[] in) {
      boolean[] result = new boolean[in.length];
      for(int i = 0; i < in.length; i++)
        result[i] = in[i];               // 自动拆箱
      return result;
    }
    //从基本类型数组紆换为包装类型敦组：
    static Boolean[] boxed(boolean[] in) {
      Boolean[] result = new Boolean[in.length]；
      for(int i = 0; i < in.length; i++)
        result[i] = in[i];             // 自动装箱
      return result;
    }
  }
  ```

  下面是对ConverTo中所有方法的测试代码:  
  ```java
  public class TestConvertTo {
    static final int SIZE = 6;
    public static void main(String[] args) {
      Boolean[] a1 = new Boolean[SIZE]:
      Arrays.setAll(a1, new Rand.Boolean()::get);
      boolean[] a1p = primitive(a1);
      show("a1p", a1p);
      Boolean[] a1b = boxed(a1p);
      show("a1b", a1b);
    }
  }
  ```
  ```java
  /*输出
  alp：[true, false, true, true, true, false]
  alb: [true, false, true, true, true, false)
  */
  ```

# 修改已有的数组元素
  传给Arrays.setAll()的生成器函数可以通过传给它的数组索引来修改已存在的数组元素:  
  ```java
  public class ModifyExisting {
    public static void main(String[] args) {
      double[] da = new double[7]；
      Arrays.setAll(da, new Rand.Double()::get);
      show(da);
      Arrays.setAll(da, n -> da[n] / 100);       // [1]
      show(da);
    }
  }
  ```
  ```java
  /*输出：
  [4.83, 2.89, 2.9, 1.97, 3.01, 0.18, 0.99]
  [0.0483, 0.028900000000000002, 0.028999999999999998,
  0.0197, 0.0301, 0.0018, 0.009899999999999999]
  */
  ```

# 关于数组并行
  如果你不假思索地使用井行，那么你写出来的程序反而可能比未使用并行时更慢  
  并行编程很多时候与其说是科学，不如说是艺术  
  尽量用简单的方式来实现代码，除非的确有必要（比如性能遇到瓶颈，可以用并行解决），否则不要轻易陷入并行的泥潭中  

  还有一些情况下，不管你是否决定尝试并行，也不管你是否只有一个处理器，并行实现都是唯一的、最佳的或者最合理的选择。你总会用到并行，因此你必须弄清楚它。  

## 策略
  从数据的角度来思考并行可能是最合适的：对于大量的数据（并且有额外的处理器可用）.并行可能会有帮助。但有时并行也可能没用，甚至反而会使情况变得更槽  
  1. 并行是唯一可选的方案。这种情况很好处理，因为除此以外没有其他选择。这很罕见
  2. 有多种可选方案，但是并行方案（通常是最新的方案）被设计成在代码中全面使用（即使在并不关心并行处理的部分代码中也是如此），类似情况1。我们就是要使用并行的方案
  3. 情况1和情况2并不是那么常见 大多数情况下，你会看到两种版本的算法————一种用于并行方式，另一种用于普通方式。我会重点讲述并行算法，但由于并行可能带来的风险，我并不会在所有场景中都应用它

## parallelSetAll()
  用流式计算（Stream）可以使代码更优雅。举例来说，假设我们要创建一个long型数组，并用从0幵始递增的数据来填充它：  
  ```java
  public class CountUpward {
    static long[] fillCounted(int size) {
      return LongStream.iterate(0, i -> i + 1)
        .limit(size) .toArray();
    }
    public static void main(String[] args) {
      long[] l1 = fillCounted(20);       // 没问题
      show(l1);
      //在我的机器上，这里堆湛出了：
      //- long[] l2 = fillCounted(10_000_000);
    }
  }
  ```
  ```java
  /*输出:
  [0, 1, 2, 3, 4, 5, 6, 1, 8, 9, 10, 11, 12, 13, 14, 15,
  16, 17, 18, 19]
  */
  ```
  - Stream处理的值到达近干万时才会幵始耗尽堆内存

# 数组实用工具
  在 java.util.Arrays类中，该类中还有更多有用的静态工具方法  
  - asList()：传入任意的序列或数组，并转化为列表集合(List、Collection )
  - copyOf()：按新的长度创建已有数组的副本
  - copyOfRange()：对已有数组的指定长度范围创建副本
  - equals()：比较两个数组是否相等
  - deepEquals()：比较两个多维数组是否相等
  - stream()：为数组元素创建一个流(Stream )
  - hashCode()：计算数组的哈希值
  - deepHashCode()：计算多维数组的哈希值
  - sort()：对数组逬行排序
  - parallelSort()：以并行方式对数组进行排序，以提升速度
  - binarySearch()：在已排序的数组中查找一个元素
  - parallelPiefix()：使用提供的函数逬行并行累积计算,基本上相当于数组的reduce()方法
  - spliterator()：生成数组的分割器(Spliterator )
  - toString()：生成用于描述数组的字符串
  - deepToString()：生成用于描述多维数组的字符串

# 数组复制
  copyOf()和copyOfRange()方法复制数组的速度远远快于用for循环等手写代码的实现方式。  
  这类方法对所有类型都有对应的重载版  
  ```java
  class Sup {         // 父类
    private int id;
    Sup(int n) ( id = n; )
    ©Override
    public String toString() {
      return getClass().getSimpleName() + id;
    }
  }
  class Sub extends Sup {     // 子类
    Sub(int n) { super(n); }
  }
  public class ArrayCopying {
    public static final int SZ = 15;
    public static void main(String[] args) {
      Sub[] d = new Sub[SZ/2];
      Arrays.setAll(d, Sub::new)；
      // 由 Sub[]生成 Sup[]：
      Sup[] b =
        Arrays.copyOf(d, d.length, Sup[].class);   // [4]
      show(b);

      // "向下转型"可以通过编译，但会抛出异常:
      Sup[] b2 = new Sup[SZ/2]
      Arrays.setAll(b2, Sup::new)；
      try {
        Sub[] d3 = Arrays.copyOf(
          b2, b2.length, Sub[].class);           // [6]
      } catch(Exception e) {
        System.out.println(e);
      }
    }
  }
  ```
  ```java
  /*输出
  [Sub0, Subl, Sub2, Sub3, Sub4, Sub5, Sub6]
  java.Lang.ArrayStoreException
  */
  ```
  - [4]copyOf()和copyOfRange()都有创建不同类型数组的重载版本，在调用时给方法的最后一个参数传入目标类型即可
  - 是用来做“向上转型”和“向下转型”的，也就是说，如果你想根据一个已有的子类型数组生成它的基类数组，这些方法能帮你达到目的
  - [6]在此处强行把基类当作其子类是非法的，因为子类对象中的一些数据和方法很可能在基类对象中并不存在

# 数组比较
  Arrays类提供了equals()方法来比较一维数组是否相等,以及deepEquals()方法来比较多维数组。这些方法都有针对所有基本类型和对象类型的重载版本实现  
  对于基本类型，是由其包装类中的equals()方法来比较的，例如int元素实际是由Integer.equals()来负责比较  

# 流和数组
  stream()方法能够很方便地根据某些类型的数组生成流:  
  ```java
  public class StreamFromArray {
    public static void main(String[] args) {
      int[] ia = new Rand.Pint().array(10);
      Arrays.st ream(ia)
        .skip(3)
        .limit(5)
        .map(i -> i * 10)
        ,forEach(System.out::println);

      // 只支持 int、long 以及 double：
      //- Arrays.stream(new boolean[10]);
      //- Arrays.stream(new byte[10]);
      //- Arrays.stream(new char[10]);
      //- Arrays.stream(new short[10]);
      //- Arrays.stream(new float[10]);

      //对于其他类型，必须使用包装类:
      float[] fa = new Rand.Pfloat().array(10);
      Arrays.stream(ConvertTo.boxed(fa));
      Arrays.stream(new Rand.Float().array(10));
    }
  }
  ```
  ```java
  47200
  61770
  84790
  66560
  37680
  ```
  - 只有int、long和double这些原生支持的类型适用于Arrays.stream(),其他类型则总是需要通过包装类数组来实现

  相较于直接操作数组，先将数组转化为流通常更容易生成你想要的结果。要注意的是，尽管当前流“用完了”(你无法重复消费流)，但你仍然持有数组，因此还可以用别的方式继续使用它————包括再生成一个流

# 数组排序
  程序设计中最重要的目标之一是“分离易变的和不易变的事物”  
  此处,不变的(代码)是通用的排序算法，而会变化的则是具体对象的比较方式  
  所以相较于在大量不同的排序逻辑中分别实现不同的比较方法，更应该使用策略设计模式(strategy design pattern )  
  在策略模式中，代码中易变的部分被包含在一个独立的类中(即策略对象).然后将策略对象传递到通用不变的代模版，后者利用策略对象来补全为完整的算法  

  Java有两种方式来实现比较功能  
  第一种:  
  是给目标类増加“原生”的比较方法，通过实现java.lang.Comparable接口即可，该接口十分简单，只有一个方法:compareTo()  
  ```java
  public class CompType implements Comparable<CompType> {
    int i;
    int j;
    private static int count = 1;
    public CompType(int n1, int n2) {
      i = n1;
      j = n2;
    }
    @verride
    public int compareTo(CompType rv) {
      return (i < rv.i ? -1 : (i ==rv.i ? 0 : 1));
    }
  }
  ```
  - 一旦定义了比较方法，你就需要决定它如何来比较两个对象

  第二种：  
  现在假设有人给了你一个没有实现Comparable接口的类，或者给了你一个实现了Comparable接口的类，但是你并不喜欢它的实现方式，决定要换一种  
  要解决这个问题.你可以单独创建一个实现了 Comparator接口(在第12章中简单介绍过)的类，它有两个方法：compare()和equals()  
  ```java
  class CompTypeComparator
  implements Comparator<CompType> {
    public int compare(CompType o1, CompType o2) {
      return (o1.j < o2.j ? -1 : (o1.j == o2.j ? 0 : 1));
    }
  }
  ```

## 使用 Arrays.sort()
  通过内建的排序方法，可以对任何基本类型数组或者对象类型（实现了 Compamble接口或实现了对应的Comparator）进行排序  
  ```java
  public class StringSorting {
    public static void main(String[] args) {
      String[] sa = new Rand.String().array(20);
      show("Before sort", sa);
      Arrays.sort(sa);
      show("After sort", sa);
    }
  }
  ```
  ```java
  /*输出：
  Before sort: [btpenpc, cuxszgv, gmeinne, eloztdv,
  ewcippc, ygpoalk, Ljlbynx, taprwxz, bhmupju, cjwzmmr,
  anmkkyh, fcjpthl, skddcat, jbvlgwc, mvducuj, ydpulcq, 
  zehpfmm, zrxmclh, qgekgly, hyoubzl]
  After sort: [anmkkyh, bhmupju, btpenpc, cjwzmmr,
  cuxszgv, eloztdv, ewcippc, fcjpthl, gmeinne, hyoubzl, 
  jbvlgwc, Ijlbynx, mvducuj, qgekgly, skddcat, taprwxz,
  ydpulcq, ygpoalk, zehpfmm, zrxmclh]
  */
  ```
  - 注意该字符串排序算法中的输出使用的是字典顺序，+因此会将所有大写字母开头的单词放在前面，小写字母幵头的单词放在后面(电话簿就是典型的例子)

  Java标准库中的排序算法已经为各种类型做了最优的设计————对基本类型使用快速排序，对对象使用稳定的归并排序

## 并行排序
  如果排序的性能成了问题，你可以使用Java 8中的parallelSort(),该方法对所有可能的情况都实现了对应的重载版本，包括对数组中的多个部分逬行排序，或者使用Comparator  
  ```java
  @State(Scope.Thread)
  public class ParallelSort {
    private long[] la;
    @Setup
    public void setup() {
      la = new Rand.Plong().array(100_000);
    }
    @Benchmark
    public void sort() {
      Arrays.sort(la):
    }
    @Benchmark
    public void parallelSort() {
      Arrays.parallelSort(la);
    }
  }
  ```
  parallelSort()的算法不断将大数组分割成较小的数组，直到数组的大小到达限制,继而使用传统的Arrays.sort()方法，然后将结果合并  

# 用 Arrays.binarySearch()进行二分查找
  一旦数组排好了序，便可以通过Arrays.binarySearch()来快速查找某个特定的元素。  
  然而，如果你对未排序的数组使用binarysearch()查找，则结果可能无法预测  
  ```java
  public class Arraysearching {
    public static void main(String[] args) {
      Rand.Pint rand = new Rand.Pint();
      int[] a = new Rand.Pint().array(25);
      Arrays.sort(a);
      show("Sorted array", a);
      while(true) {
        int r = rand.getAsInt();
        int location = Arrays.binarySearch(a, r);
        if(location >= 0) {
          System.out.println(
            "Location of " + r + " is " + location +
            ", a[" + location + "] is " + a[location]);
          break;         // 跳出 while 循环
        }
      }
    }
  }
  ```
  ```java
  /*输出:
  Sorted array: [125, 267, 635, 650, 1131, 1566, 1634,
  2400, 2766, 3063, 3768, 3941, 4720, 4762, 4948, 5878.
  5682, 5807, 6177, 6193, 6656, 7021, 8479, 8737, 9954]
  Location of 635 is 2, a[2] is 635
  */
  ```

  如果你需要一个去重的排序数组.可以使用TreeSet（以维护排列顺序）或者LinkedHashSet（以维护插入顺序）：这些类会自动管理所有细节.只有当它们成为性能瓶颈时，才应该考虑用手动维护（顺序）的数组来替代  
  如果使用了 Comparator来对对象数组进行排序（基本类型的数组不允许吏用Comparator来排序），那么在使用binarySearch()（适用的binarySearch()重载版本）时.也需要引用同一个Comparator  
  ```java
  String[] sa = new Rand.String().array(30);
  Arrays.sort(sa, String.CASE_INSENSITIVE_ORDER);
  show(sa);
  int index = Arrays.binarySearch(sa,
    sa[10], String.CASE_INSENSITIVE_ORDER);
  System.out.println(
    "Index: "+ index + "\n"+ sa[index]);
  ```
  ```java
  /*输出：
  [anmkkyh, bhmupju, btpenpc, cjwzmmr, cuxszgv, eloztdv,
  ewcippc, ezdeklu, fcjpthl, fqmlgsh, gmeinne, hyoubzl,
  jbvlgwc, jlxpqds, Ijlbynx, mvducuj, qgekgly, skddcat,
  taprwxz, uybypgp, vjsszkn, vniyapk, vqqakbm, vwodhcf,
  ydpulcq, ygpoalk, yskvett, zehpfmm, zofmmvm, zrxmclh]
  Index: 10
  gmeinne
  */
  ```
  - Comparator必须要作为第三个参数传给重载的binarySearch()方法

# 用parallelPrefix()进行累积计算
  parallelPrefix()方法很像Stream类中的reduce()方法：它会对前一个元素和当前元素进行操作，将结果放入当前元素的位置：  
  ```java
  public class ParallelPrefi1{
    public static void main(String[] args) {
      int[] nums = new Count.Pint().array(10);
      show(nums);
      System.out.println(Arrays.stream(nums)
        .reduce(Integer::sum).getAsInt());
      Arrays.parallelPrefix(nums, Integer::sum); 
      show(nums);
      System.out.println(Arrays.stream(
        new Count.Pint().array(6))
          .reduce(Integer:: sum) .getAsInt());
    }
  }
  ```
  ```java
  /*输出:
  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
  45
  [0, 1, 3, 6, 10, 15, 21, 28, 36, 45]
  15
  */
  ```
  - 在位置0，该方法将前置位算好的值(没有前置位则为0 )和当前值合并，并更新到位置0；在位置1,该方法继续将前我位算好的值(即
刚才更新到位置0中的值)和当前值合并.并更新到位置1
  - 使用Stream.reduce()方法只能得到最终的结果.而Arrays.parallelPrefix()方法则还能得到所有的中间结果值(如果需要的话)

  正如之前提到的，用Stream来初始化非常优雅，但是对于非常大的数组，该方法会导致堆内存耗尽，使用setAll()方法来初始化能够更高效地利用内存  
  ```java
  public class ParallelPrefix3 {
    static final int SIZE = 10_000_000;
    public static void main(String[] args) {
      long[] nums = new long[SIZE];
      Arrays.setAll(nums, n -> n);
      Arrays.parallel.Prefix(nums, Long::sum);
      System.out.println("First 20: " + nums[19]);
      System.out.println("First 200: " + nums[199]);
      System.out.println("All: " + nums[nums.length-1]);
    }
  }
  ```
  ```java
  /*输出:
  First 20: 190
  First 200: 19900
  All: 49999995000000
  */
  ```
  由于很难保证正确使用，因此除非遇到内存或者性能（或两者同时出现）问题时，可以考虑使用parallelPrefix(),否则都应该默认使用Stream.reduce()  

# 总结
  Java对固定长度、低级实现的数组提供了十分恰当的支持  
  这类数组在性能和灵活性中更偏向前者，正如C和C++的数组模型一样  
  在初期版本的Java中，固定长度、低级实现的数组是绝对必需的，不只是因为Java的设计者选择兼容基本类型（同时也是为了性能着想）.也是因为当时对集合类型的支持还非常薄弱  
  
  在Java后来的版本中，对集合的支持得到了显著的提升，此后集合便成了除性能外各方面都比数组更加出色的选择  

  由于自动装箱和泛型的存在，因此在集合中保存基本类型是毫不费力的，这也更加促使你用集合来替代低级实现的数组  
  因为泛型能生成类型安全的集合，所以数组在这方面也不再具有优势了  

  一些语言根本就没有固定长度和低级实现的数组。它们只有比C/C++/Java功能更强大的可变长度集合，比如Python中的一种list类型，它使用基本的数组语法，但是支持的功能要多得多：  
  ```java
  class MyList(list): # 继承自 list
    #定义方法,并显式地使用"this"指针:
    def getReversed(self):
      reversed = self[:]     # Copy list using slices
      reversed.reverse()       # Built-in list method
      return reversed
  ```
  - MyList是一个class类型的定义，基类被放在圆括号中
  - 在MyList类中.def语句用来定义方法，而传入的第一个参数自动相当于Java中的this,只是在Python中习惯在此处使用显式的标识符self（它并不是一个语法关键字）

  虽然Python中的一切都的确是对象（包括整型和浮点型）.但你仍然有办法打破封装.进入内部，因为你可以通过编写C、C++或使用一些专门用来提升性能的特殊工具（这类工具很多）来优化代码中的性能瓶颈。通过这种方法，你可以在拥有性能优化能力的同时.保证对象的纯粹性  

  我们肯定很难离幵数组，你在阅读代码时也会经常看到它们。然而，Collection的各种实现，几乎永远是更好的选择  
  
