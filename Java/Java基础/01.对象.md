# 对象：问题空间（现实）概念在机器空间（计算机）的映射
  抽象：现实概念抽象为虚拟对象。  
  5个特征：  
  1. 万物皆对象
  2. 程序：多个对象通过发送消息来通知彼此要干什么
  3. 内存角度而言，一个对象由其他基础对象“组合”而来
  4. 每个对象都有类型 .class
  5. 同一类型可以接受相同消息

  即对象具有状态（字段）、行为（方法）和标识（内存地址）。  

# 接口与实现
  - 类：抽象数据类型
  - 对象：某种类型的对象/实例
  - 接口（interface）：定义了能够向对象发送的请求/消息
  - 实现（implementation）：响应请求/消息

# 隐藏：类只暴露必要的接口给客户程序员，防止破坏，易于修改
  3种访问修饰符（显式关键字）： 
  - public：可被所有类访问
  - protected：类似private，区别在于继承的子类允许访问protected成员
  - 包访问权限：无关键字（默认），同一个包内的类可互相访问
  - private：只能被该类自身的方法访问

  - 类不能被protected/private修饰,会导致其他所有类均无法访问！（直接报错！！）
  - 字段和方法可被任意访问修饰符修饰

# 复用实现
  - 实例化类的对象
  - 创建新的类：组合任意已有的类

# 继承
  ```mermaid
  graph TD;
      子类1-->基类;
      子类2-->基类;
      子类3-->基类;
  ```
  基类的所有字段/方法与子类共享  
  接口继承：基类能够接受的请求/消息，子类一样可以  
  子类的新东西：  
  1. 添加新方法
  2. 重写基类已有方法

  - 子类与基类接口完全一样：“is a”关系， 即 A是B
  - 子类添加了新接口："is-ilke-a"关系，即 A像B

# 多态
  “向上转型”  
  ```mermaid
  graph TD;
      Circle-->Shape;
      Square-->Shape;
      Triangle-->Shape;
  ```
  Shape的方法不管对象具体属于哪个类，都可以正常运行。  
  将子类视为基类的过程叫“向上转型”

# 单根层次结构：所有的类都默认继承自一个基类：Object
  优势：  
  - 保证接口兼容性：向上转型
  - 有利于实现垃圾收集器 garbage collector
  - 异常处理（exception handling）简单

# 集合：新类型的对象，用来保存其他对象
  集合（容器）：根据放入内容自行调整空间，无须关注保存数量，如何保存等问题。  
  参数化类型（泛型）：  
  - 集合只能持有Object类型
  - 放入集合：向上转型，特定类型->Object
  - 取出集合：向下转型，Object->特定类型

  被参数化的类型是一种特殊类，编译器自动适配特定的类型  
  以 `<className>` 形式定义泛型，例：ArrayList<Shape> shape = new ArrayList();

# 对象的创建和生命周期
  new关键字创建一个对象的动态实例  
  什么时刻清理对象：  
  - c++：程序员指定
  - Java：垃圾收集器自动清理

# 异常处理
  异常：错误之处“抛出”的对象，根据错误类型被异常处理程序“捕获”  
  单独运行路径，不影响正常执行的代码  
  异常提供一种恢复办法，有机会修正问题而继续运行，而非结束程序  

# 通过引用操作对象
  创建引用时需要连接到对象（即初始化）  
  String s = "abc";  
  
# 数据保存在哪里
  1. 寄存器（register）：存储在CPU中
  2. 栈（stack）：存储在随机存取存储器（random-access memory, RAM）
  3. 堆（heap）:存储在通用内存池中
  4. 常量（constant）：存储在只读存储器中（read-only memory, ROM）
  5. 非RAM存储（non-RAM storage）：
     RAM对象：序列化对象（字节流）/持久化对象               使用JDBC/Hibernate ——>                 其他形式：磁盘中

# 基本类型：保存在虚拟机栈
  | 基本类型 | 大小 | 最小值 | 最大值 | 包装类 |  
  | --- | --- | --- | --- | --- |  
  | boolean | —— | —— | —— | Boolean |  
  | char | 16位 | Unicode 0 \ u0000 | 65535 \uffff | Character |  
  | byte | 8位 | -2^7 | +2^7-1 | Byte |  
  | short | 16位 | -2^15 | +2^15-1 | Short |  
  | int | 32位 | -2^31 | +2^31-1 | Integer |  
  | long | 64位 | -2^63 | +2^63-1 | Long |  
  | float | 32位 | IEEE754 | IEEE754 | Float |  
  | double | 64位 | IEEE754 | IEEE754 | Double |  
  | void | —— | —— | —— | Void |  

  包装类（wrapper class）：将基本类型包装为堆上的非原始对象，可作为Object的子类对象保存在集合中。  
  “自动装箱/拆箱”机制：  
  - Character ch = 'x';           //自动装箱
  - char c = ch;                  //自动拆箱

  - BigInteger：支持任意精度整数                  //底层是 多个32位int组成的数组
  - BigDecimal：支持任意精度定点数                //底层是 二进制 通过字符串 转为 十进制 来运算

# Java的数组：一定被初始化，无法访问数组边界外的内存（报错）
  若数组用于放置对象，则数组内存放的是引用，自动初始化为null  

# 注释
  多行注释：/* 注释文字 */  
  单行注释：// 注释文字  

# Java对象作用域：对象在作用域结束后依然存在，有GC释放内存

# 方法、参数、返回值
  ```
  访问修饰符 ReturnType methodName(/* 参数列表 */)｛
    //方法体
    return ...
  }
  ```
  - ReturnType：返回类型
  - methodName：方法名

# 名称可见性
  反转域名作为包（package）名，确保所有文件都有对应的命名空间  

# 使用其他组件
  import语句：导入指定位置的包：放置各种类的库（Java的一切活动都在其中）  

# static关键字：将字段/方法与 类 绑定，不在依赖对象
  成为类字段、类方法：  
  1. 只适用于类成员字段/方法
  2. 任何方法中的局部变量/方法不能用static

  - static修饰后，无需新建对象， “类名.xxx”即可调用static字段/方法
  - 多个对象修改/调用的是同一个static字段/方法（内存共享）
  - 非static修饰，只能由对象实例调用

  定义main方法作为程序入口，static必不可少  
  ```java
  public static void main(String[] args){

  }
  ```
  - public：可被外部程序调用  
  - static：无需对象，即可调用
  - args：必要参数：Java编译器强制传递，用于获取控制台的输入

# 编程风格
  “驼峰命名法”（Camel-Case）  
  类名：首字母大写，类名每个词首字母大写  
  方法/字段/对象名：首字母小写，除第一个词外的每个词首字母大写

