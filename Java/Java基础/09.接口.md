接口和抽象类提供了一种更结构化的方式分离接口与实现  

# 抽象类和抽象方法
  抽象类（抽象基类）：包含抽象方法的类，用抽象方法操作一组子类。  
  抽象方法：通用接口，抽象出多个实现类的共同之处，多个实现类用不同方式来表示这个接口。  
  ```java 
  abstract class Basic{                   //抽象类
    abstract void unimplemented();        //抽象方法，没有方法体
  }
  ```
  abstract关键字表明声明的是抽象的类/方法  

  1. 包含抽象方法的类必须定义为抽象类，否则编译器报错，防止无用。
  2. 用抽象类创建对象，编译器会报错。一个子类继承抽象类，想要生成子类对象，则必须为基类的所有抽象方法提供定义。  
     否则子类仍然是抽象类。  
  3. 抽象类可以不包含抽象方法。一个类不想被实例化，即可定义为抽象类。

  “@Override”注解不用也不影响运行，但强烈建议使用，因为这会给程序员明显提示：这是重写方法！  

  - 接口的方案法默认为public，也只允许public方法，抽象类的方法权限与普通类一样（private，protected，public）
  - 但抽象类不允许private abstract方法，因为private不允许子类定义抽象方法，子类永远不能实例化（非法）

# 接口定义
  使用interface关键字定义接口。与创建类一样，public interface所在文件名需要与接口一致。否则就是包访问权限。  
  - Java 8之前：接口只有抽象方法，全部abstract，所以方法无需添加abstract关键字
  - Java 8：允许默认方法和静态方法，也允许字段（隐式static和final）

  - 接口：类的抽象，例如Runnable, Serializable
  - 抽象类：类的模版：例：String

  设计符合特定接口（或多个接口）的类，使用 implements 关键字  
  表示我要定义接口是如何工作的。  

  接口的方法默认隐式public，所以类在实现时，重写方法需定义public，不能是其他访问修饰符（继承期间不能降低访问性）  
  同样建议使用“Override”注释  

## 默认方法
  使用default关键字，允许接口的方法创建一个方法体  
  实现了该接口的类可以在不定义该方法的情况下正常调用该方法  
  向接口中新添方法（默认方法），不会破坏已使用该接口的代码（不强制要求可实例化类重写该方法）  

## 多重继承
  Java是单继承的，只能继承一个类（或抽象类）  
  
  由于接口允许默认方法，多实现意味着可以做到类似多继承的效果  
  但接口不允许包含字段（static final字段除外），所以只能实现方法多继承，而不能实现状态的多继承
  
  组合多个来源的接口实现，需要方法签名（方法名+参数列表）不同，否则引发编译器报错  
  `class Bob implements Bob1, Bob2{...}`  
  Bob1和Bob2中存在方法签名相同时，需重写该方法。  

## 接口中的静态方法
  允许接口里包含逻辑上属于它的应用程序  
  通常是像runOps(), show()这类通用工具方法  

  ```java
  public interface Operation{
    void execute();
    static void runOps(Operation... ops){      //“Operation... ops”: Java可变参数列表，runOps()体现设计模式：模板方法模式（Template Method）
      for(Operation op : ops)
        op.execute();
    }
    static void show(String msg){
      System.out.println(msg);
    }
  }
  ```

  创建Operation的4种方式，例：  
  ```java
  Operation.runOps(
    new Heat(),                              //常规类，实现Operation接口
    new Operaton(){                          //匿名类，直接给出新建类体,而不是创建新的class
      public void execute(){
        Operation.show("Hammer");
      }
    },
    twist::execute;                          //已经实例的twist对象  引用方法（方法引用使用'::'）
    ()->Operation.show("Anneal")             //Lambda表达式
  );
  ```

# 抽象类与接口
  | 特性 | 接口 | 抽象类 |  
  | --- | --- | --- |  
  | 创建新类 | 可以在新类中组合多个接口 | 只能继承一个抽象类 |  
  | 状态 | 不能包含字段（static final字段除外，但它们不支持对象状态） | 可以包含字段，非抽象方法可以引用这些字段 |  
  | 默认方法与抽象方法 | 默认方法不需要在子类型里实现 | 抽象方法必须在子类型里实现 |  
  | 构造器 | 不能有构造器 | 可以有构造器 |  
  | 访问权限控制 | 隐式的public | 任意访问修饰符 |  

  抽象类为什么可以有private 字段/方法？  
  抽象类可以有自己方法实现public/protected g()，自己方法的实现可能会用到自己的私有变量a和私有方法f()。    
  具体子类能够调用抽象类的g(), 但不能直接调用a和f()。  

  经验法则：  
  1. 能用常规类解决问题，就不要用抽象类和接口
  2. 能用接口，就不要用抽象类

  接口与常规类的耦合性更低，接口的方法可应用到大范围的类上，但抽象类仍然是类，只能应用到子类  

# 完全解耦
  根据多态和“上下转型”，我们可以创建设计模式：策略模式（Strategy Pattern）  
  创建一个接口/类：P（方法参数均是基类/Object，以便运行时绑定具体子类的重写方法）  
  用其中的方法来操纵一组类：A和A的子类（这组类需要实现P的多行为方法）  
  实现P根据不同具体子类参数类型（多次调用），产生不同行为————策略模式  

  要实现这种策略设计模式：  
  1. 被操纵的类可修改：新建一个更接近被操纵类的P的子接口P1，A和A的子类需要实现P1。    //直接修改A及A的子类，让A及子类实现P  
     P1中可添加新的抽象方法、static final字段、static方法（甚至static main（））  
     使用A的子类作为参数调用多行为方法  
  2. 被操纵的类不可修改：使用设计模式：适配器模式（Adapter Pattern），新建适配器类T（实现P）————采用委托（组合A）  
     并重写P的多行为方法，与基类A达到类型匹配。  
     使用T（包含A的子类）作为参数调用多行为方法。A的子类被委托到T，T是一种特殊的A  

# 组合多个接口（实现类可“向上转型为全部的接口类型”）
  继承A，实现B, C, D，同时出现时，继承在前。例：  
  `Class T extends A implements B, C, D`  

  1. 若接口的抽象方法在实现类A中已实现，则T无需重写实现。
  2. T可以“向上转型”为A, B, C, D。
  3. 使用接口可以防止实例化。
  4. 在不定义方法和实例变量下，应使用接口，而非抽象类。基类首先考虑设计成接口。

# 








