接口和抽象类提供了一种更结构化的方式分离接口与实现  

# 抽象类和抽象方法
  抽象类（抽象基类）：包含抽象方法的类，用抽象方法操作一组子类。  
  抽象方法：通用接口，抽象出多个实现类的共同之处，多个实现类用不同方式来表示这个接口。  
  ```java 
  abstract class Basic{                   //抽象类
    abstract void unimplemented();        //抽象方法，没有方法体
  }
  ```
  abstract关键字表明声明的是抽象的类/方法  

  1. 包含抽象方法的类必须定义为抽象类，否则编译器报错，防止无用。
  2. 用抽象类创建对象，编译器会报错。一个子类继承抽象类，想要生成子类对象，则必须为基类的所有抽象方法提供定义。  
     否则子类仍然是抽象类。  
  3. 抽象类可以不包含抽象方法。一个类不想被实例化，即可定义为抽象类。

  “@Override”注解不用也不影响运行，但强烈建议使用，因为这会给程序员明显提示：这是重写方法！  

  - 接口的方案法默认为public，也只允许public方法（JDK9允许private方法，自动隐式default修饰），抽象类的方法权限与普通类一样（private，protected，public）
  - 但抽象类不允许private abstract方法，因为private不允许子类定义抽象方法，子类永远不能实例化（非法）

# 接口定义
  使用interface关键字定义接口。与创建类一样，public interface所在文件名需要与接口一致。否则就是包访问权限。  
  - Java 8之前：接口只有抽象方法，全部abstract，所以方法无需添加abstract关键字
  - Java 8：允许默认方法和静态方法，也允许字段（隐式static和final）

  - 接口：类的抽象，例如Runnable, Serializable
  - 抽象类：类的模版：例：String

  设计符合特定接口（或多个接口）的类，使用 implements 关键字  
  表示我要定义接口是如何工作的。  

  接口的方法默认隐式public，所以类在实现时，重写方法需定义public，不能是其他访问修饰符（继承期间不能降低访问性）  
  同样建议使用“Override”注释  

## 默认方法
  使用default关键字，允许接口的方法创建一个方法体  
  实现了该接口的类可以在不定义该方法的情况下正常调用该方法  
  向接口中新添方法（默认方法），不会破坏已使用该接口的代码（不强制要求可实例化类重写该方法）  

## 多重继承
  Java是单继承的，只能继承一个类（或抽象类）  
  
  由于接口允许默认方法，多实现意味着可以做到类似多继承的效果  
  但接口不允许包含字段（static final字段除外），所以只能实现方法多继承，而不能实现状态的多继承
  
  组合多个来源的接口实现，需要方法签名（方法名+参数列表）不同，否则引发编译器报错  
  `class Bob implements Bob1, Bob2{...}`  
  Bob1和Bob2中存在方法签名相同的方法时，需重写该方法。  

## 接口中的静态方法
  允许接口里包含逻辑上属于它的应用程序  
  通常是像runOps(), show()这类通用工具方法  

  ```java
  public interface Operation{
    void execute();
    static void runOps(Operation... ops){      //“Operation... ops”: Java可变参数列表，runOps()体现设计模式：模板方法模式（Template Method）
      for(Operation op : ops)
        op.execute();
    }
    static void show(String msg){
      System.out.println(msg);
    }
  }
  ```

  创建Operation的4种方式，例：  
  ```java
  Operation.runOps(
    new Heat(),                              //常规类，实现Operation接口
    new Operaton(){                          //匿名类，直接给出新建类体,而不是创建新的class
      public void execute(){
        Operation.show("Hammer");
      }
    },
    twist::execute;                          //方法引用，已经实例的twist对象引用方法（方法引用使用'::'）
    ()->Operation.show("Anneal")             //Lambda表达式
  );
  ```

# 抽象类与接口
  | 特性 | 接口 | 抽象类 |  
  | --- | --- | --- |  
  | 创建新类 | 可以在新类中组合多个接口 | 只能继承一个抽象类 |  
  | 状态 | 不能包含字段（static final字段除外，但它们不支持对象状态） | 可以包含字段，非抽象方法可以引用这些字段 |  
  | 默认方法与抽象方法 | 默认方法不需要在子类型里实现 | 抽象方法必须在子类型里实现 |  
  | 构造器 | 不能有构造器 | 可以有构造器 |  
  | 访问权限控制 | 隐式的public | 任意访问修饰符 |  

  抽象类为什么可以有private 字段/方法？  
  抽象类可以有自己方法实现public/protected g()，自己方法的实现可能会用到自己的私有变量a和私有方法f()。    
  具体子类能够调用抽象类的g(), 但不能直接调用a和f()。  

  经验法则：  
  1. 能用常规类解决问题，就不要用抽象类和接口
  2. 能用接口，就不要用抽象类

  接口与常规类的耦合性更低，接口的方法可应用到大范围的类上，但抽象类仍然是类，只能应用到子类  

# 完全解耦
  根据多态和“上下转型”，我们可以创建设计模式：策略模式（Strategy Pattern）  
  创建一个接口/类：P（方法参数均是基类/Object，以便运行时绑定具体子类的重写方法）  
  用其中的方法来操纵一组类：A和A的子类（这组类需要实现P的多行为方法）  
  实现P根据不同具体子类参数类型（多次调用），产生不同行为————策略模式  

  要实现这种策略设计模式：  
  1. 被操纵的类可修改：新建一个更接近被操纵类的P的子接口P1，A和A的子类需要实现P1。    //直接修改A及A的子类，让A及子类实现P  
     P1中可添加新的抽象方法、static final字段、static方法（甚至static main（））  
     使用A的子类作为参数调用多行为方法  
  2. 被操纵的类不可修改：使用设计模式：适配器模式（Adapter Pattern），新建适配器类T（实现P）————采用委托（组合A）  
     并重写P的多行为方法，与基类A达到类型匹配。  
     使用T（包含A的子类）作为参数调用多行为方法。A的子类被委托到T，T是一种特殊的A  

# 组合多个接口（实现类可“向上转型为全部的接口类型”）
  继承A，实现B, C, D，同时出现时，继承在前。例：  
  `Class T extends A implements B, C, D`  

  1. 若接口的抽象方法在实现类A中已实现，则T无需重写实现。
  2. T可以“向上转型”为A, B, C, D。
  3. 使用接口可以防止实例化。
  4. 在不定义方法和实例变量下，应使用接口，而非抽象类。基类首先考虑设计成接口。

# 通过继承扩展接口（接口 extends 接口）
  - interface p extends p1
  - interface p extends p1, p2, p3...

## 组合接口时的名称冲突
  1. 将接口组合在一起时，要尽力避免在不同接口中使用同名的方法  
     这会导致重写、重载、和实现混乱在一起
  2. 类中写多个接口的同名函数（签名不同），第一个是重写（文本顺序，实现了该签名所在的接口方法），其他是重载（对所在自身类）
  3. 类继承的基类中已重写接口的f()，类中写一个f()（签名不同），它属于重载（重写已存在基类中）
  4. 类继承的基类有接口的同名方法f()（只有返回类型不同）  
     此时类仍需要重写f()，因为重写方法要求返回类型不变，还需要删除/改名类已有的f()
  5. 类继承的两个接口有同名方法f()（只有返回类型不同）  
     报错：不确定返回类型，因为这两个f()既不是重写，也不是重载，非法！  
     
# 适配接口
  设计模式：策略模式 + 适配器模式  
  写一个适配器类（组合类/接口），继承多个接口，创建新的类以达到适配目标。  

# 接口中的字段
  自动隐式static和final，因此可用来创建一组常量。  
  接口的字段定义：  
  1. 右值
  2. 非常量表达式

  ```
  public interface RandVals{
    Random RAND = new Random(47);
    int RAND_INT = RAND.nextInt(10);          //非常量表达式初始化，RAND_INT不是接口的一部分，而是在第一次加载时存储在接口的静态存储区
  }
  ```

# 嵌套接口
  ```java
  class T {
    private interface P {
      void f();
    }
    private class A implements P {
      ©Override public void f() {}
    }
    public class B implements P {
      ©Override public void f() {}
    }
    public P getP() { return new B(); }
    private P dRef;
    public void receiveP(P d) {
      dRef = d;
      dRef.f();
    }
  }
  ```
  ```java
  public class Nestinginterfaces {
    // private的接口只能在定义的类里实现:
    //- class Dlmp implements A.D (
    //- public void f() {}
    //- }

    public static void main(String[] args) {
      t a = new T();
      //无法得到T.P：
      //- T.P ad = a.getP();
      //无法得到T.B：
      //- T.B di2 = a.getP();
      //无法访问该接口的方法
      //- T.getP() .f();
      //另一个A才能处理getDO：
      T a2 = new T();
      a2.receiveP(a.getP());
    }
  }
  ```
  - 类T中嵌套接口：接口可以public, protected, private  
  - 类T中定义的private interface P 可以在类T中定义的 private class A 实现，也可在类T中定义的 public class B 实现，但不能在类T外实现    
  - T对象在其他类中，不允许通过getP()获得B对象后向上转型为P，也就是不能直接调用获得类型P的方法 - getP()  
  - 除非将T对象获得P的方法作参数传入到另一个T对象的方法（receiver P（））中  

  ```java
  interface E {
    interface G {
      void f();
    }
    //多余的public：
    public interface H {
      void f();
    }
    void g();
    //接口内不能用private
    //- private interface I {}
  }
  ```
  ```java
  public class Nestinginterfaces {
    class EImp implements E {
      @Override public void g() {}
    }
    class EGImp implements E.G {
      @Override public void f() {}
    }
    class EImp2 implements E {
      @Override public void g() {}
      class EG implements E.G {
        @Override public void f() {}
      }
    }
  }
  ```
  接口P中嵌套接口：接口内部的所有接口都是隐式public的，不能设为private
  1. 实现一个接口时，不需要实现接口内部嵌套的接口
  2. private接口只能嵌套在类A中，不能在类A的内部定义类之外实现

# 接口和工厂
  设计模式：工厂方法模式（Factory Method Pattern），详见：  
  [Java/Java高阶/01. 23种设计模式/01.创建型模式/01.工厂方法模式（Factory Method Pattern）.md](https://github.com/jinlemon7/learning_Display/blob/dc8f7cc4f4b51a1e792749acadc0f562bb738166/Java/Java%E9%AB%98%E9%98%B6/01.%2023%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/01.%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%EF%BC%88Factory%20Method%20Pattern%EF%BC%89.md)  
  
  工厂方法模式可看作策略模式的一种：将对象的创建行为（调用构造器）独立出来并抽象为工厂接口的getProduct()  

# 新特性：接口的private方法
  default和static引入接口，可以让程序员在接口中编写方法的代码  
  但有时希望一些方法是private的。  
  JDK9的特性：允许接口内private方法  
  ```java
  Interface JDK9{
    private void fd(){...}            //不需要default，private自动隐式将方法default
    private static void fs(){...}
  }
  ```

# 新特性：密封类和密封接口
  关键字sealed ————密封，接口/基类限制自己能派生哪些类
  1. 可密封类、接口、抽象类
  2. 未在permits子句列出的子类创建时，若继承类，则编译器报错
  3. 所有子类都定义在同一个文件中，则不需要permits子类
  4. sealed类的子类只能通过下面的修饰符来定义  
     final：不允许有进一步的子类  
     sealed：允许有一组密封子类  
     non-sealed：允许子类继承，放开限制  
  5. sealed类必须至少有一个子类
  6. JDK的record可用作密封实现，record隐式final，前面不需要加final
  7. 可用ClassName/InterfaceName.class.getPermittedSubclasses()来发现允许的子类
     ```java
     var p = A.class.getPermittedSubclasses();
     System.out.println(p.getSimpleName());
     ```
  ```java
  sealed Interface Base permits D1, D2{...}
  final class D1 implements Base{}
  record D2(String s) implements Base{}
  ```

# 总结
  错误：将一个类总是用“接口 + 工厂”代替。  
  这是一种过早的设计优化，中间层级带来额外复杂性、额外的理解时间成本。  
  接口应该是必要时用来重构的东西，而非提前“以防万一”。  

  指导方针： 优先使用类而非接口。接口很容易被滥用。  
  
