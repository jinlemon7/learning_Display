又名动态绑定/后期绑定/运行时绑定  
访问控制通过将细节设private实现接口与实现的分离。  
多态将“做什么”和“怎么做”通过类型解耦，实现接口和实现的分离。  
多态：调用基类方法时  使用后期绑定机制自动替换为  调用子类重写方法  

# 再论向上转型
  通过“向上转型”，子类对象可以作为一个基类参数，适用于有基类参数的方法。  

## 忘记子类对象的类型
  编写以基类为参数的方法f()，从而不用担心特定的子类。好处：  
  1. 编写一个适用于所有子类的调用方法f()，不需要多次重载方法f()，减少代码量
  2. 较少代码负载度，便于管理

# 难点：方法的参数是基类，执行方法时如何调用子类的重写方法？
## 方法调用绑定
  绑定：将一个方法调用和方法体关联起来  
  - 前期绑定：程序运行前绑定。例：c语言
  - 后期绑定：发生在运行时，基于对象的类型，由后期绑定机制进行绑定。例：Java，除了static或final方法不需要，已前期绑定。

## 后期绑定如何正确绑定
  后期绑定由编译器自动发生，包括是否采用后期绑定。  
  不需要程序员给编译器任何额外的编译时信息。  
  向上转型非常简单：  
  ```java
  graph TD;
  Circle --> Shape;
  Square --> Shape;
  Triangle --> Shape;
  ```

  Shape s = new Circle();  
  后期绑定保证s调用方法在Circle中有重写方法时，使用重写方法。  

## 可扩展性
  无论是添加新的子类，还是基类/子类添加新方法，已有的只与基类接口通信的调用方法，不需要任何改变来适应这些新变化。  

  新子类仍然适用于这些方法！当然你可以根据需要重写定制基类的方法体（被只与基类接口通信的调用方法所调用的）  

  多态是程序员“将变化的事物与不变的事物分离”的一项重要技术。  

## 陷阱：“重写”private方法
  基类的private方法f()，在子类中存在一个同名、同参数列表、同返回类型的方法。  
  该方法并不是基类f()的重写方法，因为private不允许子类访问，隐式final不允许被重写，所以该方法为子类的一个新方法。  
  该方法前如果使用“@Override”，将会报错“方法未重写或请在基类实现该方法”。  
  
  这种情况下，“向上转型”的对象除了重写方法使用子类的，其他的方法和字段都用基类的。  
  所以“向上转型”对象使用f()将调用基类的f()。  

## 陷阱：字段访问和静态方法是多态的
  一个类A，public字段field，A的子类B有一个public字段field。  
  `A a = new B();`    a.field：直接访问一个字段，会被编译器解析（运行前绑定），不是多态的。  
  a “向上转型”为类型A，所以a.field返回的是A的field。  
  而 B b =  B()中要获得A的field，则需要使用super.field  

  静态方法与类关联，而非与对象关联，也不是多态的。  

# 构造器和多态
## 继承与清理
  除了GC自动垃圾收集，还需要手动清理，则需要给类创建一个dispose()方法  
  在多层次继承体系结构中，dispose()方法的清理顺序与内存对象初始化顺序相反。  

  - 对于字段：清理顺序与声明顺序相反
  - 对于类：清理顺序与继承顺序相反：先执行子类清理，在执行基类清理(子类在清理时可能会调用基类中的一些方法)

## 构造器内部应禁止调用多态方法
  多层次继承体系结构中，若基类构造器调用多态方法（被重写方法，动态方法），会用到被重写后的定义。  
  因为这个被重写方法在子类对象完全构造之前被调用，产生逻辑上的错误。（违背程序员期望）  

  为对象分配的存储空间会优化被初始化为二进制0，再进行任何构造器方法和其他方法。  

  所以不要在构造器中调用此类中的任何方法（static/final/private方法除外，它们是运行前绑定，不能被重写）

# 协变返回类型
  子类中的重写方法的返回值可以是基类被重写方法返回类型的子类型。  
  ```mermaid
  graph TD;
  类B --> 类A;
  返回类型D --> 返回类型C;
  ```
  A.f()返回C，B的重写f()可返回D。  

# 用继承进行设计
  最好先选择组合，组合不会强制使用继承层次结构，更加灵活。  
  支持动态选择类型（设计模式：状态模式：运行时将引用指向其他对象来更改类型），继承则要求编译时就明确类型。  

  PS：通用准则“使用继承表达行为差异，使用字段表达状态差异”  
  即使用继承得到两个不同子类表达f()的差异  
  使用组合允许引用更换类型，使状态发改变，状态改变导致行为改变。  

## 替换和扩展
  替换（“is-a”关系）：子类接口不比基类多，与基类接口完全一致  
  扩展（“is-like-a”关系）：子类接口比基类多，扩展了更多方法  

  扩展的缺点：“向上转型”为基类对象无法调用子类扩展的方法，此时需要重新获取类型信息。  

## 向下转型与反射
  向下转型：在继承层次结构中向下移动，重新获取类型信息。  
  Java中，每个转型（使用括号"()"强制转型）都会被检查。    ————向下转型需要强制类型转换  
  这种无需为异常编写任何特殊代码，在运行时检查类型的行为是Java反射（reflection）的一部分。  

# 总结
  多态：不同的形式  
  面向对象编程：  
  1. 基类的相同接口
  2. 使用基类接口的不同形式：动态绑定方法的不同版本
