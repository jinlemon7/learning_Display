字符串操作可以说是计算机编程中最常见的行为之一  

# 不可变的字符串
  String类的对象是不可变的。  
  该类中每个看起来似乎会修改String值的方法,实际上都创建并返回了一个全新的String对象.该对象包含了修改的内容  
  而原始的String则保持不变。  
  ```java
  public class Immutable (
    public static String upcase(String s) {
      return s.toUpperCase();
    }
    public static void main(String[] args) {
      String q = "howdy";
      System.out.printin(q); // howdy
      String qq = upcase(q);
      System.out.println(qq); // HOWDY
      System.out.println(q); // howdy
    }
  }
  ```
  - 当q被传递给upcase()时，实际上传递的是q对象引用(内存地址)的一个副本
  - upcase()返回执行的结果：一个指向新字符串的引用。我们通过将原来字符串的每个字符设置为大写，从而得到了这个新字符串
  - 传递进来的原始字符串对象则原封不动地保留了下来

  对于代码的读者来说，参数一般是给方法提供信息的，而不是要被修改的   
  这种不变性是一个重要的保证，因为它使代码更易于编写和理解  

# 重载 + 与 StringBuilder
  String对象是不可变的，因此我们可以根据需要为特定的String设置多个别名。  
  因为String是只读的，指向它的任何引用都不可能改变它的值，所以引用之间不会相互影响  

  不变性可能会带来效率问题：一个典型的例子是操作符+  
  应用于String的+和+= 是Java中仅有的被重载的操作符，Java不允许程序员重载其他操作符  
  此Java设计者认为操作符重载是一个“糟糕”的特性，不应该包含在Java中  
  Java中使用操作符重载会比C++中容易很多  

  +操作符可以用来拼接字符串：  
  它需要创建许多String对象来组合这个新的String,这样就有了一堆String类型的中间对象需要被垃圾收集  

  用JDK自带的javap 工具反编译上述代码.命令如下  
  `javap -c Concatenation`      -c标志表示生成JVM字节码  
  你或许会认为可以随意使用String,反正编译器会对字符串的使用进行优化。  
  在这样想之前，先让我们更仔细地看看编译器在做什么  
  示例：直接使用String,以及手动使用StringBuilder编码：  
  ```java
  public class WhitherStringBuilder {
    public String implicit(String[] fields) {
      String result =""；
      for(String field : fields) (
        result += field;
      }
      return result;
    }
    public String explicit(String[] fields) {
      StringBuilder result = new StringBuilder();
      for(String field : fields) {
        result.append(field);
      )
      return result.toString();
    }
  }
  ```
  运行javap -c WhitherStringBuilde:  
  首先是implicit()方法：  
  ```shell
  12:  iload              5
  25:  new                #3   // StringBuilder
  29:  invokespecial      #4   // StringBuilder."<init>"
  33:  invokevirtual      #5   // StringBuilder.append:(String)
  38:  invokevirtual      #5   // StringBuilder.append:(String;)
  41： invokevirtual      #6   // StringBuilder.toString:()
  48:  goto               12
  ```
  - StringBuilder构造发生在这个循环的内部.这意味着每次循环时 .你都会得到一个新的StringBuilder 对象

  explicit()的字节码:
  ```shell
  0: new             #3 // StringBuilder
  4: invokespecial   #4 // StringBuilder."<init>"
  17: iload          5
  33: invokevirtual  #5 // StringBuilder.append:(String)
  40: goto           17
  ```
  - 不仅循环的代码更短更简单，而且该方法只创建了一个StringBuilder对象
  - 显式使用StringBuilder时，如果知道字符串可能有多大，你还可以预先分配它的大小，这样就不会不断地重新分配缓冲区了

  当创建toString()方法时，如果操作很简单，通常可以依赖编译器。
  如果涉及循环，并且对性能也有一定要求，那就需要在toString()中显式使用StringBuilder了；  
  ```java
  public class UsingStringBuilder {
    public static String stringl() {
      Random rand = new Random(47);
      StringBuilder result = new StringBuilder("[")；
      for(int i = 0; i < 25; i++) (
        result.append(rand.nextlnt(lOO));
        result.append(", ")；
      }
      result.delete(result.length() -2, result.length());
      result.append("]");
      return result.toString();
    }
    public static String string2() {
      String result = new Random(47);
      .ints(25, 0, 100)
      .mapToObj(Integer::toString)
      .collect(Collectors.joining(","));
      return "[" + result + "]";
    }
    public static void main(String[] args) {
      System.out.println(stringl());
      System.out.println(string2());
    }
  }
  ```
  ```java
  /*输出：
  [58, 55, 93, 61, 61, 29, 68, 0, 22, 7, 88, 28, 51, 89,
  9, 78, 98, 61, 20, 58, 16, 4G, 11, 22, 4]
  [58, 55, 93, 61, 61, 29, 68, 0, 22, 7, 88, 28, 51, 89,
  9, 78, 98, 61, 20, 58, 16, 40, 11, 22, 4]
  */
  ```
  - 在stringl()中，最终的结果是用append()语句对每一部分逬行拼接而成的
  - StringBuilder 提供了丰富而全面的方法,包括 insert()、replace()、substring()甚至reverse().但我们通常使用的只有append()和toString()
  - string2()使用T Stream,生成的代码更加赏心悦目 实际上,Collectors.joining()内部使用StringBuilder实现，所以使用这种方式不会有任何损失！
  - StringBuilder是在Java 5中引入的。在此之前,Java使用StringBuffer.它是线程安全的，因此成本也明显更高。使用StringBuilder进行字符串操作会更快

# 无意识的递归
  Java的标准集合最终也是从Object继承而来的,所以它们也包含了一个toString()方法  
  这个方法在集合中被重写,这样它生成的结果字符串就能表示容器自身.以及该容器持有的所有对象  

  ```java
  public class InfiniteRecursion {
    @Override public String toString() {
      return
        "InfiniteRecursion address: " + this + "\n";    //[1]
    }
    public static void main(String[] args) {
      Stream.generate(InfiniteRecursion::new)
      .limit(10)
      .forEach(System.out::println);
    }
  }
  ```
  - 如果创建一个InfiniteRecursion对象，然后将其打印出来，你会得到一个很长的异常栈
  - [1]之所以这样，是因为字符串的自动类型转换。编译器看到一个String后面跟着一个+和一个不是String的东西，它就试图将这个
this转换为一个String。这个转换是通过调用toString()来完成的，而这样就产生了一个递归调用
  - 如果真的想打印对象的地址，可以直接调用Object的toString()方法来实现。因此,这里不应该使用this,而应该使super.toString()

# 对字符串的操作
  下面是可操作String对象的大多数方法：  
  | 方法 | 参数，重载 | 途 用 |  
  | --- | --- | --- |  
  | 构造器 | 重载版本包括：默认构造器，参数分别为 String、StringBuilder、StringBuffer、char数组、byte数组的构造器 | 创建String对象 |  
  | length() | | String中的Unicode代码单元（code units）个数 |  
  | charAt() | int索引 | String中某个位置的char |  
  | getChars(), getBytes() | 要复制的开始和结束索引.要复制到的目标数组.以及目标数组的起始索引 | 将char或byte复制到外部数组中 |  
  | toCharArray() | | 生成一个char[].包含了String中的所有字符 |  
  | equals(), equalsIgnoreCase() | 要与之比较的String | 对两个String的内容逬行相等性检查，如果内容相等,则返回true |  
  | compareTo() compareToIgnoreCase() | 要与之比较的String | 按字典順序比较String的内容.结果可能为负数、零或正数。注意大写和小与不相等 |  
  | contains() | 要査找的CharSequence | 如果参数包含在String中，则结果为true |  
  | contentEquals() | 用来比较的CharSequence或StringBuffer | 如果该String与参数的内容完全匹配.则结果为true |  
  | isEmpty() | | 返回一个boolean值，表明该String的长度是否为0 |  
  | regionMatches() | 该String的索引偏移量.参数String和它的索引偏移量。以及要比较的长度。重載方法添加了 “忽略大小写”功能 | 返回一个boolean值.表明该区域是否匹配 |  
  | startsWith() | 该字符串可能的前缀String。重载方法在参数列表中増加了偏移量 | 返回一个boolean值.表明该String是否以参数字符串开头 |  
  | endsWith() | 该字符串可能的后级String | 返回一个boolean值.表明参数字符串是否为后缀 |  
  | indexOf() lastIndexOf() | 重载版本包括:char、char和起始索引、String、String和起始索引 | 如果在此String中找不到该参数，則返回-1。否则返回参数开始的索引，lastIndexOf()則从后向前捜索 |  
  | matches() | 一个正则表达式 | 返回一个boolean值，表明此String是否与给定的正則表达式匹配 |  
  | split() | 一个正则表达式。可选的第二个参数是要进行的最大分隔数 | 根据正则表达式拆分String,返回结果数组 |  
  | join()（在 Java 8 中引入） | 分隔符以及要合并的元素，通过将元素与分隔符连接在一起.生成一个新的String | 将片段合并成一个由分隔符分隔的新String |  
  | subString()(还有subSequence()) | 重载版本包括：起始索引；起始索引+结束索引 | 返回一个String对象,包含了指定的字符集合 |  
  | concat() | 要拼接的String | 返回一个新的String对象.其中包含了原始String的字符.后跟参数的字符 |  
  | replace() | 要搜索的旧字符.以及用来替换的新字符。也可以用来在CharSequence之间逬行替换 | 返回一个替换后的新String对象，如果没有匹配.则使用旧的String |  
  | replaceFirst() | 用来进行捜索的正则表达式.以及用来替换的新String | 返回替换后的新String对象 |  
  | replaceAll() | 用来进行搜索的正则表达式.以及用来替换的新String | 返回替换  后的String对象 |  
  | toLowerCase(), toUpperCase() | | 返回一个新的String对象.所有字母的大小写都发生了相应的变化，如果没有任何更改.则使用旧的String |  
  | trim() | | 返回一个删除了两端空白字符的新String对象。如果没有任何更改，则使用旧的String |  
  | valueOf()(静态) | 重载版本包括：Object、char[]、char[]和偏移量还有计数、boolean、char、int、long、float、double | 返回一个String,里面包含了参数的字符表示 |  
  | intern() | | 为每个唯一的字符序列生成一个独一无二的String引用 |  
  | format() | 格式字符串（内含要被替换的格式说明符），参数 | 生成格式化后的结果String |  
  - 当需要更改内容时，每个String方法都会小心地返回一个新的String对象

# 格式化输出

## System.out.printf()
  printf()方法没有使用重载的+操作符来拼接引号内的文本和变量, 而是使用特殊的占位符来表示数据的位置  
  `System.out.printf("Row 1: [%d %f]%n, x, y);`  
  这些占位符称为格式说明符  

## System.out.format()
  Java 5引入的format()方法可用于PrintStream或PrintWriter对象  
  如果你比较怀旧的话，也可以直接使用piintf()方法.它用起来很方便.内部直接调用了 format()来实现  
  ```java
  int x = 5;
  double y = 5.332542;
  //新的方式：
  System.out.format("Row 1: [%d %f]%n", x, y);
  //或者:
  System.out.printf("Row 1: [%d %f]%n", x, y);
  ```
  ```java
  /*输出
  Row 1: [5 5.332542]
  Row 1: [5 5.332542]
  */
  ```
  - format()和printf()是等价的。它们都只需要一个格式化字符串.后面跟着参数.其中每个参数都对应一个格式说明符
  - String类也有一个静态的format()方法，它会产生一个格式化字符串

## Formatter 类
  Java中所有的格式化功能都由java.util包里的Formatter类处理。你可以将Formatter视为一个转换器，将格式化字符串和数据转换为想要的结果  
  ```java
  public class Turtle {
    private String name;
    private Formatter f;
    public Turtle(String name. Formatter f) {
      this.name = name;
      this.f = f;
    }
    public void move(int x, int y) {
      f.format("%s The Turtle is at (%d,%d)%n",
      name, x, y):
    }
    public static void main(String[] args) {
      Printstream outAlias = System.out;
      Turtle tommy = new Turtle("Tommy",
        new Formatter(System.out));
      Turtle terry = new Turtle("Terry",
        new Formatter(outAlias));
      tommy.move(0,0):
      terry.move(4,8);
      tommy.move(3,4);
      terry.move(2,5);
      tommy.move(3,3)；
      terry.move(3,3);
    }
  }
  ```
  ```java
  /*输出
  Tommy The Turtle is at (0,0)
  Terry The Turtle is at (4,8)
  Tommy The Turtle is at (3,4)
  Terry The Turtle is at (2,5)
  Tommy The Turtle is at (3,3)
  Terry The Turtle is at (3,3)
  */
  ```
  - 构造器被重载以获取一系列的输出位置，但最有用的是PrintStream（如上例所示）Outputstream和File

## 格式说明符
  `%[argument_index$][flags][width][.precision]conversion`  
  - width控制一个字段的最小长度
  - precision（精度），用于指定字段长度的最大值  
    - 对字符串而言，precision指定了字符串的最大输出字符数
    - 对浮点数而言.precision指定了要显示的小数位数(默认为6位)，小数位数如果太多则舍入,如果太少则末尾补零
    - 如果对整数应用precision,则会抛出异常

  ```java
  public class ReceiptBuilder {
    private double total = 0;
    private Formatter f =
      new Formatter(new StringBuilder() );
    public ReceiptBuilder() {
      f.format(
        "%-15s %5d %10s%n", "Item", "Qty", "Price");
    }
  }
  ```
  ```java
  /*输出:
  Item         Qty   Price
  */
  ```
  - 将StringBuilder传递给Formatter构造器后,它就有了一个构建String的地方
  - 还可以使用构造器参数将其发送到标准输出甚至文件里  例:Formatter(System.out)

## Formatter 转换
  一些最常见的转换字符:  
  | 字符 | 效果 |  
  | --- | --- |  
  | d | 整数类型（十进制） |  
  | c | Unicode 字符 |  
  | b | Boolean 值 |  
  | s | 字符串 |  
  | f | 浮点数（十逬制） |  
  | e | 浮点数（科学记数法） |   
  | x | 整数类型（十六进制） |  
  | h | 哈希码（十六进制） |   
  | % | 字面量% |  

  转换字符b适用于boolean、char、int、double、对象和BigInteger。  
  对于boolean基本类型或Boolean对象来说，相应的结果就是true或false  
  但是，对于任何其他参数，只要参数类型不是null,结果总是true：即使是数值0  

## String.format()
  Java 5提供了String.format()方法，它是一个静态方法。  
  参数与Formatter类的format()方法完全相同，但返回一个String  
  ```java
  public class DatabaseException extends Exception {
    public DatabaseException(int transactionlD, int querylD, String message) {
      super(String.format("(t%d, q%d) %s", transactionID,
        querylD, message));
    }
    public static void main(String[] args) {
      try {
        throw new DatabaseException(3, 7, "Write failed");
      } catch(Exception e) {
        System.out.println(e);
      }
    }
  }
  ```
  ```java
  /*输出：
  DatabaseException: (t3, q7) Write failed
  */
  ```
  - String.format()的方法内部所做的，其实就是实例化一个Formatter,并将传入的参数直接传递给它
  - 和手动来做这些相比，使用这个方法通常更方便，代码也更清晰易读

### 十六进制转储工具
  ```java
  public static String format(byte[] data) {
    StringBuilder result = new StringBuilder();
    int n = 0；
    for(byte b : data) {
      if(n % 16 == 0)
        result.append(String.format ("%05X: ", n));
      result.append(String.format("%02X ", b));
    }
  }

  System.out.println(format (
    Files.readAllBytes(Paths.get (
      "build/classes/java/main/onjava/Hex.class"))));
  ```
  - Files.readAllBytes(),它以byte数组的形式返回了整个文件

# 新特性：文本块
  JDK 15最终添加了文本块(text block ),使用三引号来表示包含换行符的文本块.  
  
  """后面的换行符会被自动去掉，块中的公用缩进也会被去掉  
  如果想要保留缩进，那就移动最后的"""来产生所需的缩进  
  ```java
  public static final String NONE = """
          XXX
          YYY
          """;       //没有缩进
  public static final String TWO = """
          XXX
          YYY
        """;         //产生2个缩进
  public static final String EIGHT = """
          XXX
          YYY
  """;               //产生8个缩进
  public static void main(String(] args) {
    System.out.print(NONE);
    System.out .print(WO);
    System.out.print(EIGHT);
  }
  ```
  ```java
  /*
  XXX
  YYY
    XXX
    YYY
          XXX
          YYY
  ```

  为了支持文本块,String类里添加了一个新的formatted()方法  
  ```java
  public String toString() {
    return """
      Location: %s
      Temperature: %.2f
      """.formatted(location, temperature);
  ```
  - formatted()是一个成员方法,所以除了文本块之外，也可以把它用于普通字符串.它用起来更好、更清晰.因为可以将它直接添加到字符串的后面

# 正则表达式
  Java中的字符串操作以前委托给了String、StringBuffer和StringTokenizer类  
  与正则表达式相比，它们的功能相对简单  

  利用正则表达式，我们可以通过编程的方式，构建复杂的文本模式，从而在输入的字符串中逬行查找  

  它提供了一种紧凑且动态的语言，可以用完全通用的方式来解决字符串处理、匹配和选择，以及编辑、验证等各种问题  

## 基础
  正则表达式用通用术语来描述字符串，因此你可以这样说：“如果字符串中包含这些内容，那么它就符合我的搜索条件。”  
  例：要表示一个数前面可能有也可能没有减号，可以在减号后面加上一个问号：  
  `-?`  

  数字用\d来描述  
  `\\`的意思是“我正在插入一个正则表达式反斜杠，所以后面的字符有特殊含义”  
  要表示一个数字，你的正则表达式字符串应该是`\\d`。要插入普通的反斜杠，你可以用`\\\\` 
  换行符和制表符之类的符号只使用一个反斜杠：\n\t  (Java一开始设计的时候并没有考虑到正则表达 ,所以后来只能硬塞逬这种笨拙的语法)  

  在一个普通的字符串中你需要两个反斜杠来生成一个反斜杠：  
  ```java
  public class Backslashes {
    public static void main(String[] args) (
      String one =  "\\"；
      String two = "\\\\"；
      String three = "\\\\\\";
      System.out.println(one);
      System.out.println(two);
      System.out.println(three):
      System.out.println(one.matches("\\\\"));
      System.out.println(two.matches("\\\\\\\\"));
      System.out.println(three.matches("\\\\\\\\\\\\"));
    }
  }
  ```
  ```java
  /*输出
  \
  \\
  \\\
  true
  true
  true
  */
  ```
  - 而在正则表达式中.我们需要使用四个反斜杠才能与单个反斜杠匹配

  在表达式里表示 “前面有一个或多个”，请使用+ : 至少有一个前面的字符 
  例：`-?\\d+`

  括号可以将表达式分组，竖线 | 表示“或”操作  
  `(-|\\+)?`    
  - +字符在正则表达式中具有特殊意义.所以在表达式中必须用`\\`转义成普通字符

  String类中内置了一个很有用的正则表达式工具split()，它可以“围绕给定正则表达式的匹配项来拆分字符串”  
  ```java
  public class Splitting {
    public static String knights =
      "Then, when you have found the shrubbery, " +
      "you must cut down the mightiest tree in the " +
      "forest... with... a herring!";
    public static void split(String regex) {
      System.out.println(
        Arrays.toString(knights.split(regex)));
    }
    public static void main(String[] args) {
      split(" ");            //参数里不一定要冇正則字符
      split("\\W+");         //不是单词的字符
      split("n\\W+");        // n后而跟为一个不是単词的字符
    }
  }
  ```
  ```java
  /*输出：
  [Then,, when, you, have, found, the, shrubbery,, you,
  must, cut, down, the, mightiest, tree, in, the,
  forest...with..., a, herring!]
  [Then, when, you, have, found, the, shrubbery, you,
  must, cut, down, the, mightiest, tree, in, the, forest,
  with, a, herring]
  [The, whe, you have found the shrubbery, you must cut
  dow, the mightiest tree i, the forest...with... a
  herring!]
  */
  ```
  - 可以使用普通字符作为正则表达式————正则表达式不必包含特殊字符，如split()的第一次调用所示，它只使用空格进行了拆分
  - split()使用了`\\W`,表示非单词字符(小写版本的`\\w`表示单词字符)
  - 第三次调用的split()表示“字母n后跟一个或多个非单词字符”

  String.split()有一个重载版本可以限制拆分发生的次数  
  还可以使用正则表达式进行替换，你可以只替换第一个匹配的项，也可以全部替换 
  ```java
  public class Replacing {
    static String s = Splitting.knights;
    public static void main(String[] args) {
      System.out.println(
        s.replaceFirst("f\\w+", "located"));
      System.out.printin(
        s.replaceAll("shrubbery|tree|herring","banana"));
    }
  }
  ```
  非字符串的正则表达式具有更强大的替换工具————例如.可以调用方法来执行替换  

## 创建正则表达式
  | 构造项 | 生成结果 |  
  | --- | --- |  
  | B | 指定字符B |  
  | \xhh | 具有十六逬制値0xhh的字符 |  
  | \uhhhh | 十六逬制表示为0xhhhh的Unicode字符 |  
  | \t | 制表符（Tab） |  
  | \n | 换行 |  
  | \r | 回车 |  
  | \f | 換页 |  
  | \e | 转义(escape) |  

  一些定义某种模式字符的典型方式，以及部分预先定义好的字符模式:  
  | 符号 | 结果 |  
  | --- | --- |  
  | * | 任何字符 |  
  | [abc] | a、b或c中的任何一个字符(与a\|b\|c相同) |  
  | [^abc] | a、b或c之外的任何字符(否定) |  
  | [a-zA-Z] | a-z或A-Z的任何字符(范围) |  
  | [abc[hij]] | a、b、c、h、i、j中的任何一个字符(与a\|b\|c\|h\|i\|j相同.求并集) |  
  | [a-z&&[hij]] | h、i或j中的任何一个字符(求交集) |  
  | \s | 一个空白字符(空格 制表符 换行符 换页 回车) |  
  | \S | 非空白字符([^\s]) |  
  | \d | 数字([0-9]) |  
  | \D | 非数字([^0-9]) |  
  | \w | 一个单词字符([a-zA-Z_0-9]) |  
  | \W | 一个非单词字符([^\w]) |  

  逻辑操作符:  
  | 逻辑操作符 | 含义 | 
  | --- | --- |  
  | XY | X后跟Y |  
  | X\|Y | X或Y |  
  | (X) | 一个捕获组(capturing group)。你可以在后面的表达式中用\&i来引用笫i个捕获组 |  

  不同的边界匹配器：  
  | 边界匹配器 | 含义 |  
  | --- | --- |  
  | ^ | 行首 |  
  | $ | 行尾 |  
  | \b | 单词的边界 |  
  | \B | 非单词的边界 |  
  | \G | 前一个匹配的结束 |  

  ```java
  public class Rudolph {
    public static void main(String[] args) {
      for(String pattern : new String[]{
      "Rudolph",
      "[rR]udolph",
      "[rR][aeiou][a-z]ol.*",
      "R.*" })
      System.out.println("Rudolph".matches(pattern));
    }
  }
  ```
  ```java
  /*输出：
  true
  true
  true
  true
  */
  ```
  目标不应该是创建最难理解的正则表达式,而应该是创建能完成工作的最简单的正则表达式  

## 量词
  量词（quantifier）描述了一个正则表达式模式处理输入文本的方式:  
  | 贪婪型 | 勉强型 | 占有型 | 匹配 |  
  | --- | --- | --- | --- |  
  | X? | X?? | X?+ | x, 一个或一个都没有 |  
  | X* | X*? | X*+ | X.零个或多个 |  
  | X+ | X+? | X++ | X.一个或多个 |  
  | X{n} | X{n}? | X{n}+ | X.正好n个 | 
  | X{n,} | X{n,}? | X{n,}+ | X.至少n个 |  
  | X{n,m} | X{n,m}? | X{n,m}+ | X.至少n个但不超过m个 |  
  - 表达式X经常需要用括号括起来，才能按你希望的方式工作  

### 贪婪型
  量词默认是贪婪的,除非另有设置。贪婪型表达式会为模式找到尽可能多的匹配项,会一直持续执行，直到找到最大的匹配字符串  

### 勉强型
  用问号来指定，这个量词会匹配满足模式所需的最少字符数  

### 占有型
  目前这种类型仅适用于Java（不适用于其他语言）.这是一个更高级的功能  
  占有型量词不会保留正则表达式应用于字符串时生成的状态.因此可以防止回溯。这还可以防止正则表达式运行时失控，并使其执行更有效 

  `abc+`： 表示“ab后跟一个或多个c”  
  `(abc)+`：表示“一个或多个abc”  
  
  CharSequence接口对CharBuffer、String、StringBuffer或StringBuilder等类进行了抽象，给出了一个字符序列的通用定义：  
  ```
  interface CharSequence {
    char charAt(int i);
    int length();
    CharSequence subSequence(int start, int end);
    String toString();
  }
  ```  
  许多正则表达式操作使用了CharSequence参数  

## Pattern 和 Matcher
  通常我们会编译正则表达式对象，而不是使用功能相当有限的String。  
  只需要导入java.util.regex包.然后使用静态方法Pattern.compile()编译正则表达式即可  

  Pattern()根据传入的字符串参数来生成一个Pattern对象  
  matcher()方法接受一个字符串参数，会产生一个Matcher对象，它有一组可供选择的操作  

  ```java
  Pattern p = Pattern.compile(arg);
  Matcher m = p.matcher(args[0]);
  ```

  Pattern对象表示正则表达式的编译版本。  
  Pattern对象的matcher()方法，加上输入的字符串作为参数.来生成一个Matcher对象  

  `static boolean matches (String regex, CharSequence input)`  
  它会检查正则表达式regex与整个CharSequence类型的输入参数input是否匹配  

  Pattern里还有一个split()方法，它根据regex的匹配结果来分割字符串，并返回分割后的字符串数组  

  用Matcher对象提供的方法:  
  boolean matches()  
  boolean lookingAt()  
  boolean find()  
  boolean find(int start)  
  如果模式能匹配整个输入字符串，则matches()方法返回匹配成功；  
  如果输入字符串的起始部分与模式匹配，则lookingAt()方法返回匹配成功  

### 1. Matcher的find()
  ```java
  public class Finding {
    public static void main(String[] args) {
      Matcher m = Pattern.compile("\\w+")
        .matcher(
          "Evening is full of the linnet's wings");
      while(m.find())                  // [1]
        System.out.print(m.group() + " ")；
      System.out.println();
      int i = 0;
      while(m.find(i)) {               // [2]
        System.out.print(m.group() + "");
        i++
      }
    }
  }
  ```
  ```java
  /*输出:
  Evening is full of the linnet s wings
  Evening vening ening ning ing ng g is is s full full
  ull ll 1 of of f the the he e linnet linnet innet nnet
  net et t s s wings wings ings ngs gs s
  */
  ```
  - 模式\\w+会将输入的字符串拆分为单词
  - [1]find()就像一个迭代器，会向前遍历输入的字符串
  - [2]Find(i)可以接收一个整数参数，来表示搜索开始的字符位置————这个版本的find()会将起始搜索位置重置为参数的值，如输出所示

### 2. Matcher的group()
  分组(group)是用括号括起来的正则表达式.后续代码里可以用分组号来调用它们  
  `A(B(C))D` ： 分组0是 ABCD,分组1是BC,分组2是C  

  Matcher对象提供了一些方法，可以获取与分组相关的信息：  
  - public int groupCount()返回该匹配器模式中的分组数目：分组0不包括在此计数中
  - public String group()返回前一次匹配操作(例如find())的第0个分组(即整个匹配)
  - public String group(int i)传入前一次匹配操作期间的分组号。如果compile()匹配成功，但指定的分组未能匹配输入字符串的任何部分.则返回null
  - public int start(int group)返回在前一次匹配操作中找到的分组的起始索引
  - public int end(int group)返回在前一次匹配操作中找到的分组的最后一个字符的索引加1的值
  ```java
  public class Groups {
    public static final String POEM =
      "Twas brillig, and the slithy toves\n" +
      "Did gyre and gimble in the wabe.\n" +
      "All mimsy were the borogoves,\n" +
      "And the mome raths outgrabe.\n\n" +
      "Beware the Jabberwock, my son,\n" +
      "The jaws that bite, the claws that catch.\n" +
      "Beware the Jubjub bird, and shun\n" +
      "The frumious Bandersnatch.";  
    public static void main(String[] args) (
      Matcher m = Pattern.compile(
        "(?m)(\\S+)\\s+((\\S+)\\s+(\\S+))$")
        .matcher(POEM);
      while(m.find()) {
        for(int j = 0; j <= m.groupCount(); j++)
          System.out.print (" [" + m.group(j) + "]");
        System.out.println();
      }
    }
  }
  ```
  ```java
  /*输出:
  [the stithy toves][the][slithy toves][stithy][toves]
  [in the wabe.][in][the wabe.][the][wabe.]
  [were the borogoves,][were][the
  borogoves,][the][borogoves,]
  [mome raths outgrabe.][mome][raths
  outgrabe.][raths][outgrabe.]
  [Jabberwock, my son,)[Jabberwock,][my son,][my][son,]
  [claws that catch.][claws][that catch.][that][catch.]
  [bird, and shun][bird,][and shun][and][shun]
  [The frumious Bandersnatch.][The][frumious
  Bandersnatch.][frumious](Bandersnatch.]
  */
  ```
  - 目标是捕获每行的最后三个单词，行尾由$分隔
  - 正常情况下是将$与整个输入序列的结尾逬行匹配，因此我们必须明确告诉正则表达式注意输入中的换行符。这是通过序列开头的模式标记(?m)来完成的

### 3. Matcher的start()和end()
  start()返回本次匹配结果的起始索引，而把本次匹配结果最后一个字符的索引加上1,就是end()的返回值  
  如果匹配不成功，调用start()或end()会产生一个IllegalStateException  
  ```java
  static void examine(String s, String regex) {
    Display d = new Display(regex);
    Pattern p = Pattern.compile(regex);
    Matcher m = p.matcher(s);
    while(m.find())
      d.display("find() '" + m.group() +
        "' start = " + m.start() + " end= " + m.end());
      if(m.lookingAt())     //不需要reset()
        d.display("lookingAt() start = "
          + m.start() + " end = "+ m.end());
      if(m.matches())       //不需要reset()
        d.display("matches() start = "
          + m.start() + " end = "+ m.end());
  }
  ```
  ```java
  /*输出
  input : Never give up! Never surrender!
  Never.*?!
  find() 'Never give up!' start = 0 end = 14
  find() 'Never surrender!' start = 15 end = 31
  lookingAt() start = 0 end = 14
  matches() start = 0 end = 31
  */
  ```
  - find()会在输入字符串中的任何位置匹配正则表达式
  - 对lookingAt()和matches()来说，只有正则表达式和输入字符串的幵始位置匹配时它们才可能成功
  - matches()仅在整个输入字符串都与正则表达式匹配时才会成功
  - 而lookingAt()则仅在输入字符串的幵始部分匹配时才成功

### 4. Pattern 标记
  Pattern类的compile()方法还有一个重载版本，它可以接受一个标记参数，来影响匹配行为:  
  `Pattern Pattern.compile(String regex, int flag)`   
  | 编译标记 | 效果 |  
  | --- | --- |  
  | Pattern.CANON_EQ | 当且仅当两个字符的完全正则分解匹配时.才认为它们匹配。例如.当指定此标记时.表达式\u003F将匹配字符串？。 默认情况下.匹配不考止正则的等价性 |  
  | Pattern.CASE_INSENSITIVE (?i) | 默认情况下.匹配仅在US-ASCII字符集中进行时才不区分大小写。这个标记允许模式匹配时不考虑大小写，可以通过指定UNICODE_CASE标记,并结合这个标记来在Unicode字符集里启用不区分大小写的匹配 |  
  | Pattern.UNICODE_CASE (?u) | 当指定了这个标记.并旦同时启用了CASE.INSENSITIVE标记时.不区分大小写的匹配将以符合Unicode标准的方式完成，默认情况下.匹配仅在US-ASCII字符集中进行时才不区分大小写 |  
  | Pattern.COMMENTS (?x) | 在这种模式下.空白符被忽略.弁且以#开头的嵌入注译也会被忽略.直到行尾：UNIX的行模式也可以通过嵌入的标记表达式来启用 |  
  | Pattern.MULTILINE (?m) | 开启在多行模式下，表达式^和$分別匹配一行的开头和结尾。默认情况下，这些表达式仅匹配整个输入字符串的开头和结尾 |  
  | Pattern DOTALL (?s) | 在dotall模式下.表达式匹配任何字符.包括換行符。默认情况下，表达式不匹配换行符 |   
  | Pattern.UNIX_LINES (?d) | 这种模式下,在^和$的行为里.只有换行符\n被识别 |  
  - 可以在正则表达式中直接使用上表中的大多数标记，只需要将左栏括号中的字符插入希望模式生效的位置之前即可。例：(?m)

  特别有用的是以下几种:  
  - Pattern.CASE_INSENSITIVE
  - Pattern.MULTILINE
  - Pattern.COMMENTS （有助于清晰度和/或文档记录）
  
  可以通过“或”操作（ | ）来组合这些标记：  
  ```java
  public class ReFlags {
    public static void main(String[] args) {
      Pattern p = Pattern.compile("^java",
      Pattern.CASE_INSENSITIVE | Pattern.MULTILINE);
      Matcher m = p.matcher(
        "java has regex\nJava has regex\n" +                //第1处，第2处
        "JAVA has pretty good regular expressions\n" +      //第3处
        "Regular expressions are in Java");
      while(m.find())
        System.out.println(m.group());
    }
  }
  ```
  ```java
  /*输出
  java
  Java
  JAVA
  */
  ```

## split()
  split()根据输入的正则表达式来拆分字符串，然后返回拆分后的字符串对象数组  
  `String[] split(CharSequence input)`  
  `String[] split(CharSequence input, int limit)`  
  ```java
  public class SplitDemo {
    public static void main(String[] args) {
      String input =
        "This!!unusual use!!of exclamation!!points";
      System.out.println(Arrays.toString(
        Pattern.compile("!!").split(input)));
      //只执行前3次：
      System.out.println(Arrays.toString(
        Pattern.compile("!!").split(input, 3)));
    }
  }
  ```
  ```java
  /*输出:
  [This, unusual use, of exclamation, points]
  [This, unusual use, of exclamation!!points)
  */
  ```
  - String[] split(CharSequence input, int limit)的limit是已经被拆分并保存的String个数，而不是拆分依据的正则表达式所使用的次数

## 替换操作
  - replaceFirst(String replacement)用参数 replacement 替换输入字符串的第一个匹配的部分
  - replaceAll(String replacement)用参数replacement替换输入字符串的每个匹配的部分
  - appendReplacement(StringBuffer sbuf, String replacement) 执行逐步替换，并保存到sbuf中。这是一个非常重要的方法，因为你可以调用其他方法来处理或生成replacement(replaceFirst()和replaceAll()只能放入固定的字符串)
  - 在调用了一次或多次appendReplacement()方法后，可以再调用appendTail(StringBuffer sbuf)方法,将输入字符串的剩余部分复制到sbuf
  ```java
  String s = Files.lines(
    Paths.get ("TheReplacements .java"))
    .collect (Collectors.joining ("\n"));
  StringBuffer sbuf = new StringBuffer();
  Pattern p = Pattern.compile ("[aeiou]");
  Matcher m = p.matcher(s);
  // 一边在找一边替换：
  while(m.find())
    m.appendReplacement(
      sbuf, m.group().toUpperCase());
  //插入文本的剩余部分：
  m.appendTail(sbuf);
  System.out.printIn(sbuf);
  ```
  - String类自带的replaceAll(),它和Matcher里的replaceAll()等效
  - 在前面的示例中，我们先获取一个group(),在这里它表示正则表达式匹配到的元音，然后将其设置为大写，最后将结果写入sbuf
  - 在appendReplacement()方法的替换字符串中，你还可以通过`\$g`直接引用匹配的某个组，其中g就是组号。不过它只能应付简单的处理，无法实现前面的示例中你想要的类似功能

## reset()
  reset()方法将现有的Matcher对象应用于新的字符序列：  
  ```java
  public class Resetting {
    public static void main(String[] args) throws Exception {
      Matcher m = Pattern.compile("[frb][aiu][gx]")
        .matcher("fix the rug with bags");
      while(m.find())
        System.out.print(m.group() + " ")；
      System.out.println();
      m.reset("fix the rig with rags");
      while(m.find())
        System.out.print(m.group() + " ");
    }
  }
  ```
  ```java
  /*输出：
  fix rug bag
  fix rig rag
  */
  ```
  - 没有任何参数的reset()会将Matcher对象设置到当前序列的起始位置

## 正则表达式和Java I/O
  大多数示例将正则表达式应用于静态的字符串  
  下面这个示例演示了如何用正则表达式来搜索文件中的匹配项:  
  ```java
  public static void main(String[] args) throws Exception {
    if(args.length < 2) {
      System.out.println(
        "Usage: java JGrep file regex");
      System.exit(0);
    }
    Pattern p = Pattern.compile(args[1]);
    Matcher m = p.matcher("")；
    //遍历输入文件的每一行
    Files.readAllLines (Paths.get(args[0])).forEach (
      line -> {
        m.reset(line);
        while(m.find())
          System.out.printin(
            m.group() + ": " + m.start());
      }
    );
  }
  ```

# 扫描输入
  一般的解决方案是读入一行文本，对其进行分词解析，然后使用Integer. Double等类里的各种方法来解析数据
  ```java
  public static BufferedReader input =
    new BufferedReader(new StringReader(
    "Sir Robin of Camelot\n22 1.61803"));
  public static void main(String[] args) {
    try {
      System.out.printin("What is your name?");
      String name = input.readLine();
      System.out.println(name);
    } catch(IOException e) {
      System.err.println("I/O exception");
    }
  }
  ```
  ```java
  /*输出：
  What is your name?
  Sir Robin of Camelot
  */
  ```
  - StringReader将字符串转换为可读流对象.该对象用于创建BufferedReader,因为BufferedReader有一个readLine()方法 这样我们就可以每次从input对象里读取一行.就好像它是来自控制台的标准输入一样

  Java 5中添加的Scanner类大大减轻了扫描输入的负担：  
  ```java
  public class BetterRead {
    public static void main(String[] args) {
      Scanner stdin = new Scanner(SimpleRead.input);
      System.out.println ("What is your name?");
      String name = stdin.nextLine();
      System.out.printIn(name);
    }
  }
  ```
  ```java
  /*输出：
  What is your name?
  Sir Robin of Camelot
  */
  ```
  - Scanner的构造器可以接受任何类型的输入对象，包括File对象、InputStream、String,或者此例里的Readable ( Java 5引入的一个接口.用于描述"具有read()方法的东西”————BufferedReader就归于这一类

## Scanner 分隔符
  默认情况下，Scanner通过空格分割输入数据，但也可以用正则表达式的形式来指定自己的分隔符模式：  
  ```java
  public class ScannerDelimiter {
    public static void main(String[) args) {
      Scanner scanner = new Scanner("12, 42, 78, 99, 42");
      scanner.useDelimiter("\\s*,\\s*");
      while(scanner.hasNextInt())
        System.out.println(scanner.nextInt());
    }
  }
  ```
  - 还有delimiter()方法，它返回了当前用作分隔符的Pattern对象

## 使用正则表达式扫描
  ```java
  static String threatData =
    "58.27.82.161@O8/10/2015\n" +
    "204.45.234.4O@08/ll/2015\n" +
    "58.27.82.161@08/ll/2015\n" +
    "58.27.82.161@08/12/2015\n" +
    "58.27.82.161@08/12/2015\n" +
    "[Next tog section with different data format}";
  public static void main(String[] args) {
    Scanner scanner = new Scanner(threatData);
    String pattern = " (\\d+[. ]\\d+[. ]\\d+[. ]\\d+)@" +
      "(\\d{2}/\\d{2}/\\d{4})";
    while(scanner.hasNext(pattern)) {
      scanner.next(pattern);
      MatchResult match = scanner.match();
      String ip = match.group(1);
      String date = match.group(2);
      System.out.format(
        "Threat on %s from %s%n", date,ip);
    }
  }
  ```
  ```java
  /*输出：
  Threat on 08/10/2015 from 58.27.82.161
  Threat on 08/11/2015 from 294.45.234.48
  Threat on 08/11/2015 from 58.27.82.161
  Threat on 08/12/2015 from 58.27.82.161
  Threat on G8/12/2G15 from 58.27.82.161
  */
  ```
  - next()与特定模式一起使用时，该模式会和下一个输入分词进行匹配

# StringTokenizer
  ```java
  public static void main(String[] args) {
    String input =
    "But I'm not dead yet! I feel happy!";  
    StringTokenizer stoke = new StringTokenizer(input);
    while(stoke.hasMoreElements())
      System.out.print(stoke.nextToken() + " ");
  }
  ```
  ```java
  /*输出:
  But I'm not dead yet! I feel happy!
  */
  ```
  - 使用正则表达式或Scanner对象，你还可以使用更复杂的模式来拆分字符串，而这对StringTokenizer来说就很困难了

# 总结
  现在Java对字符串的支持已经相当完善，不过有时还是要在一些细节上注意效率的问题，比如合理地使用 StringBuilder  
  
