反射可以在程序运行时发现并使用对象的类型信息。  

反射使我们摆脱了只能在编译时执行面向类型操作的限制，并且让我们能够编写一些非常强大的程序  
- 简单反射，它假定你在编译时就已经知道了所有可用的类型
- 复杂的反射，它允许我们在运行时发现和使用未知类的信息

# 为什么需要反射
  ```mermaid
  graph TD;
  Circle --> Shape;
  Square --> Shape;
  Triangle --> Shape;
  ```
  ```java
  public class Shapes {
    public static void main(String[] args) {
    Stream.of(
      new Circle()，new Square(), new Triangle())
      .forEach(Shape::draw);
    }
  }
  ```
  ```java
  /*输出:
  Circle.draw()
  Square.draw()
  Triangle.draw()
  */
  ```
  - 将一个Shape的子类对象放入Stream<Shape>时，会发生隐式的向上转型
  - 在向上转型为Shape时，这个对象的确切类型信息就丢失了。对于流来说，它们只是Shape类的对象
  - 从技术上讲，Stream<Shape>实际上将所有内容都当作Object保存
  - 当一个元素被取出时，它会自动转回Shape。这是反射最基本的形式，在运行时检查了所有的类型转换是否正确。这就是反射的意思：在运行时，确定对象的类型
  - 反射类型转换并不彻底：Object只是被转换成了Shape.而没有转换为最终的Circle. Square或Triangle。这是因为我们所能得到的信息就是Stream<Shape>里保存的都是Shape
  - 在编译时，这是由Stream和Java泛型系统强制保证的.而在运行时.类型转换操作会确保这一点

  通过复杂反射，你可以査询到某个Shape引用所指的确切类型，从而选择并隔离特殊情况  
  
# Class 对象
  Class对象：特殊对象，包含了与类相关的信息。体现了类型信息在运行时是如何表示的  
  Class对象被用来创建类的所有“常规”对象。  
  Java使用Class对象执行反射，即使是类型转换这样的操作也一样。  
  Class类还有许多其他使用反射的方式  

  程序中的每个类都有一个Class对象。  
  每次编写并编译一个新类时，都会生成一个Class对象（并被相应地存储在同名的.class文件中）  
  为了生成这个对象，Java虚拟机（JVM）使用被称为类加载器（class loader）的子系统  

  类加载器子系统实际上可以包含一条类加载器链，但里面只会有一个原始类加载器(即启动类加载器)。通常来说我们不需要加载器链中的额外加载器，但对于特殊需要（例如以某种方式加载类以支持Web服务器应用程序，或通过网络来下载类），你可以引入额外的类加载器来实现   

  类在首次使用时才会被动态加载到JVM中。当程序第一次引用该类的静态成员时,就会触发这个类的加载  
  构造器是类的一个静态方法，尽管没有明确使用static关键字  

  Java程序在运行前并不会被完全加载，而是在必要时加载对应的部分  
  这种动态加载能力使得Java可以支持很多行为，而它们在静态加载语言（如C++）中很难复制，或根本不可能复制  

  ```java
  class Cookie {
    static { System.out.println("Loading Cookie"); }
  }
  class Gum {
    static { System.out .printIn("Loading Gum"); }
  }
  class Candy {
    static { System.out.printin("Loading Candy"); }
  }
  public class Sweetshop {
    public static void main(String[] args) {
      System.out.println("inside main");
      new Candy();
      System.out.printin("After creating Candy");
      try {
        Class.forName("Gum");
      } catch(ClassNotFoundException e) (
        System.out.println("Couldn't find Gum");
      }
      System.out.println("After Class.forName(\"Gum\")");
      new Cookie():
      System.out.printin("After creating Cookie");
    }
  }
  ```
  ```java
  /*输出：
  inside main
  Loading Candy
  After creating Candy
  Loading Gum
  After Class.forName("Gum")
  Loading Cookie
  After creating Cookie
  */
  ```
  - Class对象仅在需要时才加载，并且静态代码块的初始化是在类加载时执行的

  `Class.forName("Gum");`  
  所有的Class对象都属于Class类。Class对象和其他对象一样，因此你可以获取并操作它的引用(这也是加载器所做的)  
  静态的forName()方法可以获得Class对象的引用,该方法接收了一个包含所需类的文本名称(注意拼写和大小写！)的字符串，并返回了一个Class引用  

  不管什么时候，只要在运行时用到类型信息,就必须首先获得相应的Class对象的引用  
  - Class.forName()方法用起来就很方便了，因为不需要对应类型的对象就能获取Class引用  
  - 如果已经有了一个你想要的类型的对象，就可以通过getClass()方法来获取Class引用，这个方法属于Object根类

  ```java
  import java.lang.reflect.InvocationTargetException;

  interface HasBatteries {}
  interface Waterproof {}
  interface Shoots {}

  class Toy {
    //可以将下面这个无參构造器注释掉来看一下NoSuchMethodError
    public Toy() {}
    public Toy(int i) {}
  }
  class FancyToy extends Toy implements HasBatteries, Waterproof, Shoots (
    public FancyToy() { super(1); }
  }
  public class ToyTest {
    static void printInfo(Class cc) {
      System.out.printin("Class name: " + cc.getName() +
        "is interface? [" + cc.isInterface() + "]");
      System.out.printin(
        "Simple name: " + cc.getSimpleName());
      System.out.println(
        "Canonical name : "+ cc.getCanonicalName());
    }
    @SuppressWarnings("deprecation")
    public static void main(String[] args) {
      Class c = null；
      try {
        c = Class.forName(" reflection.toys.FancyToy");
      } catch(ClassNotFoundException e) {
        System.out.println ("Can't find FancyToy");
        System.exit(1);
      }
      printInfo(c):
      for(Class face : c.getlnterfaces())
        printInfo(face);
      Class up = c.getSuperclass();
      Object obj = null;
      try {
        //对应类要有public的无参构造器：
        obj = up.newInstance();
      } catch(Exception e) {
        throw new
          RuntimeException("Cannot instantiate");
      }
      printInfo(obj .getClass());
    }
  }
  ```
  ```java
  /*输出：
  Class name: reflection.toys.FancyToy is interface?
  [false]
  Simple name: FancyToy
  Canonical name : reflection. toys. FancyToy
  Class name: reflection.toys.HasBatteries is interface?
  [true]
  Simple name: HasBatteries
  Canonical name : reflection. toys.HasBatteries
  Class name: reflection. toys .Waterproof is interface?
  [true]
  Simple name: Waterproof
  Canonical name : reflection. toys .Waterproof
  Class name: reflection.toys.Shoots is interface? [true]
  Simple name: Shoots
  Canonical name : reflection. toys.Shoots
  Class name: reflection.toys.Toy is interface? [false]
  Simple name: Toy
  Canonical name : reflection. toys .Toy
  */
  ```
  - 传递给forName()的字符串参数必须是类的完全限定名称(包括包名称)
  - getName()和getCanonicalName()生成完全限定的类名
  - getSimpleName()生成不带包的名称
  - isInterface()可以告诉你这个Class对象是否表示一个接口
  - Class.getInterfaces()方法返回了一个Class对象数组,它们表示你感兴趣的这个Class对象的所有接口
  - getSuperclass()查询Class对象的直接基类
  - Class的newlnstance()方法是实现“虚拟构造器”的一种途径，这相当于声明“不知道你的确切类型，但无论如何你都要正确地创建自己”

  newInstance()在Java 8中还是正常的，但在更高版本中已被弃用，Java 推荐使用 Constructor.newInstance()来代替  
  示例中我们使用了@SuppressWarnings("deprecation")来抑制那些更高版本的弃用警告  
    
## 类字面量
  Java还提供了另一种方式来生成Class对象的引用：类字面量(class literal)  
  `FancyToy.class;`  
  这更简单也更安全，因为它会进行编译时检查(因此不必放在try块中)。另外它还消除了对forName()方法的调用，所以效率也更高  
  
  类字面量适用于常规类以及接口、数组和基本类型。每个基本包装类都有一个名为TYPE的标准字段。TYPE字段表示一个指向和基本类型对应的Class对象的引用  
  | 类字面量 | 等价于 |  
  | boolean.class | Boolean.TYPE |  
  | char.class | Character.TYPE |  
  | byte.class | Byte.TYPE |  
  | short.class | Short.TYPE |  
  | int.class | Integer.TYPE |  
  | long.class | Long.TYPE |  
  | float.class | Float.TYPE |  
  | double.class | Double.TYPE |  
  | void.class | Void.TYPE |  
  
  使用“.class”的形式创建Class对象的引用时，该Class对象不会自动初始化。  
  初始化被延迟到首次引用静态方法（构造器是隐式静态的）或非常量静态字段时————lazy initializaton:  
  ```java
  class Initable {
    static final int STATIC_FINAL = 47;
    static final int STATIC_FINAL2 = 
      Classinitialization.rand.nextInt(1000);
    static {
      System.out.println("Initializing Initable");
    }
  }

  class Initable2 {
    static int staticNonFinal = 147;
    static {
      System.out.println("Initializing Initable2");
    }
  }

  class Initable3 {
    static int staticNonFinal = 74;
    static {
      System.out.println("Initializing Initable3");
    }
  }

  public class Classinitialization {
    public static Random rand = new Random(47);
    public static void main(String[] args) throws Exception {
      Class initable = Initable.class;
      System.out.println("After creating Initable ref");
      //不会触发初始化
      System.out.println(Initable.STATIC_FINAL);
      //触发初始化
      System.out.printin(Initable.STATIC_FINAL2);
      //触发初始化
      System.out.printin(Initable2.staticNonFinal);
      Class initable3 = Class.forName("Initable3");
      System.out.printin("After creating Initable3 ref");
      System.out.println(Initable3.staticNonFinal);
    }
  }
  ```
  ```java
  /*输出:
  After creating Initable ref
  47
  Initializing Initable
  258
  Initializing Initable2
  147
  Initializing Initable3
  After creating Initable3 ref
  74
  */
  ```
  - 仅使用.class语法来获取对类的引用不会导致初始化
  - 而Class.forName()会立即初始化类以产生Class引用
  - 如果一个static final字段的值是“编译时常量”,比如Initable.staticFinal,那么这个值不需要初始化Initable类就能读取
  - 但是把一个字段设置为static和final并不能保证这种行为：对Initable.staticFinal2的访问会强制执行类的初始化，因为它不是编译时常量

## 泛型类的引用
  一个Class引用表示的就是它所指向的确切类型：Class类的一个对象  
  Class引用指向的是一个Class对象，该对象可以生成类的实例，并包含了这些实例所有方法的代码。它还包含该类的静态字段和静态方法

  你可以使用泛型语法来限制Class引用的类型：  
  ```java
  public class GenericClassReferences {
    public static void main(String[] args) {
      Class intClass = int.Class;
      intClass = double.class;
      Class<Integer> genericIntClass = int.class;
      genericIntClass = Integer.class; // 一样
      // genericIntClass = double.class; // 不合法
    }
  }
  ```
  - 通过使用泛型语法，可以让编译器强制执行额外的类型检查

  `Class<Number> genericNumberClass = int.class;`  
  - 实际上这段代码无法运行,Integer的Class对象不是Number的Class对象的子类

  要想放松使用泛化的Class引用时的限制，请使用通配符`?`，它是Java泛型的一部分,表示“任何事物”  
  ```java
  public class WildcardClassReferences {
    public static void main(String[] args) {
      Class<?> intClass = int.class;
      intClass = double.class;
    }
  }
  ```
  - 和普通的Class相比，我们还是倾向于Class<?>,即使它们是等价的
  - Class。〉的好处在于.它表明了你不是偶然或无意识地使用了非具体的类引用。你就是选择了这个非具体的版本

  想创建一个Class引用，并将其限制为某个类型或任意子类型，可以将通配符与extends关键字组合来创建一个界限（bound ）：  
  ```java
  public class BoundedClassReferences {
    public static void main(String[] args) {
      Class<? extends Number> bounded = int.class;
      bounded = double.class;
      bounded = Number.class;
      //或者任何继承了 Number的类
    }
  }
  ```
  - 将泛型语法添加到Class引用的一个原因是提供编译时的类型检查
  - 这样的话，如果你做错了什么.那么很快就能发现

  ```java
  class ID {
    private static long counter;
    private final long id = counter++;
    ©Override public String toString() {
      return Long.toString(id);
    }
    // 如果想要调用 getConstructor().newlnstance(),
    // 就主要提供一个public的无参构造器：
    public ID() {}
  }
  public class DynamicSupplier<T> implements Supplier<T> {
    private Class<T> type;
    public DynamicSupplier(Class<T> type) {
      this.type = type;
    }
    ©Override public T get() {
      try {
        return type.getConstructor().newInstance();
      } catch(Exception e) {
        throw new RuntimeException(e);
      }
    }
    public static void main(String[] args) {
      Stream.generate(
        new DynamicSupplier<>(ID.class))
        .skip(10)
        .limit(5)
        .forEach(System.out::printin);
    }
  }
  ```
  ```java
  /*输出：
  10
  11
  12
  13
  14
  */
  ```
  - DynamicSupplier会强制要求它使用的任何类型都有一个public的无参构造器(一个没有参数的构造器),因为Constructor().newInstance()调用的是无参构造器
  - 在上面的例子中，ID自动生成的无参构造器不是public的，因为ID类不是public的，所以我们必须显式定义它

  对Class对象使用泛型语法时，newInstance()会返回对象的确切类型，而不仅仅是简单的Object  
  ```java
  Class<FancyToy> ftc = FancyToy.class;
  //生成确切的类型：
  FancyToy fancyToy = ftc. getConstructor().newInstance();
  Class<? super FancyToy> up = ftc.getSuperclass();
  //下面的代码无法通过编译：
  // Class<Toy> up2 = ftc.getSuperclass();
  //只能生成Object
  Object obj = up.getConstructor().newInstance();
  ```
  - 编译器只允许你声明这个基类引用是“FancyToy的某个基类”，就像表达式Class<? super FancyToy>所声明的那样

## cast()方法
  ```java
  class Building {}
  class House extends Building {}

  public class ClassCasts {
    public static void main(String[] args) {
      Building b = new House();
      Class<House> houseType = House.class;
      House h = houseType.cast(b);
      h = (House)b;       //或者直接这样进行转型
    }
  }
  ```
  - cast()在你不能使用普通类型转换的情况下很有用。如果你正在编写泛型代码,并旦存储了一个用于转型的Class引用，就可能会遇到这种情况(Class引用不能使用普通类型转换)

  Class.asSubclass()会将类对象转换为更具体的类型  

# 转型前检查
  - 传统的类型转换 比如“（Shape）”.它使用反射来确保转型是正确的：如果你执行了错误的转型，它会抛出一个ClassCastException
  - 代表对象类型的Class对象。你可以查询Class对象来获取有用的运行时信息

  在Java中，的确会执行类型检查，这种转型通常称为“类型安全向下转型”（type-safe downcast）  
  如果不使用显式的类型转换来告诉编译器这是一个特定的类型，编译器就不会允许执行向下转型赋值操作（编译器会检查该向下转型操作是否合理.因此它不会让你向下转型为实际上不是其子类的类型）  

  第三种形式的反射：  
  关键字instanceof,它返回一个boolean值,表明一个对象是否是特定类型或其子类的实例  

  当没有其他信息可以告诉你对象类型的时候，在向下转型之前使用instanceof很重要  
  
  ```
  public class Pet extends Individual {
    public Pet(String name) { super(name); }
    public Pet() { super(); }
  }
  ...
  ```
  - 我们必须在每种情况下都显式地编写无参构造器。因为每个类都有一个带参数的构造器，这阻止了编译器自动生成无参构造器（只有没有任何构造器的类才会隐含生成无参构造器）

  ```java
  private Random rand = new Random(47);
  //创定不同类型的Pet：
  public abstract List<Class<? extends Pet>> types();
  ©Override public Pet get () {         // 创止一个随机的 Pet 对象
    int n = rand.nextlnt(types().size());
    try {
      return types().get(n)
        .getConstructor().newInstance();
    } catch(InstantiationException |
        NoSuchMethodException |
        InvocationTargetException |
        IllegalAccessException e) {
      throw new RuntimeException(e);
    }
  }
  ```
  - List的泛型参数被指定为“继承了 Pet的任意子类”，因此newInstance()无须类型转换即可生成一个Pet

  ```java
  @SuppressWarnings("unchecked")
  private static void loader() {
    try {
      for(String name : typeNames)
      types.add(
        (Class<? extends Pet>)Class.forName(name));
    } catch(ClassNotFoundException e) {
      throw new RuntimeException(e);
    }
  }
  ```
  - loader()方法使用Class.forName()来创建-个Class对象的列表,可能会抛出ClassNotFoundException。这是合理的.因为你传递给它的是一个在编译时无法验证的字符串
  - @SuppressWarnings("unchecked")注解不能直接用于静态初始化块

  instanceof有一个相当严格的限制：只能将其与类型名称进行比较，而不能与一个Class对象进行比较  

## 使用类字面量
  ```java
  //不需要try块
  public static final
  List<Class<? extends Pet» ALL_TYPES =
    Collections. unmodifiabl.eList(Arrays.asList(
      Pet.class, Dog.class, Cat.class, Rodent.class,
      Mutt.class, Pug.class, EgyptianMau.class,
      Manx.class, Cymric.class, Rat.class,
      Mouse.class, Hamster.class));
  ```

## 动态的 instanceof————Class.isInstance()
  Class.isInstance()方法提供了一种动态验证对象类型的方式:  判断对象是否是特定类型及其子类的实例
  ```java
  public class PetCounter3 {
    static class Counter extends HashMap<Class<? extends Pet>, Integer> {
      Counter() {
        super(PetCreator.ALL_TYPES.stream()
          .map(type -> Pair.make (type, 0))
          .collect(
            Collectors.toMap(Pair::key, Pair::value)));
      }
      public void count(Pet pet) (
        // Class.isInstance()消除了大量的 instanceof：
        entrySet().stream()
        .filter(pair -> pair.getKey().isInstance(pet))
        .forEach(pair ->
          put (pair.getKey(), pair.getValue() + 1))；
      }
      @Override public String toString() {
        String result = entrySet().stream()
          .map(pair -> String.format("%s=%s",
            pair.getKey().getSimpleName(),
            pair.getValue()))
          .collect(Collectors.joining(", "))；
        return "{" + result + "}";
      }
    }

    public static void main(String[] args) {
      Counter petCount = new Counter();
      new PetCreator().stream()
        .limit(20)
        .peek(petCount::count)
        .forEach(p -> System.out.print(
          p.getClass().getSimpleName() + " "));
      System.out.println("\n" + petCount);
    }
  }
  ```
  ```java
  /*输出:
  Rat Manx Cymric Mutt Pug Cymric Pug Manx Cymric Rat
  EgyptianMau Hamster EgyptianMau Mutt Mutt Cymric Mouse
  Pug Mouse Cymric
  {EgyptianMau=2, Mouse=2, Pet=20, Cymric=5, Rat=2,
  Dog=6, Mutt=3, Hamster=l, Cat=9, Manx=7, Rodent=5,
  Pug=3}
  */
  ```
  - isInstance()方法使我们不再需要instanceof表达式
  - 此外，这还意味着，如果想添加新的Pet类型，只需要更改PetCreator.types数组就可以,程序的其余部分不需要修改(但在使用instanceof表达式时就不可以)

## 递归计数
  使用Class.isAssignableFrom()方法代替Map的预加载，来创建一个并不仅限于对Pet进行计数的通用工具：  
  ```java
  import java.util.*;
  import java.util.stream.*;
  
  public class
  TypeCounter extends HashMap<Class<?>, Integer> {
    private Class<?> baseType;
    public TypeCounter(Class<?> baseType) (
      this.baseType = baseType;
    }
    public void count(Object obj) {
      Class<?> type = obj.getClass();
      if (!baseType.isAssignableFrom(type))
        throw new RuntimeException(
          obj + " incorrect type: " + type +
          " should be type or subtype of " + baseType);
      countClass(type);
    }
    private void countClass(Class<?> type) {
      Integer quantity = get(type);
      put(type, quantity == null ? 1 : quantity + 1);  
      Class<?> superclass = type.getSuperclass();
      if(superclass != null &&
        baseType.isAssignableFrom(superClass)) {
        countClass(superClass);
      }
    }
    @Override public String toString() {
      String result = entrySet().stream()
        .map(pair -> String.format("%s=%s",
          pair.getKey().getSimpleName(),
          pair.getValue()))
        .collect(Collectors.joining(", "));
      return "(" + result + "}";
    }
  }

  public class PetCounter4 {
    public static void main(String[] args) {
      TypeCounter counter = new TypeCounter(Pet.class);
      new PetCreator().stream()
        .limit(20)
        .peek(counter::count)
        .forEach(p -> System.out.print(
          p.getClass().getSimpleName() + ""))；
      System.out.println("\n" + counter);
    }
  }
  ```
  ```java
  /*输出：
  Rat Manx Cymric Mutt Pug Cymric Pug Manx Cymric Rat
  EgyptianMau Hamster EgyptianMau Mutt Mutt Cymric Mouse
  Pug Mouse Cymric
  (Rodent=5, Mouse=2, Hamster=l, Cymric=5, Dog=6,
  EgyptianMau=2, Pet=20, Rat=2, Pug=3, Manx=7, Cat=9,
  Mutt=3}
  */
  ```

# 注册工厂
  通过Pet层次结构来生成对象存在一个问题，即每次向层次结构中添加新类型的Pet时，都必须记住将其添加到PetCreator.java的列表里 在一个要经常添加类的系统中，这可能会成为问题  
  你必须自己手动创建这个列表(除非你编写一个工具来搜索并分析源代码,然后创建和编译这个列表)。所以最佳的做法就是把这个列表放在一个靠近中心的、位置明显的地方。我们感兴趣的这个层次结构的基类可能就是最好的地方  

  java.util.function.Supplier通过它的T get()方法提供了一个工厂方法的原型。get()方法可以通过协变返回类型为Supplier的不同子类返回对应的类型:  
  ```java
  class Part implements Supplier<Part> (
    @Override public String toString() {
      return getClass().getSimpleName();
    }
    static List<Supplier<? extends Part» prototypes =
      Arrays.asList(
        new FuelFilter(),
        new AirFilter(),
        new CabinAirFilter()，
        new OilFilter(),
        new FanBelt(),
        new PowerSteeringBelt(),
        new GeneratorBelt()
      );
    private static Random rand = new Random(47);
    @Override public Part get() {
      int n = rand.nextlnt(prototypes.size());
      return prototypes.get(n).get();
    }
  }
  class Filter extends Part {}
  class FuelFilter extends Filter {
    @Override
    public FuelFilter get() { return new FuelFilter(); }
  }
  class AirFilter extends Filter {
    @Override
    public AirFilter get() { return new AirFilter(); }
  }
  class CabinAirFilter extends Filter {
    @Override public CabinAirFilter get() {
    return new CabinAirFilter();
    }
  }
  class OilFilter extends Filter {
    @Override
    public OilFilter get() ( return new OilFilter(); }
  }
  class Belt extends Part {}
  class FanBelt extends Belt {
    ©Override
    public FanBelt get() ( return new FanBelt(); }
  }
  class GeneratorBelt extends Belt {
    @Override public GeneratorBelt get() (
      return new GeneratorBelt();
    }
  }
  class PowerSteeringBelt extends Belt {
    @Override public PowerSteeringBelt get() {
      return new PowerSteeringBelt();
    }
  }
  public class RegisteredFactories {
    public static void main(String[] args) {
      Stream.generate(new Part())
      .limit(10)
      .forEach(System.out::println);
    }
  }
  ```
  ```java
  /*输出:
  GeneratorBelt
  CabinAirFilter
  GeneratorBelt
  AirFilter
  PowerSteeringBelt
  CabinAirFilter
  FuelFilter
  PowerSteeringBelt
  PowerSteeringBelt
  FuelFilter
  */
  ```
  -  如果调用了基类Part的get()方法(或者通过generate()调用get()),它会随机创建特定的Part子类型，每个子类型最终都继承自Part,并重写了 get()方法来生成自身的对象

# Instanceof 与 Class 的等价性
  instanceof和isInstance()的效果是一样的,而它们与Class对象的直接比较有着重要的区别:  
  ```java
  class Base {}
  class Derived extends Base {}

  public class FamilyVsExactType {
    static void test(Object x) {
      System.out.println(
        "Testing x of type " + x.getClass());
      System.out.println(
        "x instanceof Base " + (x instanceof Base));
      System.out.printin (
        “x instanceof Derived " + (x instanceof Derived));
      System.out.println(
        "Base.isInstance(x) " + Base.class.isInstance(x));
      System.out.printIn(
        "Derived.isInstance(x) " + Derived.class.isInstance(x));
      System.out.println(
        "x.getClass() == Base.class " +
        (x.getClass() == Base.class));
      System.out.println(
        "x.getClass() == Derived.class " +
        (x.getClass() == Derived.class));
      System.out.printin(
        "x.getClass().equals(Base.class) "+
        (x.getClass().equals(Base.class)));
      System.out.println(
        "x.getClass().equals(Derived.class) " +
        (x.getClass().equals(Derived.class)));
      }
    public static void main(String[] args) {
      test(new Base());
      test(new Derived());
    }
  }
  ```
  ```java
  /*输出:
  Testing x of type class reflection.Base
  x instanceof Base true
  x instanceof Derived false
  Base.isInstance(x) true
  Derived.isInstance(x) false
  x.getClass() == Base.class true
  x.getClass() == Derived.class false
  x.getClass().equals(Base.class)) true
  x.getClass().equals(Derived.class)) false
  Testing x of type class reflection.Derived
  x instanceof Base true
  x instanceof Derived true
  Base.isInstance(x) true
  Derived.isInstance(x) true
  x.getClass() = Base.class false
  x.getClass() = Derived.class true
  x.getClass().equals(Base.class)) false
  x.getClass().equals(Derived.class)) true
  */
  ```
  - instanceof和isInstance()产生了完全相同的结果.而equals()和==也一样
  - instanceof与类型的概念保持了一致，它相当于表示“你是这个类，或是这个类的子类”
  - 另一方面，如果你使用==比较实际的Class对象,则不需要考虑继承————它要么是确切的类型，要么不是

# 运行时的类信息
  如果不知道某个对象的确切类型，instanceof可以告诉你。但是，这里有一个限制：只有在编译时就知道的类型才能使用instanceof来检测  
  
  但假设你获取了一个不在你的程序空间的对象引用————事实上，在编译时你的程序甚至无法获知这个对象所属的类。也许你只是从磁盘文件或网络连接中获得了一堆字节，然后被告知这些字节代表一个类  

  基于组件的编程，在这种编程方式中，我们在构建应用程序的集成开发环境（IDE ）中，通过快速应用程序开发（RAD）模式来构建项目。这是一种可视化编程方法，它通过将代表不同组件的图标拖拽到表单中来创建程序，然后在程序里通过设置组件的属性值来配置它们  

  反射提供了一种检测可用方法并生成方法名称的机制

  在运行时获取类信息的另一个吸引人的动机就是,希望提供通过网络在远程平台上创建和运行对象的能力。这称为远程方法调用（RMI）,它允许Java程序将对象分布到多台机器上。（特别是分布式计算）  

  Class类和java.lang.reflect库一起支持了反射，这个库里包含Field、Method以及Constructor类（每个都实现了Member接口 ）  

  这样你就可以使用Constructor来创建新的对象，使用get（）和set（）方法来读取和修改与Field对象关联的字段,使用invoke（）方法调用与Method对象关联的方法  
  调用getField()、getMethods（）和getConstructors()等方法，以返回表示字段、方法和构造器的对象数组  

  因此对于JVM来说，该特定类型的.class文件必须是可用的；要么在本地机器上.要么可以通过网络获得。通过反射，在编译时不可用的.class文件就可以在运行时被打幵和检查了  

## 类方法提取器
  通常来说，你不会直接用到反射工具.但它有助于创建更动态的代码。  
  有时候动态提取有关类的信息也是很有用的。  

  如果我们查看一个类定义的源代码或其JDK文档，只能找到在这个类中被定义或被重写的方法。  
  但对我们来说，可能还有更多继承自基类的可用方法：  
  ```java
  import java.lang.reflect.*;
  import java.util.regex.*;

  public class ShowMethods {
    private static String usage =
      "usage:\n" +
      "ShowMethods qualified .class. name\n" +
      "To show all methods in class or:\n" +
      "ShowMethods qualified.class.name word\n" +
      "To search for methods involving 'word'";
    private static Pattern p = Pattern.compile("\\w+\\.");
    public static void main(String[] args) {
      if(args.length < 1) (
        System.out.println(usage);
        System.exit(9);
      }
      int lines = 0;
      try {
        Class<?> c = Class.forName(args[0]);
        Method[] methods = c.getMethods();
        Constructor[] ctors = c.getConstructors();
        if(args.length == 1) {
          for(Method method : methods)
            System.out.printIn(
              p.matcher(
                method.toString()).replaceAll(""));
          for(Constructor ctor : ctors)
            System.out.println(
              p.matcher(ctor.toString()).replaceAll(""));
          lines = methods.length + ctors.length;
        }else {
          for(Method method : methods)
            if(method.toString().contains(args[1])) {
              System.out.println(p.matcher(
                method.toString()).replaceAll(""));
              lines++;
            }
          for(Constructor ctor : ctors)
            if(ctor.toString().contains(args[1])) {
              System.out.println(p.matcher(
                ctor.toString()).replaceAll(""));
              lines++;
            }
        }
      }catch(ClassNotFoundException e) {
        System.out.printin("No such class: " + e)
      }
    }
  }
  ```
  ```java
  /*输出：
  public static void main(String[])
  public final void wait(long,int) throws
  InterruptedException
  public final native void wait(long) throws
  InterruptedException
  public final void wait() throws InterruptedException
  public boolean equals(Object)
  public String toString()
  public native int hashCode()
  public final native Class getClass()
  public final native void notify()
  public final native void notifyAll()
  public ShowMethods()
  */
  ```
  - Class类里的方法getMethods()和getConstructors()分别返回了 Method对象的数组和Constructor对象的数组
  - toString()方法来生成一个含有完整的方法签名的字符串
  - 输出里包含了一个public的无参构造器，即使代码中没有定义任何构造器:你看到的这个构造器是由编译器自动合成
  - 如果将ShowMethods设为非public类（即包访冋权限），那么这个自动合成的无参构造器就不会在输出中显示了。合成的无参构造器会自动获得与类相同的访问权限

  Class.forName()生成的结果在编译时是未知的，因此所有的方法签名信息都是在运行时提取的  

# 动态代理
  代理（proxy ）是基本的设计模式之一。  
  这些操作通常涉及与“实际”对象的通信.因此代理通常充当中间人的角色  

  在任何时候，如果你想要将额外的操作从“实际”对象中分离出来，特别是当你一般不会使用这些额外操作，但希望很轻松地就能改成使用，或反过来，这时代理就很有用了(设计模式的关注点就是封装修改————因此你需要做对应的修改来适应模式)  

  Java的动态代理(dynamic proxy)比代理更进一步，它可以动态地创建代理，并动态地处理对所代理方法的调用  
  在动态代理上逬行的所有调用都会被重定向到一个调用处理器(invocation handler)上,这个调用处理器的工作就是发现这是什么调用，然后决定如何处理它  
  ```java
  interface Interface {
    void doSomething();
    void somethingElse(String arg);
  }
  class DynamicProxyHandler implements InvocationHandler {
    private Object proxied;
    DynamicProxyHandler(Object proxied) (
      this.proxied = proxied;
    }
    @Override public Object
    invoke(Object proxy, Method method, Object[] args)
    throws Throwable {
      System.out.println(
        "**** proxy: " + proxy.getClass() +
        ", method: " + method + ", args: " + args);
      if(args != null)
        for(Object arg : args)
          System.out.println("  " + arg);
      return method.invoke(proxied, args);
    }
  }
  class SimpleDynamicProxy {
    public static void consumer(Interface iface) {
      iface.doSomething();
      iface.somethingElse("bonobo");
    }
    public static void main(String[] args) {
      RealObject real = new RealObject();
      consumer(real);
      //插入一个代理然后再次调用：
      Interface proxy = (Interface)Proxy.newProxyInstance(
        Interface.class.getClassLoader(),
        new Class[]{ Interface.class },
        new DynamicProxyHandler(real));
      consumer(proxy);
    }
  }
  ```
  ```java
  /*输出：
  doSomething
  somethingElse bonobo
  **** proxy: class $ProxyO, method: public abstract void
  Interface.doSomething(), args: null
  doSomething
  **** proxy: class $Proxy0, method: public abstract void
  Interface.somethingElse(java.lang.String), args：
  [Ljava.lang.Object;@lb84c92
    bonobo
  somethingElse bonobo
  */
  ```
  - 我们通过调用静态方法Proxy.newProxyInstance()来创建动态代理，它需要三个参数：
  - 一个类加载器（通常可以从一个已经加载的对象里获取其类加载器，然后传递给它就可以了）
  - 一个希望代理实现的接口列表（不是类或抽象类）
  - 以及InvocationHandler接口的一个实现
  - 在invokeO内部调用代理的方法时需要小心，因为对接口的调用是通过代理进行重定向的
  - 你会执行被代理的操作，然后使用Method.invoke()方法将请求转发给被代理的对象，并传入必要的参数
  
  你可以过滤某些方法调用，同时又放行其他的方法调用:  
  ```java
  @Override public Object
  invoke(Object proxy, Method method, Object[] args)
  throws Throwable {  
    if(method.getName().equals("interesting"))
      System.out.printin(
        "Proxy detected the interesting method");
    return method.invoke(proxied, args);
  }
  ```

# 使用 Optional
  尽管Optional是在Java 8中引入来支持Stream的，但它是一个通用工具，可以应用于普通类就证明了这一点  
  这个主题之所以包含在本章中，是因为涉及运行时检查  
  
  Optional看起来在“更接近数据”的地方最有用，此时对象代表问题空间中的实体。  
  举个简单的例子，许多系统里有Person类，但在代码中，有些情况下你并没有获得这样一个实际的对象（或者你可能有，但还没有关于那个对象的所有信息），所以通常你会使用一个null引用来表示，然后对其进行检查  
  ```java
  import onjava.*;
  import java.util.*;

  class Person {
    public final Optional<String> first;
    public final Optional<String> last;
    public final Optional<String> address;

    //省唯其余代码
    public final boolean empty;
    Person(String first, String last, String address) {
      this.first = Optional.ofNullable(first);
      this.last = Optional.ofNullable(last);
      this.address = Optional.ofNullable(address);
      empty = !this.first.isPresent()
        && !this.last.isPresent()
        && !this.address.isPresent();
    }
    Person(String first, String last) {
      this(first, last, null);
    }
    Person(String last) { this(null, last, null); )
    Person() { this(null, null, null); }
    @Override public String toString() {
      if(empty)
        return "<Empty>";
      return (first.orElse("") +
        " " + last.orElse("") +
        " "+ address.orElse("")).trim();
    }
    public static void main(String[] args) {
      System.out.printin(new Person());
      System.out.println(new Person("Smith"));
      System.out.printin(new Person("Bob", "Smith"));
      System.out.println(new Person("Bob", "Smith",
      "11 Degree Lane, Frostbite Falls, MN"));
    }
  }
  ```
  ```java
  /*输出:
  <Empty>
  Smith
  Bob Smith
  Bob Smith 11 Degree Lane, Frostbite Falls, MN
  */
  ```
  - Person的设计有时被称为“数据传输对象” 注意，所有的字段都是public和final的，因此没有getter和setter方法
  - Person是不可变的一你只能用构造器设置值.然后读取这些值，但你不能修改它们（字符串本身是不可变的，所以你不能修改字符串的内容，也不能给字段重新赋值）
  
  ```java
  class EmptyTitleException extends RuntimeException {}

  class Position {
    private String title;
    private Person person;
    Position(String jobTitle, Person employee) {
      setTitle(jobTitle);
      setPerson(employee);
    }
    Position(String jobTitle) {
      this(jobTitle, null);
    }
    public String getTitle() { return title; }
    public void setTitle(String newTitle) {
      // 如果 newTitle 是 null,则抛出 EmptyTitleException：
      title = Optional.ofNullable(newTitle)
        .orElseThrow(EmptyTitleException::new);
    }
    public Person getPerson() { return person; }
    public void setPerson(Person newPerson) {
      //如果newPerson是null.则使用一个空的Person：
      person = Optional .ofNullable(newPerson)
        .orElse(new Person());
    }
    @Override public String toString() {
      return "Position: " + title +
      ", Employee: " + person;
    }
    public static void main(String[] args) {
      System.out.println(new Position("CEO"));
      System.out.println(new Position ("Programmer",
        new Person("Arthur", "Fonzarelli")));
      try {
        new Position(null);
      } catch(Exception e) {
        System.out.printIn("caught " + e);
      }
    }
  }
  ```
  ```java
  /*输出：
  Position: CEO, Employee: <Empty>
  Position： Programmer, Employee: Arthur Fonzarelli
  caught EmptyTitleException
  */
  ```
  - title和petson都是普通字段，不受Optional的保护
  - 修改这些字段唯一的方法是通过setTitle()和setPerson(),而这两者都使用了 Optional的功能来对字段加以限制
  - EmptyTitleException是一个RuntimeException,因为它代表了一个程序员错误
  - EmptyTitleException的使用有助于进一步定位错误

  极限编程(Extreme Programming, XP)的一项宗旨就是“尝试最简单且可行的事情”  ：在初稿中只“尝试最简单且可行的事情”，直到程序的某些方面要求你添加额外的功能，而不是一开始就假设它是必要的  

## 标签接口
  使用标签接口 (tagging interface )来表示可空性更方便  
  标签接口没有元素,我们只是将它的名称当作标签来使用:  
  ```java
  public interface Null {}
  ```

  ```java
  public interface Robot {
    String name();
    String model();
    List<Operation> operations();
    static void test(Robot r) {
      if(r instanceof Null)
        System.out.printin("[Null Robot]");
      System.out.printin("Robot name: " + r.name());
      System.out.printin("Robot model: " + r.model());
      for(Operation operation : r.operations()) (
        System.out.println(operation.description.get());
        operation.command.run();
      }
    }
  }
  ```
  - 可以通过调用operations()来访问Robot的服务
  - Operation包含一个描述和一个命令［这是一种命令模式(Command pattern )］,它们被定义为对函数式接口的引用,，这样你就可以将lambda表达式或方法引用传递给Operation的构造器
  ```java
  public class Operation {
    public final Supplier<String> description;
    public final Runnable command;
    public Operation(Supplier<String> descr, Runnable cmd) {
      description = descr;
      command = cmd;
    }
  }
  ```

  对于每种Robot类型，如果为Null————则做一些特殊操作，本例中会提供Robot的确切类型信息 此信息由动态代理捕获:  
  ```
  class NullRobotProxyHandler implements InvocationHandler {
    private String nullName;
    private Robot proxied = new NRobot();
    NullRobotProxyHandler(Class<? extends Robot> type) {
      nullName = type.getSimpleName() + " NullRobot";
    }
    private class NRobot implements Null, Robot {
      @Override
      public String name() { return nullName; }
      @Override
      public String model() { return nullName; }
      @Override public List<Operation> operations() {
        return Collections.emptyList();
      }
    }
    @Override public Object
    invoke(Object proxy, Method method, Object[] args)
      throws Throwable {
      return method.invoke(proxied, args);
    }
  }
  public class NullRobot {
    public static Robot
    newNullRobot(Class<? extends Robot> type) {
      return (Robot)Proxy.newProxylnstance(
        NullRobot.class.getClassLoader(),
        new Class[]( Null.class, Robot.class },
        new NullRobotProxyHandler(type));
    }
    public static void main(String[] args) {
      Stream.of(
        new SnowRobot("SnowBee"),
        new NullRobot( SnowRobot.class)
      ).forEach(Robot::test);
    }
  }
  ```
  ```java
  /*输出:
  Robot name: SnowBee
  Robot model: SnowBot Series 11
  SnowBee can shovel snow
  SnowBee shoveling snow
  SnowBee can chip ice
  SnowBee chipping ice
  SnowBee can clear the roof
  SnowBee clearing roof
  [Null Robot]
  Robot name: SnowRobot NullRobot
  Robot model: SnowRobot NullRobot
  */
  ```
  - 每当需要一个空的Robot对象时，调用newNullRobot()即可,传递给它想要的Robot类型.它会返回一个代理
  - 代理会同时满足Robot和Null接口的要求，并提供它所代理的类型的特定名称

# 模拟对象和桩
  模拟对象(Mock Object)和桩(Stub )是Optional的逻辑变体。  
  这两个都是在最终的程序中使用的“实际”对象的代理。  
  模拟对象和桩都假装是提供真实信息的实际对象.而不会像Optional那样隐藏对象,甚至包括null对象。  

  模拟对象和桩之间的区别在于程度的不同 模拟对象往往是轻虽级和自测试的.通常我们创建很多模拟对象是为了处理各种不同的测试情况。  
  桩只返回桩数据，它通常是重虽级的，并且经常在测试之间重用。  
  桩可以根据它们的调用方式.通过配置逬行更改。所以桩是一个复杂的对象，它只做一件事情  
  如果你需要做很多事情，通常会创建很多小而简单的模拟对象  

# 接口和类型信息
  interface关键字的一个重要目标是允许程序员隔离组件，从而减少耦合。如果只和接口通信，那么就可以实现这一目标。  
  但通过类型信息可能会绕过它————接口并不一定保证解耦  
  ```java
  public interface A {
    void f();
  }
  class B implements A {
    @Override public void f() {}
    public void g() {}
  }
  public class InterfaceViolation {
    public static void main(String[] args) {
      A a = new B();
      a.f();
      // a.g(); //编译错误
      System.out.printin(a.getClass().getName());
      if(a instanceof B) {
        B b = (B)a;
        b.g();
      }
    }
  }
  ```
  ```java
  /*输出：
  B
  */
  ```

  一种解决方案是直接声明，如果程序员决定使用实际的类而不是接口，他们就得自己承担后果。  
  在许多情况下这可能是合理的，但如果事实并非如此，你就需要实施更严格的控制。  

  最简单的方法是使用包访问权限来实现，这样包外的客户就看不到它了:  
  ```java
  class C implements A {
    @Override public void f() {
      System.out.printLn("public C.f()");
    }
    public void g() {
      System.out.printLn("public C.g()");
    }
    void u() {
      System.out.println("package C.u()");
    }
    protected void v() (
      System.out.printin("protected C.v()");
    }
    private void w() {
      System.out.println("private C.w()");
    }
  }

  public class HiddenC {
    public static A makeA() ( return new C(); }
  }
  ```
  - 类HiddenC是这个包唯一的public部分，调用它时会生成一个A接口
  - 即使makeA()返回了一个C类型，在包外仍然不能使用除A外的任何爭物，因为你不能在包外命名C

  ```java
  public class Hiddenlmplementation {
    public static void main(String[] args) throws Exception {
      A a = HiddenC.makeA();
      a.f();
      System.out.println(a.getClass ().getName());
      //编译错误：无法找到符号'C'：
      /* if(a instanceof C) {
        C c = (C)a;
        c.g();
      } */
      //呀！反射仍然允许我们週用g()：
      callHiddenMethod(a, "g");
      //拄至访问权限更小的方法：
      callHiddenMethod(a, "u");
      callHiddenMethod(a, "v");
      callHiddenMethod(a, "w");
    }
    static void
    callHiddenMethod(Object a, String methodName)
    throws Exception {
        Method g =
          a.getClass().getDeclaredMethod(methodName);
        g.setAccessible(true);
        g.invoke(a);
    }
  }
  ```
  ```java
  /*输出:
  public C.f()
  reflection.packageaccess.C
  public C.g()
  package C.u()
  protected C.v()
  private C.w()
  */
  ```
  - 你仍然可以使用反射来访问并调用所有的方法，甚至包括private的方法！如果你知道方法的名称，就可以通过调用Method对象的setAccessible(true)来设置，从而让这个方法可以被调用

  你可能认为通过仅发布已编译的代码可以防止这种情况，但这不是解决方案。只需要运行JDK自带的反编译器javap就能绕过它：  
  `javap -private C`   -private标志表示需要显示所有成员，甚至包括私有成员  
  输出如下：  
  ```shell
  class reflection.packageaccess.C extends
  java.lang.Object implements reflection.interfacess.A {
    reflection.packageaccess.C();
    public void f();
    public void g();
    void u();
    protected void v();
    private void w();
  }
  ```

  将接口实现为私有内部类或匿名类都无法阻止反射进入并调用非公共访问权限的方法（看来没有任何方法）  
  
  对于字段，甚至是private的字段，也是如此:  
  ```java
  class WithPrivateFinalField {
    private int i = 1;
    private final String s = "I'm totally safe";
    private String s2 = "Am I safe?";
    @Override public String toString() {
      return "i = " + i + ", " + s + ", " + s2;
    }
  }
  public class ModifyingPrivateFields {
    public static void
    main(String[] args) throws Exception {
      WithPrivateFinalField pf =
        new WithPrivateFinalField():
      System.out.println(pf);
      Field f = pf.getClass().getDeclaredField("i");
      f.setAccessible(true);
      System.out.println(
        "f.getlnt(pf): " + f.getlnt(pf));
      f.setlnt(pf, 47);
      System.out.printtn(pf);
      f = pf. getClass(). getDeclaredField("s");
      f.setAccessible(true);
      System.out.printLn ("f .get(pf): " + f.get(pf));
      f.set(pf, "No, you're not!");
      System.out.println(pf);
      f = pf.getClass().getDeclaredField("s2");
      f.setAccessible(true);
      System.out.printIn("f.get(pf): " + f.get(pf));
      f.set(pf, "No, you're not!");
      System.out.println(pf);
    }
  }
  ```
  ```java
  /*输出:
  i=1, I'm totally safe, Am I safe?
  f.getlnt(pf): 1
  i = 47, I'm totally safe, Am I safe?
  f.get(pf): I'm totally safe
  i = 47, I'm totally safe. Am I safe?
  f.get(pf): Am I safe?
  i = 47, I'm totally safe, No, you're not!
  */
  ```
  - final字段实际上是安全的,不会发生变化.运行时系统在接受任何更改尝试时并不会报错，但实际上什么也不会发生

  一般来说,这些访问违规并不是世界上最槽糕的事情。如果有人使用这种技术来调用你标记为private或包访问权限的方法（即这些方法不应该被调用）,那么当你更改这些方法的某些方面时，他们就不应该抱怨。  
  此外.Java语言提供了一个后门来访问类.这一事实可以让你能够解决某些特定类型的问题。如果没有这个后门的话，这些问题会谁以解决，甚至不可能解决。反射带来的好处通常很难否认  

  在Python中，你在要隐藏的元素前面放置一个双下划线__,如果尝试在类或包之外访用它.运行时系统就会报错  

# 总结
  反射从匿名的基类引用中发现类型信息。初学者极易误用它.因为在学会使用多态方法调用之前,使用反射可能感觉很合理  

  面向对象编程语言的目的就是，在任何可能的地方都使用多态，而只在必要的时候使用反射。  

  但是，如果想按预期使用多态方法调用，就需要控制基类的定义，因为在扩展程序的时候，你可能会发现基类并未包含自己想要的方法。如果基类来自别人的库，一种解决方案就是反射：你可以继承一个新类，然后添加额外的方法。  
  添加需要新功能的代码,就必须使用反射来检查你的特定类型  

  将某个功能放在基类中可能意味着，为了某个特定类的利益，接口变得不那么合理。  

  最后，反射有时能解决效率问题。假设你的代码使用了多态，但是其中某个对象运行这种通用代码的效率极低。你可以使用反射来选择该类型，然后为其编写特定场景的代码来提高效率。  
  但是，请注意不要过早为提高效率而编程。这是一个诱人的陷阱。最好让程序先运行起来，再考虑它是否运行得足够快，如果想要解决效率问题，则应该使用分析器(profiler )  

  我们还看到，由于反射允许更加动态的编程风格，因此它开创了一个包含各种可能性的编程新世界。  
  为一致的错误报告模型的存在，使我们能够通过反射编写动态代码。当然，尽力编写能够进行静态检查的代码是值得的，如果可以的话就应该这么做。  
  但是动态代码是将Java与C++等语言区分开来的重要工具之一。  
    
