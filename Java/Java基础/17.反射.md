反射可以在程序运行时发现并使用对象的类型信息。  

反射使我们摆脱了只能在编译时执行面向类型操作的限制，并且让我们能够编写一些非常强大的程序  
- 简单反射，它假定你在编译时就已经知道了所有可用的类型
- 复杂的反射，它允许我们在运行时发现和使用类的信息

# 为什么需要反射
  ```mermaid
  graph TD;
  Circle --> Shape;
  Square --> Shape;
  Triangle --> Shape;
  ```
  ```java
  public class Shapes {
    public static void main(String[] args) {
    Stream.of(
      new Circle()，new Square(), new Triangle())
      .forEach(Shape::draw);
    }
  }
  ```
  ```java
  /*输出:
  Circle.draw()
  Square.draw()
  Triangle.draw()
  ```
  - 将一个Shape的子类对象放入Stream<Shape>时，会发生隐式的向上转型
  - 在向上转型为Shape时，这个对象的确切类型信息就丢失了。对于流来说，它们只是Shape类的对象
  - 从技术上讲，Stream<Shape>实际上将所有内容都当作Object保存
  - 当一个元素被取出时，它会自动转回Shape。这是反射最基本的形式，在运行时检查了所有的类型转换是否正确。这就是反射的意思：在运行时，确定对象的类型
  - 反射类型转换并不彻底：Object只是被转换成了Shape.而没有转换为最终的Circle. Square或Triangle。这是因为我们所能得到的信息就是Stream<Shape>里保存的都是Shape
  - 在编译时，这是由Stream和Java泛型系统强制保证的.而在运行时.类型转换操作会确保这一点

  通过复杂反射，你可以査询到某个Shape引用所指的确切类型，从而选择并隔离特殊情况  
  
# Class 对象
  Class对象：特殊对象，包含了与类相关的信息。体现了类型信息在运行时是如何表示的  
  Class对象被用来创建类的所有“常规”对象。  
  Java使用Class对象执行反射，即使是类型转换这样的操作也一样。  
  Class类还有许多其他使用反射的方式  

  程序中的每个类都有一个Class对象。  
  每次编写并编译一个新类时，都会生成一个Class对象（并被相应地存储在同名的.class文件中）  
  为了生成这个对象，Java虚拟机（JVM）使用被称为类加载器（class loader）的子系统  

  类加载器子系统实际上可以包含一条类加载器链，但里面只会有一个原始类加载器(即启动类加载器)。通常来说我们不需要加载器链中的额外加载器，但对于特殊需要（例如以某种方式加载类以支持Web服务器应用程序，或通过网堵来下载类），你可以引入额外的类加载器来实现   

  类在首次使用时才会被动态加载到JVM中。当程序第一次引用该类的静态成员时,就会触发这个类的加载
  构造器是类的一个静态方法，尽管没有明确使用static关键字  

  Java程序在运行前并不会被完全加载，而是在必要时加载对应的部分  
  这种动态加载能力使得Java可以支持很多行为，而它们在静态加载语言（如C++）中很难复制，或根本不可能复制  

  ```java
  class Cookie {
    static { System.out.println("Loading Cookie"); }
  }
  class Gum {
    static { System.out .printIn("Loading Gum"); }
  }
  class Candy {
    static { System.out.printin("Loading Candy"); }
  }
  public class Sweetshop {
    public static void main(String[] args) {
      System.out.println("inside main");
      new Candy();
      System.out.printin("After creating Candy");
      try {
        Class.forName("Gum");
      } catch(ClassNotFoundException e) (
        System.out.println("Couldn't find Gum");
      }
      System.out.println("After Class.forName(\"Gum\")");
      new Cookie():
      System.out.printin("After creating Cookie");
    }
  }
  ```
  ```java
  /*输出：
  inside main
  Loading Candy
  After creating Candy
  Loading Gum
  After Class.forName("Gum")
  Loading Cookie
  After creating Cookie
  */
  ```
  - Class对象仅在需要时才加载，并且静态代码块的初始化是在类加载时执行的

  `Class.forName("Gum");`  
  所有的Class对象都属于Class类。Class对象和其他对象一样，因此你可以获取并操作它的引用(这也是加载器所做的)  
  静态的forName()方法可以获得Class对象的引用,该方法接收了一个包含所需类的文本名称(注意拼写和大小写！)的字符串，并返回了一个Class引用  

  不管什么时候，只要在运行时用到类型信息,就必须首先获得相应的Class对象的引用  
  - Class.forName()方法用起来就很方便了，因为不需要对应类型的对象就能获取Class引用  
  - 如果已经有了一个你想要的类型的对象，就可以通过getClass()方法来获取Class引用，这个方法属于Object根类

  ```java
  import java.lang.reflect.InvocationTargetException;

  interface HasBatteries {}
  interface Waterproof {}
  interface Shoots {}

  class Toy {
    //可以将下面这个无參构造器注释掉来看一下NoSuchMethodError
    public Toy() {}
    public Toy(int i) {}
  }
  class FancyToy extends Toy implements HasBatteries, Waterproof, Shoots (
    public FancyToy() { super(1); }
  }
  public class ToyTest {
    static void printInfo(Class cc) {
      System.out.printin("Class name: " + cc.getName() +
        "is interface? [" + cc.isInterface() + "]");
      System.out.printin(
        "Simple name: " + cc.getSimpleName());
      System.out.println(
        "Canonical name : "+ cc.getCanonicalName());
    }
    @SuppressWarnings("deprecation")
    public static void main(String[] args) {
      Class c = null；
      try {
        c = Class.forName(" reflection.toys.FancyToy");
      } catch(ClassNotFoundException e) {
        System.out.println ("Can't find FancyToy");
        System.exit(1);
      }
      printInfo(c):
      for(Class face : c.getlnterfaces())
        printInfo(face);
      Class up = c.getSuperclass();
      Object obj = null;
      try {
        //对应类要有public的无参构造器：
        obj = up.newInstance();
      } catch(Exception e) {
        throw new
          RuntimeException("Cannot instantiate");
      }
      printInfo(obj .getClass());
    }
  }
  ```
  ```java
  /*输出：
  Class name: reflection.toys.FancyToy is interface?
  [false]
  Simple name: FancyToy
  Canonical name : reflection. toys. FancyToy
  Class name: reflection.toys.HasBatteries is interface?
  [true]
  Simple name: HasBatteries
  Canonical name : reflection. toys.HasBatteries
  Class name: reflection. toys .Waterproof is interface?
  [true]
  Simple name: Waterproof
  Canonical name : reflection. toys .Waterproof
  Class name: reflection.toys.Shoots is interface? [true]
  Simple name: Shoots
  Canonical name : reflection. toys.Shoots
  Class name: reflection.toys.Toy is interface? [false]
  Simple name: Toy
  Canonical name : reflection. toys .Toy
  */
  ```
  - 传递给forName()的字符串参数必须是类的完全限定名称(包括包名称)
  - getName()和getCanonicalName()生成完全限定的类名
  - getSimpleName()生成不带包的名称
  - isInterface()可以告诉你这个Class对象是否表示一个接口
  - Class.getInterfaces()方法返回了一个Class对象数组,它们表示你感兴趣的这个Class对象的所有接口
  - getSuperclass()查询Class对象的直接基类
  - Class的newlnstance()方法是实现“虚拟构造器”的一种途径，这相当于声明“不知道你的确切类型，但无论如何你都要正确地创建自己”

  newInstance()在Java 8中还是正常的，但在更高版本中已被弃用，Java 推荐使用 Constructor.newInstance()来代替  
  示例中我们使用了@SuppressWarnings("deprecation")来抑制那些更高版本的弃用警告  
    
## 类字面量
  Java还提供了另一种方式来生成Class对象的引用：类字面量(class literal)  
  `FancyToy.class;`  
  这更简单也更安全，因为它会进行编译时检查(因此不必放在try块中)。另外它还消除了对forName()方法的调用，所以效率也更高  
  
  类字面量适用于常规类以及接口、数组和基本类型。每个基本包装类都有一个名为TYPE的标准字段。TYPE字段表示一个指向和基本类型对应的Class对象的引用  
  | 类字面量 | 等价于 |  
  | boolean.class | Boolean.TYPE |  
  | char.class | Character.TYPE |  
  | byte.class | Byte.TYPE |  
  | short.class | Short.TYPE |  
  | int.class | Integer.TYPE |  
  | long.class | Long.TYPE |  
  | float.class | Float.TYPE |  
  | double.class | Double.TYPE |  
  | void.class | Void.TYPE |  
  
  使用“.class”的形式创建Class对象的引用时，该Class对象不会自动初始化。  
  初始化被延迟到首次引用静态方法（构造器是隐式静态的）或非常量静态字段时————lazy initializaton:  
  ```java
  class Initable {
    static final int STATIC_FINAL = 47;
    static final int STATIC_FINAL2 = 
      Classinitialization.rand.nextInt(1000);
    static {
      System.out.println("Initializing Initable");
    }
  }

  class Initable2 {
    static int staticNonFinal = 147;
    static {
      System.out.println("Initializing Initable2");
    }
  }

  class Initable3 {
    static int staticNonFinal = 74;
    static {
      System.out.println("Initializing Initable3");
    }
  }

  public class Classinitialization {
    public static Random rand = new Random(47);
    public static void main(String[] args) throws Exception {
      Class initable = Initable.class;
      System.out.println("After creating Initable ref");
      //不会触发初始化
      System.out.println(Initable.STATIC_FINAL);
      //触发初始化
      System.out.printin(Initable.STATIC_FINAL2);
      //触发初始化
      System.out.printin(Initable2.staticNonFinal);
      Class initable3 = Class.forName("Initable3");
      System.out.printin("After creating Initable3 ref");
      System.out.println(Initable3.staticNonFinal);
    }
  }
  ```
  ```java
  /*输出:
  After creating Initable ref
  47
  Initializing Initable
  258
  Initializing Initable2
  147
  Initializing Initable3
  After creating Initable3 ref
  74
  */
  ```
  - 仅使用.class语法来获取对类的引用不会导致初始化
  - 而Class.forName()会立即初始化类以产生Class引用
  - 如果一个static final字段的值是“编译时常量”,比如Initable.staticFinal,那么这个值不需要初始化Initable类就能读取
  - 但是把一个字段设置为static和final并不能保证这种行为：对Initable.staticFinal2的访问会强制执行类的初始化，因为它不是编译时常量

## 泛型类的引用
  一个Class引用表示的就是它所指向的确切类型：Class类的一个对象  
  Class引用指向的是一个Class对象，该对象可以生成类的实例，并包含了这些实例所有方法的代码。它还包含该类的静态字段和静态方法

  你可以使用泛型语法来限制Class引用的类型：  
  ```java
  public class GenericClassReferences {
    public static void main(String[] args) {
      Class intClass = int.Class;
      intClass = double.class;
      Class<Integer> genericIntClass = int.class;
      genericIntClass = Integer.class; // 一样
      // genericIntClass = double.class; // 不合法
    }
  }
  ```
  - 通过使用泛型语法，可以让编译器强制执行额外的类型检查

  `Class<Number> genericNumberClass = int.class;`  
  - 实际上这段代码无法运行,Integer的Class对象不是Number的Class对象的子类

  要想放松使用泛化的Class引用时的限制，请使用通配符`?`，它是Java泛型的一部分,表示“任何事物”  
  ```java
  public class WildcardClassReferences {
    public static void main(String[] args) {
      Class<?> intClass = int.class;
      intClass = double.class;
    }
  }
  ```
  - 和普通的Class相比，我们还是倾向于Class<?>,即使它们是等价的
  - Class。〉的好处在于.它表明了你不是偶然或无意识地使用了非具体的类引用。你就是选择了这个非具体的版本

  想创建一个Class引用，并将其限制为某个类型或任意子类型，可以将通配符与extends关键字组合来创建一个界限（bound ）：  
  ```java
  public class BoundedClassReferences {
    public static void main(String[] args) {
      Class<? extends Number> bounded = int.class;
      bounded = double.class;
      bounded = Number.class;
      //或者任何继承了 Number的类
    }
  }
  ```
  - 将泛型语法添加到Class引用的一个原因是提供编译时的类型检查
  - 这样的话，如果你做错了什么.那么很快就能发现

  ```java
  class ID {
    private static long counter;
    private final long id = counter++;
    ©Override public String toString() {
      return Long.toString(id);
    }
    // 如果想要调用 getConstructor().newlnstance(),
    // 就主要提供一个public的无参构造器：
    public ID() {}
  }
  public class DynamicSupplier<T> implements Supplier<T> {
    private Class<T> type;
    public DynamicSupplier(Class<T> type) {
      this.type = type;
    }
    ©Override public T get() {
      try {
        return type.getConstructor().newInstance();
      } catch(Exception e) {
        throw new RuntimeException(e);
      }
    }
    public static void main(String[] args) {
      Stream.generate(
        new DynamicSupplier<>(ID.class))
        .skip(10)
        .limit(5)
        .forEach(System.out::printin);
    }
  }
  ```
  ```java
  /*输出：
  10
  11
  12
  13
  14
  */
  ```
  - DynamicSupplier会强制要求它使用的任何类型都有一个public的无参构造器(一个没有参数的构造器),因为Constructor().newInstance()调用的是无参构造器
  - 在上面的例子中，ID自动生成的无参构造器不是public的，因为ID类不是public的，所以我们必须显式定义它

  对Class对象使用泛型语法时，newInstance()会返回对象的确切类型，而不仅仅是简单的Object  
  ```java
  Class<FancyToy> ftc = FancyToy.class;
  //生成确切的类型：
  FancyToy fancyToy = ftc. getConstructor().newInstance();
  Class<? super FancyToy> up = ftc.getSuperclass();
  //下面的代码无法通过编译：
  // Class<Toy> up2 = ftc.getSuperclass();
  //只能生成Object
  Object obj = up.getConstructor().newInstance();
  ```
  - 编译器只允许你声明这个基类引用是“FancyToy的某个基类”，就像表达式Class<? super FancyToy>所声明的那样

## cast()方法
  ```java
  class Building {}
  class House extends Building {}

  public class ClassCasts {
    public static void main(String[] args) {
      Building b = new House();
      Class<House> houseType = House.class;
      House h = houseType.cast(b);
      h = (House)b;       //或者直接这样进行转型
    }
  }
  ```
  - cast()在你不能使用普通类型转换的情况下很有用。如果你正在编写泛型代码,并旦存储了一个用于转型的Class引用，就可能会遇到这种情况(Class引用不能使用普通类型转换)

  Class.asSubclass()会将类对象转换为更具体的类型  

# 转型前检查
  - 传统的类型转换 比如“（Shape）”.它使用反射来确保转型是正确的：如果你执行了错误的转型，它会抛出一个ClassCastException
  - 代表对象类型的Class对象。你可以查询Class对象来获取有用的运行时信息

  在Java中，的确会执行类型检查，这种转型通常称为“类型安全向下转型”（type-safe downcast）  
  如果不使用显式的类型转换来告诉编译器这是一个特定的类型，编译器就不会允许执行向下转型赋值操作（编译器会检查该向下转型操作是否合理.因此它不会让你向下转型为实际上不是其子类的类型）  

  第三种形式的反射：  
  关键字instanceof,它返回一个boolean值,表明一个对象是否是特定类型或其子类的实例  

  当没有其他信息可以告诉你对象类型的时候，在向下转型之前使用instanceof很重要  
  
  ```
  public class Pet extends Individual {
    public Pet(String name) { super(name); }
    public Pet() { super(); }
  }
  ...
  ```
  - 我们必须在每种情况下都显式地编写无参构造器。因为每个类都有一个带参数的构造器，这阻止了编译器自动生成无参构造器（只有没有任何构造器的类才会隐含生成无参构造器）

  ```java
  private Random rand = new Random(47);
  //创定不同类型的Pet：
  public abstract List<Class<? extends Pet>> types();
  ©Override public Pet get () {         // 创止一个随机的 Pet 对象
    int n = rand.nextlnt(types().size());
    try {
      return types().get(n)
        .getConstructor().newInstance();
    } catch(InstantiationException |
        NoSuchMethodException |
        InvocationTargetException |
        IllegalAccessException e) {
      throw new RuntimeException(e);
    }
  }
  ```
  - List的泛型参数被指定为“继承了 Pet的任意子类”，因此newInstance()无须类型转换即可生成一个Pet

  ```java
  @SuppressWarnings("unchecked")
  private static void loader() {
    try {
      for(String name : typeNames)
      types.add(
        (Class<? extends Pet>)Class.forName(name));
    } catch(ClassNotFoundException e) {
      throw new RuntimeException(e);
    }
  }
  ```
  - loader()方法使用Class.forName()来创建-个Class对象的列表,可能会抛出ClassNotFoundException。这是合理的.因为你传递给它的是一个在编译时无法验证的字符串
  - @SuppressWarnings("unchecked")注解不能直接用于静态初始化块

  instanceof有一个相当严格的限制：只能将其与类型名称进行比较，而不能与一个Class对象进行比较  

## 使用类字面量
  ```java
  //不需要try块
  public static final
  List<Class<? extends Pet» ALL_TYPES =
    Collections. unmodifiabl.eList(Arrays.asList(
      Pet.class, Dog.class, Cat.class, Rodent.class,
      Mutt.class, Pug.class, EgyptianMau.class,
      Manx.class, Cymric.class, Rat.class,
      Mouse.class, Hamster.class));
  ```

## 动态的 instanceof————Class.isInstance()
  Class.isInstance()方法提供了一种动态验证对象类型的方式:  判断对象是否是特定类型及其子类的实例
  ```java
  public class PetCounter3 {
    static class Counter extends HashMap<Class<? extends Pet>, Integer> {
      Counter() {
        super(PetCreator.ALL_TYPES.stream()
          .map(type -> Pair.make (type, 0))
          .collect(
            Collectors.toMap(Pair::key, Pair::value)));
      }
      public void count(Pet pet) (
        // Class.isInstance()消除了大量的 instanceof：
        entrySet().stream()
        .filter(pair -> pair.getKey().isInstance(pet))
        .forEach(pair ->
          put (pair.getKey(), pair.getValue() + 1))；
      }
      @Override public String toString() {
        String result = entrySet().stream()
          .map(pair -> String.format("%s=%s",
            pair.getKey().getSimpleName(),
            pair.getValue()))
          .collect(Collectors.joining(", "))；
        return "{" + result + "}";
      }
    }

    public static void main(String[] args) {
      Counter petCount = new Counter();
      new PetCreator().stream()
        .limit(20)
        .peek(petCount::count)
        .forEach(p -> System.out.print(
          p.getClass().getSimpleName() + " "));
      System.out.println("\n" + petCount);
    }
  }
  ```
  ```java
  /*输出:
  Rat Manx Cymric Mutt Pug Cymric Pug Manx Cymric Rat
  EgyptianMau Hamster EgyptianMau Mutt Mutt Cymric Mouse
  Pug Mouse Cymric
  {EgyptianMau=2, Mouse=2, Pet=20, Cymric=5, Rat=2,
  Dog=6, Mutt=3, Hamster=l, Cat=9, Manx=7, Rodent=5,
  Pug=3}
  */
  ```
  - isInstance()方法使我们不再需要instanceof表达式
  - 此外，这还意味着，如果想添加新的Pet类型，只需要更改PetCreator.types数组就可以,程序的其余部分不需要修改(但在使用instanceof表达式时就不可以)

## 递归计数
  使用Class.isAssignableFrom()方法代替Map的预加载，来创建一个并不仅限于对Pet进行计数的通用工具：  
  ```java
  import java.util.*;
  import java.util.stream.*;
  
  public class
  TypeCounter extends HashMap<Class<?>, Integer> {
    private Class<?> baseType;
    public TypeCounter(Class<?> baseType) (
      this.baseType = baseType;
    }
    public void count(Object obj) {
      Class<?> type = obj.getClass();
      if (!baseType.isAssignableFrom(type))
        throw new RuntimeException(
          obj + " incorrect type: " + type +
          " should be type or subtype of " + baseType);
      countClass(type);
    }
    private void countClass(Class<?> type) {
      Integer quantity = get(type);
      put(type, quantity == null ? 1 : quantity + 1);  
      Class<?> superclass = type.getSuperclass();
      if(superclass != null &&
        baseType.isAssignableFrom(superClass)) {
        countClass(superClass);
      }
    }
    @Override public String toString() {
      String result = entrySet().stream()
        .map(pair -> String.format("%s=%s",
          pair.getKey().getSimpleName(),
          pair.getValue()))
        .collect(Collectors.joining(", "));
      return "(" + result + "}";
    }
  }

  public class PetCounter4 {
    public static void main(String[] args) {
      TypeCounter counter = new TypeCounter(Pet.class);
      new PetCreator().stream()
        .limit(20)
        .peek(counter::count)
        .forEach(p -> System.out.print(
          p.getClass().getSimpleName() + ""))；
      System.out.println("\n" + counter);
    }
  }
  ```
  ```java
  /*输出：
  Rat Manx Cymric Mutt Pug Cymric Pug Manx Cymric Rat
  EgyptianMau Hamster EgyptianMau Mutt Mutt Cymric Mouse
  Pug Mouse Cymric
  (Rodent=5, Mouse=2, Hamster=l, Cymric=5, Dog=6,
  EgyptianMau=2, Pet=20, Rat=2, Pug=3, Manx=7, Cat=9,
  Mutt=3}
  */
  ```

# 注册工厂
  
    





















