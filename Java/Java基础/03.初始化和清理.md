# 构造器
  在类中与类名相同的方法
  
# 方法重载
  方法名相同，但以不同的参数列表区分。例：重载构造器
  
# this关键字（只能在非static方法中使用）
  用途：将当前对象传递给另一个对象/类的方法（外部方法）

# 构造器中调用构造器
  1. 不能同时使用this调用两个另外的构造器
  2. 构造器调用必须出现在构造器方法最开始的部分，否则编译器报错
  3. 若方法参数与成员属性重名，则用this.属性名表示类成员数据 例：this.s = s
  4. 非构造器方法不允许调用构造器
  ```java
  类名(...){
    this('xxx');     //this()自动匹配参数列表匹配的构造器
    ...
  }
  ```

# 清理和垃圾收集
  详见  
  - [Java/Java高阶/02. JVM/02.JVM 的内存区域(Runtime Date Area)是如何划分的.md](https://github.com/jinlemon7/learning_Display/blob/25080b2a5b8f39e2d7ba3c452a885d7ab2e1cb73/Java/Java%E9%AB%98%E9%98%B6/02.%20JVM/02.JVM%20%E7%9A%84%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F(Runtime%20Date%20Area)%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%92%E5%88%86%E7%9A%84.md)  
  - [Java/Java高阶/02. JVM/03.Java 中有哪些垃圾回收算法.md](https://github.com/jinlemon7/learning_Display/blob/25080b2a5b8f39e2d7ba3c452a885d7ab2e1cb73/Java/Java%E9%AB%98%E9%98%B6/02.%20JVM/03.Java%20%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95.md)  

# 成员初始化
  <img width="547" height="578" alt="image" src="https://github.com/user-attachments/assets/59f264a4-d4fb-46ac-b7ab-e334348fe0c5" />

  上图为Java默认初始化（Java自动执行）。  
  指定初始化：代码定义时或定义后由客户程序员指定初始值。  

# 构造器初始化
  构造器初始化规则：  
  - 任何指定初始化前，均先执行Java默认初始化（针对示例变量而言，不包括static初始化）
  - 类中变量初始化在全部方法（包括构造器）调用之前完成，与代码文本位置无关
  - static变量只在第一次对象创建/被访问时执行初始化，后续不会再初始化。 （因为类属性/方法只有1份内存，所有对象共享）
  - 静态字段优先被初始化（最初1次），非静态字段之后被初始化（每次new新对象），与代码文本位置无关

  创建对象的初始化顺序：假设有一个Dog对象  
  1. 尽管没有显式使用static关键字，但构造器实际上是static方法。  
     所以第一次创建Dog对象或访问Dog的静态字段/方法时，Java解释器（interpreter）会搜索路径定位Dog.class文件（存于metaSpace中）。
  2. new Dog()创建对象时，首先在堆上分配足够内存（JVM加载机制的“准备”步骤）
  3. 清空分配的内存，执行Java默认初始化（JVM加载机制的“准备”步骤）
  4. 所有静态初始化工作执行（JVM加载机制的“初始化”步骤）
  5. 执行指定初始化
  6. 执行构造器

# 显式的静态初始化
  ```java
  static int i;
  static{
    i = 47;             //用static{}显示声明static初始化
  }
  ```

# 实例初始化（非静态）
  ```java
  int i;
  {
    i = 47;           //用{}声明示例初始化
  }
  ```

# 数组初始化
  数组通过索引操作符：方括号[] 来使用和定义  
  例：`int[] a = {1, 2, 3, 4}`  

  动态数组创建：`new`      //new只能创建对象/容器，不能创建基本类型  

  例：Integer[] a = new Integer[rand.nextInt(20)];  //nextInt()中输入整数  
      int[] b = new int[20];   
      Integer[] c = new Integer[] {1, 2, 3};   //{1, 2, 3}可直接作参数进行传递  

# 可变参数列表
  1. Object数组 （所有类都继承Object）  
     例：`f(Object[] args)`
  2. 省略号(...)  
     例：`f(Object... args)`
  3. 多个（>2）重载方法使用了可变参数列表时（不含无参方法）  
     f()不带参数调用会产生编译报错  
     所以最好只在1个重载方法上用可变参数列表，或者不使用

# 枚举类型：一种特殊类，有自己的方法
  - name()：返回常量的名称字符串
  - ordinal()：enum的声明顺序
  - values()：返回声明顺序的enum常量值数组，类似Map的values()

  关键字：enum
  ```java
  public enum Name{      //没有参数列表
    A, B, C, D, E        //包含5个命名值：常量
  }
  ```

# 局部变量类型推断（type inference）
  ```java
  void f(){
    var s = "hello";          //var关键字，编译器自动发现类型
  }
  ```
  1. 静态方法也允许类型推断
  2. 只使用局部变量（方法内定义的变量），不适用于任何成员变量
  3. 必须有初始化右值，不能不提供右值或右值为null
