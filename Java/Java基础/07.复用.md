- 组合
- 继承

# 组合语法：将对象引用放在新类中
  非基本类型：对象引用放新类。  
  基本类型：直接定义。  

  引用的Java默认初始化为null，编译器不会为每个引用都创建一个对象（减少开销）
  1. 定义时初始化            //构造器之前
  2. 构造器中初始化
  3. 实例初始化              //对于实例变量而言，方法之前
  4. 实际使用之前初始化      //延迟初始化

# 继承：entends
  ```mermaid
  graph TD;
  子类 --> 基类;
  ```
  创建一个类时，总是在继承（隐式继承根类Object）  
  Object根类的成员：  
  - equals()
  - hashCode()
  - toString()
  - getClass()
  - notify()
  - notifyAll()
  - wait()

  继承获得基类所有字段和方法。  
  成员访问控制一般规则：  
  1. 字段都是private
  2. 方法都是public
  3. 使用protected动态调整

  子类构造器中调用父类构造器不能简单调用A()       //产生递归调用  
  要使用super关键字：`super.A()`  
  子类可以重写来修改基类的方法，也可以创建新方法。  

## 初始化基类
  创建子类对象时，里面包含了一个基类的子对象subObject  
  与基类对象一样，只是被包裹在子类对象中。  
  
  所以正确初始化基类很重要：调用基类构造器进行初始化，它具有基类初始化的全部信息和权限  
  Java会自动在子类构造器中插入对基类构造器的调用（隐式），满足条件：  
  基类有无参构造器或没有任何构造器，子类新建有参/无参构造器均会隐式插入super()来调用父类的无参构造器  
  Java会自动在子类构造器中插入时对基类构造器的调用（隐式），一种情况除外，见下面的#带参数的构造器。  

## 带参数的构造器
  若基类只有有参构造器并且子类要创建有参构造器，则必须使用super关键字和参数列表显式调用基类构造器。  
  PS：构造器的super调用要在第1行！  
  否则编译器报错。  

# 委托
  Java虽然没有提供直接支持，但除了组合和继承，还有第三种关系——委托。  
  既将成员对象放在类中（类似组合），又在新类里公开对象的所有方法（类似继承）。  
  ```java
  public class B{
    private A a = new A();
    public b(){...}
    public void f1(int v){         //委托方法
      a.f1(v);                     //方法被转发到了内部的a对象，这里的接口与继承得到的是相同的，但是可以更好地控制委托
    }                              //例如仅提供a对象的部分方法
    public void f2(int v){
      a.f2(v);
    }
  }
  ```

# 组合与继承相结合
  客户程序员经常用到组合和继承，将类分离清晰，轻松复用它们。（最多只需要导入一个包）  

## 确保正确的清理
  虽然有GC，但是如果要显式定义清理活动，要将清理活动放在finally字句里，预防异常处理。  
  这种清理活动在处理非内存事物时很有必要。  
  PS：Object的finalize()方法已废弃，不要使用和重写。  

##  名称隐藏
  - 重载：方法名相同，参数列表不同即可（参数类型、个数、顺序不同）
  - 重写：方法名相同，参数列表、返回类型都相同，方法体不同

  重写（ Override ）：  
  1. 发生在父类/子类之间
  2. 方法名、参数列表、返回类型必须形同
  3. 重写方法的访问修饰符的访问性一定要 >= 被重写方法的访问修饰符  
     继承期间方法的访问性不能降低：public > protected > 包访问权限（default） > privae  
  4. 重写方法的检查异常不能比被重写方法 更新或更宽泛

  重载（Overload）：  
  1. 同名、参数列表不同（方法签名：名称 + 参数列表）
  2. 重载方法的返回类型与被重载方法相比，可相同可不相同，不作为重载区分标准。

  Java基类的方法重载无论多少次，在父类还是子类中，所有版本的重载都有效。   
  
  @Override注解当重写时可使用，可像关键字一样使用。也可防止重写变重载（重载时报错）。 

# 选择组合还是继承
  组合和集成都会将基类子对象放置在新类中。组合是显式执行此操作，继承时隐式执行。  

  - 使用组合"has-a"：在新类中使用现有类的功能：在新类中嵌入一个对象（private 或 public）
  - 使用继承"is-a"：在新类中使用现有类的接口

# protected关键字
  能有private就用private，protected完全为了实用主义：为了被修饰成员可以被子类和同一包内其他类使用。  

# 向上转型
  ```java
  class Instrument {
    public void play() {}
    static void tune(Instrument i) {
      // ...
      i.play();
    }
  }

  // Wind对象也是instrument,因为它们有相同的接口:
  public class Wind extends Instrument {
    public static void main(String[] args) {
      Wind flute = new Wind();
      Instrument .tune(flute): // 向上转型
    }
  }
  ```

  基类的方法调用传入子类引用参数，这种将子类引用转换为基类引用的行为叫向上转型。  
  子类是基类的超集，因为子类可能包含更多的方法。  
  
  因此，向上转型总是安全的，向上转型期间，只会丢失方法，不会获得方法。  
  向上转型不需要显式转换或特殊符号。向下转型需要显式强制转换。  

## 判断使用继承还是组合
  1. 尽可能不使用继承，只有必须使用继承时，谨慎使用它
  2. 如果必须"向上转型"，则继承是必要的。 使用继承时问一句“需要向上转型吗”

# final关键字
  表示字段/方法/类时无法更改的。使用final的原因：  
  - 设计
  - 效率

## final字段
  告诉编译器某个字段是“恒定的”，即常量：  
  1. 编译时常量
  2. 运行时常量

  编译时常量将一些计算在编译时进行，减少运行时开销。  
  static final的字段会产生一块唯一（内存只有一个）且不可变（一旦初始化就固定）的内容空间  
  - final 基本类型：定义常量必须始终是一个值。使值不可变，可在声明时或构造器给出这个值
  - final 对象/数组引用：使引用不可变，不能更改为指向其他对象，对象本身是可以改变的！  
    要使对象恒定不变，可以编写具体类。

  常量命名规则：全部大写字母，单词间用下划线"_"连接  

  字段是final的，也可能在编译时值不可知，例：`final int a =  rand.nextInt(20);`  ————典型的运行时常量  
  只有在运行时随机生成数来进行初始化，后续不可改。  
  - static final：不同对象的该字段始终一样（一个类初始化一次）
  - final：不同对象的该字段可能不一样（一个对象初始化一次）

### 空白final
  没有初始值的final字段，都要在构造器中赋值。  
  编译器保证final字段在使用前总是被初始化，否则报错。  

### final参数
  在参数列表中声明创建final参数  
  - final 对象/数组：引用指向内容不可改，不可" = new A() "，只能赋值已有的地址。
  - final 基本类型：只能读，不能改。

### final方法
  1. 在方法放一个“锁”，防止子类通过重写改变方法行为  ————设计原因
  2. Java早期实现中编译器会将对final方法调用转为内联调用（inline call）  ————效率原因  
     代替中断调用，直接复制方法体代码到此处，减小调用开销，但会膨胀代码规模。

  private方法是隐式final的，因为你不能外部访问或重写它。  
  - 在子类写一个与基类private方法同名，同参数列表，同返回类型的方法不会报错，但并非重写。  
    因为基类的private方法不是基类接口的一部分，只是隐藏代码。子类的方法是创建了一个新方法。
    PS：private方法不是类的接口，而是隐藏代码。  
  - 若子类的方法使用@Override注解，则会报出错误消息。
  
## final类
  阻止该类的继承，目的是类的设计永远不要修改。  
  final类中的属性，可以不是/是final；取决于客户程序员的设计，可被外部类访问并修改。  
  但所有的方法都是隐式final的，因为无法继承也就无法重写。  

## 关于final的忠告
  设计类时尽量不要将方法设为final，因为你觉得没有人想重写这个方法  
  但你不能预判其他程序员的想法。  

# 初始化与类的加载
  更传统语言中，程序一次性加载，作为启动过程的一部分，初始化后运行。  
  Java只有在需要某个文件代码的时候才会加载文件。  
  即类的代码只有在第一次使用时才加载。  

  1. 构建类的第一个对象
  2. 访问类的静态字段或静态方法（包括构造器，隐含static），例如程序入口：  
     `public static void main(String[] args)`  

## 继承与初始化 
  ```mermaid
  graph TD;
  子类 --> 基类;
  ```

  运行子类文件：  
  1. 访问B.main()，加载B（JVM加载机制）
  2. 注意到B有基类，加载基类A
  3. A的静态字段初始化（文本顺序）    //静态成员在程序运行周期中只初始化这一次！
  4. B的静态字段初始化（文本顺序）

  在B.main()中创建B对象，执行B的构造器（实例化，已执行完JVM加载和静态初始化）：  
  1. B的基本类型和引用执行Java默认初始化，之后执行B的构造器
  2. 调用基类构造器（自动/手动），A构造器活动顺序和B一样
  3. B的实例字段初始化（文本顺序）
  4. 执行B构造器的其他部分

# 总结
  - 组合：复用现有类型
  - 继承：复用现有类的接口，可以“向上转型”
  - 委托：用组合获得类，复现方法获得接口

  优先使用组合/委托，仅在必要时使用继承。   
  
