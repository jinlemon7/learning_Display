集合优化了对象的存储,而流（stream）与对象的成批处理有关  

不同于在集合中遍历元素，使用流的时候，我们是从一个管道中抽取元素，并对它们逬行操作。这些管道通常会被串联到一起，形成这个流上的一个操作管线  

```java
public class Randoms {
  public static void main(String[] args) {
    new Random(47)
      .ints(5, 20)
      .distinct()
      .limit(7)
      .sorted()
      .forEach(System.out::println);
  }
}
```
- ints()方法会生成一个流，该方法有多个重载版本，其中两个参数的版本可以设置所生成值的上下界
- 我们使用中间流操作distinct()去掉重复的值，再使用limit()选择前7个值
- sorted()使元素有序
- forEach(),它会根据我们传递的函数，在每个流对象上执行一个操作
- 方法引用System.out::println,用于将各每个条目显示在控制台上

声明式编程/命令式编程是一种编程风格，我们说明想要完成什么(what),而不是指明怎么做(how),这就是我们在函数式编程中看到的  
清晰的表达是应该使用Java 8的流的最有说服力的原因之一  

显式地编写迭代机制，称为外部迭代。而函数式编程看不到任何这样的机制，所以这被称为内部迭代，这是流编程的一个核心特性   
内部迭代产生的代码不仅可读性更好，而且更容易利用多处理器：通过放宽对具体迭代方式的控制，我们可以将其交给某种并行化机制  

流的另一个重要方面是惰性求值，这意味着它们只在绝对必要时才会被求值。   
流元素是一个一个生成，每一个流元素都走完了整个管线才会生成下一个  
我们可以把流想象成一个“延迟列表” 。因为延迟求值，所以流使我们可以表示非常大的（甚至是无限大的）序列，而不用考虑内存问题  

# Java 8对流的支持
  他们有一套现有的库，不仅用在了Java库本身之中，还用在了用户编写的无数代码之中。他们如何将流这个新的基本概念整合到现有的
库中呢？  

  最大的挑战来自使用了接口的库。因为我们想将集合转换为流，所以集合类是至关重要的一部分。  
  但如果向接口中加入新方法，就会破坏每一个实现了该接口，但是没有实现这个新方法的类  

  Java 8引入的解决方案是接口中的默认（default）方法，Java的设计者们可以将流方法硬塞进现有的类中，而且他们几乎把我们可能需要的每个操作都添加进去了。  
  这些操作可分为三种类型：创建流、修改流元素（中间操作）和 终结流（消费流元素）。最后一种类型的操作往往意味着收集一个流的元素（通常是将其放进某个集合）

# 流的创建: Stream.of()和[Collection].stream()
  使用Stream.of(),可以轻松地将一组条目变成一个流  
  ```java
  Stream.of(3.14159, 2.718, 1.618)
    .forEach(System.out::println);
  ```
  ```java
  /*输出：
  3.14159
  2.718
  1.618
  */
  ```

  每个Collection都可以使用stream()方法来生成一个流:  
  ```java
  Set<String> w = new HashSet<>(Arrays.asList(
    "It's a wonderful day for pie!").split(" ")));
  w.stream()
    .map(x -> x + " ")
    .forEach(System.out::print);
  System.out.println();

  Map<String, Doubl> m = new HashMap<>();
  m.put("pi", 3.14159);
  m.put("e", 2.718);
  m.put("phi", 1.618);
  m.entrySet().stream()
    .map(e -> e.getKey() + ": " + e.getValue())
    .forEach(System.out::println);
  ```
  ```java
  /*输出：
  a pie! It's for wonderful day
  phi: 1.618
  e: 2.718
  pi: 3.14159
  */
  ```
  中间的map()操作接受流中的毎个元素，在其上应用一个操作来创建一个新的元素，然后将这个新元素沿着流继续传递下去   
  普通的map()接受对象并生成对象，但是当希望输出流持有的是数值类型的值时,map()还有一些特殊的版本  
  mapToTnt()将一个对象流转变成了一个包含Integer的IntStream。对于Float和Double,也有名字类似的操作  

## 随机数流: Random(...).ints(...).boxed()
  Random类已经得到增强，有一组可以生成流的方法：  
  ```java
  public static <T> void show(Stream<T> stream) {
    stream
      .limit(4)
      .forEach(System.out::println);
    System .out .println ("++++++++");
  }

  public static void main(String[] args) {
    Random rand = new Random(47);
    show(rand.ints().boxed());
  }
  ```
  ```java
  /*输出：
  -1172628779
  1717241110
  -2614573909
  229493722
  */
  ```
  - ints()方法会生成一个流，该方法有多个重载版本，其中两个参数的版本可以设置所生成值的上下界  
  为消除冗余代码,上面的示例创建了泛型方法: show(Stream<T> stream)  
  Random类只会生成int、long和double等基本类型的值  
  boxed()流操作会自动将基本类型转换为其对应的包装器类型,这就使得show()能够接受这个流  

  ```java
  public static void main(String[] args) throws Exception {
    System.out.println(
      Stream.generate (new RandomWords ("Cheese, dat"))
        .limit(10)
        .collect(Collectors.joining(" ")));
  }
  ```
  - collect()操作，它会根据其参数将所有的流元素组合起来  
  - 当我们使用Collectors.joining()时，得到的结果是一个String,每个元素都会以joining()的参数分隔  
  - Stream.generate(),它可以接受任何的Supplier<T>,并生成一个由T类型的对象组成的流

## int类型的区间范围: range(...)
  IntStream类提供了一个range()方法，可以生成一个流————由int值组成的序列  
  ```java
  // for-in搭配一个区间范困：
  result = 0;
  for(int i : range(10, 20) .toArray())
    result += i;
  System.out.println(result);

  //使用流：
  System.out.println(range(10, 20).sum());
  ```
  ```java
  /*输出：
  145
  145
  */
  ```

  为了取代简单的for循环，可自定义repeat()工具函数：  
  ```java
  public class Repeat {
    public static void repeat(int n, Runnable action) {
      range(0, n).forEach(i -> action.run()):
    }
  }
  
  public class Looping {
    static void hi() ( System.out.println("Hi!"); }
    public static void main(String[] args) {
      repeat(3, () -> System.out.println("Looping!"));
      repeat(2, Looping::hi);
    }
  }
  ```
  ```java
  /*输出:
  Looping!
  Looping!
  Looping!
  Hi!
  Hi!
  */
  ```
  然而把repeat()放到自己的代码中，还要向别人解释，这么做可能并不值得。这取决于你的团队和公司的工作方式  

## generate(Supplier<T>)
  Supplier<T> 和 Stream.generate()搭配使用  
  
  如果想创建一个由完全相同的对象组成的流，只需要将一个生成这些对象的lambda表达式传给generate()  
  ```
  public class Duplicator {
    public static void main(String[] args) {
      Stream.generate(() -> "duplicate")
        .linit(3)
        .forEach(System.out::println);
    }
  }
  ```
  ```java
  /*
  duplicate
  duplicate
  duplicate
  */
  ```

  只要被引用方法和与Supplier<T>接口签名兼容：参数类型和返回类型一致，我们就可以将其方法引用传给Stream.generate()  

## iterate()
  Stream.iterate( <T>第一个参数, 函数 )  ————从一个种子开始（第一个参数）.然后将其传给第二个参数所引用的方法  
  其结果被添加到iterate()的返回值：Stream<T>中，并且保存下来作为下一次iterate()调用的第一个参数,以此类推  
  ```java
  public class Fibonacci {
    int x = 1;
    Stream<Integer> numbers() {
      return Stream.iterate(0, i -> {
        int result = x + i;
        x = i;
        return result;
      });
    }

    public static void main(String[] args) {
      new Fibonacci().numbers()
        .skip(20)             //不使用前20个
        .limit(10)             //然后从中取10个
        .forEach(System.out::printin);
    }
  }
  ```
  ```java
  /*输出:
  6765
  10946
  17711
  28657
  46368
  75025
  121393
  196418
  317811
  514229
  */
  ```
  - skip()操作,它会直接丢弃由其参数指定的相应数目的流元素

## 流生成器
  Stream库提供了这样一个FileToWordsBuilder————设计模式：建造者模式（Builder Pattern）  
  ```java
  public class FileToWordsBuilder {
    Stream.Builder<String> builder = Stream. builder();
    public FileToWordsBuilder(String filePath)
    throws Exception {
      Files.lines(Paths.get(filePath))
        .skip(l) //建过开头的注释行
        .forEach(line -> {
          for(String w : line.split("[ .?,]+"))
            builder.add(w);
        });
    }
    Stream<String> stream() ( return builder.build(); )
    public static void main(String[) args) throws Exception {
      new FileToWordsBuilder("Cheese.dat").stream()
      .limit(7)
      .map(w -> w + " ")
      .forEach(System.out::print);
    }
  }
  ```
  - 构造器没有调用build()。这意味着，只要不调用stream(),就可以继续向builder对象中添加单词
  - 如果在调用build()之后还尝试向Stream.Builder中添加单词，则会产生异常

## Arrays
  Arrays类中包含了名为stream()的静态方法，可以将数组转换为流  
  ```java
  public class MetalWork2 {
    public static void main(String(] args) {
      Arrays.stream(new Operation[] {
        () -> Operation.show("Heat"),
        () -> Operation.show("Hammer"),
        () -> Operation.show("Twist"),
        () -> Operation .show("Anneal")
      }).forEach(Operation::execute);
    }
  }
  ```
  ```java
  /*输出：
  Heat
  Hammer
  Twist
  Anneal
  */
  ```

  ```java
  Arrays.stream(
    new int[] { 1, 3, 5, 7, 15, 28, 37 }, 3, 6)
      .forEach(n -> System.out.format("%d ", n));
  ```
  ```java
  7 15 28
  ```
  调用stream(),使用了两个额外的参数：第一个告诉stream()从数组的哪个位置幵始选择元素，  
  第二个告诉它在哪里停止,每个不同类型的stream()方法都有这个版本  

## 正则表达式: Pattern.compile("[ .,?]+").splitAsStream(...)
  Java 8 向 java.util.regex.Pattern类中加入了一个新方法splitAsStream()  
  这里有个约束：splitAsStream()的输入应该是一个CharSequence,所以我们不能将一个流传到splitAsStream()中  
  ```java
  import java.util.regex.Pattern;

  private String all;
  public Stream<String> stream() {
    return Pattern
      .compile("[ .,?]+").splitAsStream(all);
  }
  ```

# 中间操作

## 跟踪与调试: peek()
  peek()操作就是用来辅助调试的。它允许查看流对象而不修改它们：  
  ```java
  class Peeking {
    public static void main(String[] args) throws Exception {
      FileToWords. stream("Cheese.dat")
        .skip(21)
        .limit(4)
        .map(w -> w + " ")
        .peek(System.out::print)
        .map(String：:toUpperCase)
        .peek(System.out::print)
        .map(String::toLowerCase)
        .forEach(System.out::print);
    }
  }
  ```
  ```java
  /*输出:
  Well WELL well it IT it s S s so SO so
  */
  ```
  - peek(System.out::print)的效果显示了流元素是一个一个生成，每一个流元素都走完了整个管线(按照管线的peek()顺序打印)才会生成下一个————惰性求值原则
  - peek()接受的是一个遵循Consumer函数式接口的函数，这样的函数没有返回值.所以也就不可能用不同的对象替换掉流中的对象

## 对流元素进行排序: sorted(...) 
  默认的比较方式：sorted()  
  还有一种接受Comparator参数(可以是签名兼容的lambda)的soited()形式  
  ```java
  public class SortedComparator (
    public static void main(String[] args) throws Exception {
      FileToWords.stream ("Cheese. dat")
        .skip(10)
        .limit(10)
        .sorted(Comparator.reverseOrder())
        .map(w -> w + " ")
        .forEach(System.out::print);
    }
  }
  ```
  ```java
  /*输出:
  you what to the that sir leads in district And
  */
  ```

## 移除元素: distinct(), filter(Predicate)
  - distinct(): 移除了流中的重复元素
  - filter(Predicate)：过滤操作只保留符合特定条件的元素
  ```java
  public static boolean isPrime(long n) {
    return rangeClosed(2, (long)Math.sqrt(n))
      .noneMatch(i -> n % i == 0);
  }

  public LongStream numbers() {
    return iterate(2, i -> i + 1)
      .filter(Prime::isPrime);
  }
  ```
  - rangeClosed()包含了上界
  - 如果没有任何一个取余操作的结果为0,则noneMatch()操作返回true。如果有任何一个计算结果等于0,则返回false。
  - noneMatch()会在第一次失败之后退出，而不会把后面的所有计算都尝试一遍

## 将函数应用于每个流元素: map(Function), mapTotype(...)
  - map(Function)；将Function应用于输入流中的每个对象，结果作为输出流继续传递
  - mapToInt(ToIntFunction):同上，不过结果放在一个 IntStream 中
  - mapToLong(ToLongFunction):同上，不过结果放在一个 LongStream 中
  - mapToDouble(ToDoubleFunction):同上，不过结果放在一个 DoubleStream 中

  map()没有理由要求生成的类型必须与输入的类型相同，所以可以在这里改变这个流的类型
  ```java
  class Numbered {
    final int n;
    Numbered(int n) ( this.n = n; )
    ©Override public String toString() {
      return "Numbered(" + n + ")"；
    }
  }
  class FunctionMap2 {
    public static void main(String[] args) {
      Stream.of(l, 5, 7, 9, 11, 13)
        .map(Numbered::new)
        .forEach(System.out::printin);
    }
  }
  ```
  ```java
  /*输出：
  Numbered(1)
  Numbered(5)
  Numbered(7)
  Numbered(9)
  Numbered(11)
  Numbered(13)
  */
  ```

  如果Function生成的结果类型是某种数值类型，必须使用相应的mapTotype操作来代替:  
  ```java
  Stream.of("5”, "7", "9")
    .mapToInt(Integer::parseInt)
    .forEach(n -> Systern.out.format("%d ", n));
  ```
  ```java
  /*输出:
  5 7 9
  */
  ```

## 在应用map()期间解除流和组合流: flatMap(Function), flatMapTotype(...), typeStream.concat(Stream1, Stream2)
  有时map()生成的是一个流，进入管道经包装变成了由流组成的流。  
  我们想要的是一个由元素组成的流，但生成了一个由元素流组成的流   
  
  flatMap()：接受生成流的函数,并将其应用于传入元素(就像map()所做的那样)，然后再将每个流“扁平化”处理，将其展开为元素，所以传出来的就都是元素了  
  - flatMap(Function)：当Function生成的是一个流时使用
  - flatMapToInt(Function):当 Function 生成的是一个 IntStream 时使用
  - flatMapToLong(Function):当 Function 生成的是一个 LongStieam 时使用
  - flatMapToDouble(Function):当 Function 生成的是一个 DoubleStream 时使用

  ```java
  Stream.of(1, 2, 3)
    .flatMap( i -> Stream.of("Gonzo", "Fozzie", “Beaker"))
    .forEach(System.out::println);
  ```
  ```java
  /*输出：
  Gonzo
  Fozzie
  Beaker
  Gonzo
  Fozzie
  Beaker
  Gonzo
  Fozzie
  Beaker
  */
  ```
  - flatMap()中的映射返回的每个流都会被自动扁平化处理，展开为组成这个流的String元素
  
  ```java
  Stream.of(1, 2, 3, 4, 5)
    .flatMapToIntfi -> IntStream.concat(
      rand.ints(9, 100).limit(i), IntStream.of(-1)))
    .forEach(n -> System.out.format("％d ", n));
  ```
  ```java
  /*输出:
  58 -1 55 93 -1 61 61 29 -1 68 0 22 7 -1 88 28 51 89 9 -1
  */
  ```
  - concat(),它会按照参数的顺序将两个流组合到一起
  - 因为rand.ints()会生成一个IntStream,所以这里必须使用flatMap(). concat()和of()的特殊的Integer版本

  创建一个不需要中间存储的单词流,这正是flatMap()所要解决的问题:  
  ```java
  public static Stream<String> stream(String filePath) throws Exception {
    return Files.lines(Paths.get(filePath))
      .skip(1) //晚辻第一行的注件信息
      .flatMap(line ->
        Pattern. compile("\\W+"). splitAsStream(line));
  }
  ```
  - 正则表达式模式使用的是 \\W+ , 意味着一个“非单词字符” (小写形式\\w指的是“单词字符”)
  - Pattern.compile().splitAsStream()生成的结果是一个流
  - flatMap()可以将元素流组成的流扁平化

  我们可以使用String.split().它会生成一个数组.然后使用Arrays.stream()将其转为流:  
  `.flatMap(line -> Arrays.stream(line.split("\\W+")))`

  毎当我们想要一个新的流时，都必须从头创建，因为流无法复用  

# Optional类型: 特殊流元素类型, Stream调用标准的流操作返回Optional对象
  在流中放入一个null就能轻松破坏掉它   
  Optional类型:既可以作为流元素来占位，也可以在我们要找的元素不存在时友好地告知我们(也就是说，不会抛出异常)  

  某些标准的流操作会返回Optional对象:   
  - findFirst()返回包含第一个元素的Optional。如果这个流为空，则返回Optional.empty
  - findAny()返回包含任何元素的Optional,如果这个流为空，则返回Optional.empty
  - max()和min()分别返回包含流中最大值或最小值的Optional。如果这个流为空,则返回 Optional.empty
  - reduce(BinaryOperator):使用BinaryOperator来组合所有的流元素。因为这个流可能为空，所以返回的是一个Optional
  - 对于数值化的流IntStieam, LongStream和DoubleStream, average()操作将其结果包在一个Optional中，以防流为空的情况
  ```java
  public static void main(String[] args) {
    System.out.println(Stream.<String>empty()
      .findFirst());
    System.out.println(Stream.<String>empty()
      .findAny());
    System.out.println(Stream.<String>empty()
      .max(String.CASE_INSENSITIVE_ORDER));
    System.out.println(Stream.<String>empty()
      .min(String.CASE_INSENSITIVE_ORDER));
    System.out.println(Stream.<String>empty()
      .reduce((si, s2) -> si + s2));
    System.out.printLn(IntStream.empty()
      .average());
  }
  ```
  ```java
  /*输出：
  Optional.empty
  Optional.empty
  Optional.empty
  Optional.empty
  Optional.empty
  OptionalDouble.empty
  */
  ```
  - Optional有一个toString()方法，可以显示有用的信息
  - 空流是通过Stream.`<String>`empty()创建的

  只用了 Stream.empty()而没有任何上下文信息，那么Java不知道它应该是什么类型的，而这种语法解决了该问题:  
  `Stream<String> s = Stream.empty():`  

  ```java
  static void test(Optional<String> optString) {
    if (optString. isPresent())
      System.out.println(optString.get());
    else
      System.out.println("Nothing inside!");
  }
  ```
  - 用isPresent(),看看里面是不是有东西。如果有，再使用get()来获取

## 便捷函数: Optional对象所调用
  简化了上面“先检查再处理所包含对象”的过程  
  - ifPresent(Consumer)：如果值存在，则用这个值来调用Consumer,否则什么都不做
  - orElse(otherObject)：如果对象存在，则返回这个对象，否则返回other0bject
  - orElseGet(Supplier)：如果对象存在，则返回这个对象，否则返回使用Supplier函数创建的替代对象
  - orElseThrow(Supplier):如果对象存在，则返回这个对象，否则抛出一个使用Supplier函数创建的异常
  ```java
  static void ifPresent(Optional<String> optString) {
    optString.ifPresent(System.out::println):
  }
  static void orElse(Optional<String> optString) {
    System.out.println(optString.orElse("Nada"));
  }
  static void orElseGet(Optional<String> optString) {
    System.out.println(
      optString.orElseGet(() -> "Generated"));
  }
  static void orElseThrow(Optional<String> optString) {
    try {
      System.out.println(optString.orElseThrow(
        () -> new Exception("Supplied")));
    }catch(Exception e) {
      System.out.println("Caught " + e);
    }
  }
  ```

## 创建Optional: Optional类所调用
  编写生成Optional的代码时，有如下三种可以使用的静态方法:  
  - empty()：返回一个空的 Optional
  - of(value)：如果已经知道这个value不是null,可以使用该方法将其包在一个Optional中
  - ofNullable(value)：如果不知道这个value是不是null,使用这个方法。  
    如果value为null,它会自动返回Optional. empty,否则会将这个value包在一个Optional中返回
  ```java
  class CreatingOptionals {
    static void test(String testName, Optional<String> opt) {
      System.out.printin( "=== "+ testName + " ===");
      System.out.println(opt.orElse("Null"));
    }
    public static void main(String[] args) {
      test("empty", Optional.empty();
      test("of", Optional.of("Howdy"));
      try {
        test("of", Optional.of(null));
      } catch(Exception e) {
        System.out.println(e);
      }
      test("ofNullable", Optional.ofNullable("Hi"));
      test("ofNullable", Optional.ofNullable(null));
    }
  }
  ```
  ```
  /*输出:
  === empty ===
  Null
  === of ===
  Howdy
  java.lang.NullPointerException
  === ofNullable ===
  Hi
  === ofNullable ===
  Null
  */
  ```
  如果试图通过向of()传递null来创建Optional,它会抛出空指针异常  

## Optional对象上的操作: filter(Predicate), map(Function), flatMap(Function)
  有三种方法支持对Optional逬行事后处理：  
  - filter(Predicate)：将Predicate应用于Optional的内容，并返回其结果。如果Optional与Predicate不匹配，则将其转换为empty。如果Optional本身已经是empty,则直接传回
  - map(Function)：如果 Optional 不为 empty,则将 Function 应用于 Optional 中包含的对象，并返回结果。否则传回Optional.empty
  - flatMap(Function)：和map()类似，但是所提供的映射函数会将结果包在Optional中，这样flatMap()最后就不会再做任何包装了

  对于普通的流filter()而言，如果Predicate返回false,它会将元素从流中删除。  
  但是对于Optional.filter()而言,如果Predicate返回false,它不会删除元素，但是会将其转化为empty。
  ```java
  static St ring[] elements = {
    “Foo", "", "Bar", "Baz", "Bingo"
  };
  static Stream<String> testStream() {
    return Arrays.stream(elements);
  }

  test(String descr, Predicate<String> pred) {
    System.out.printIn(" ---( " + descr + ")---");
    for(int i = 0; i <= elements.length; i++) {
      System.out.printIn(
        testStream()
          .skip(i)
          .findFirst()
          .filter(pred));
    }
  }

  public static void main(String[] args) {
    test("str != \"\"", str -> str != "");
  }
  ```
  ```java
  /*输出:
  ---( str != "" )---
  Optional[Foo]
  Optional.empty
  Optional[Bar]
  Optional[Baz]
  Optional(Bingo]
  Optional.empty
  */
  ```
  - 每次逬入for循环，它都会重新获得一个流，并跳过用for循环的索引设置的元素数
  - 然后它执行findFirst(),获得剩余元素的中的第一个，它会被包在一个Optional中返回
  - 和常见的for循环不同的是，这个索引没有用i < elements.length来限制，而是用了 i <= elements.length,所以最后一个元素事实上会超出这个流。方便的是,这会自动变成一个Optional.empty,在测试的最后能看到

  Optional.map()会应用一个函数，但是在Optional的情况下，只有当Optional不为empty时，它才会应用这个映射函数  
  它也会提取Optional所包含的对象，并将其交给映射函数：  
  ```java
  static String[] elements = { "12", "", "23", "45" );
  static Stream<String> testStream() {
    return Arrays.st ream(elements);
  }
  static void test(String descr, Function<String, String> func) {
    System.out.println(" ---( " + descr + " )---");
    for(int 1 = 0; i <= elements.length; i++) {
        System.out.println(
          testStream()
            .skip(i)
            .findFirst()       // 生成一个Optional
            .map(func));
    }
  }

  public static void main(String[] args) {
    //如果Optional不为empty,在将其传给时，map()首先会提取Optional中的对象：
    test("Take last digit", s -> s.length() > 0 ?
      s.charAt(s.length() - 1) + "" : s);
    //在函数完成后，map()会先把结果包在一个Optional中，然后返回
  }
  ```
  ```java
  /*输出:  
  ---( Take last digit )---
  Optional[2]
  Optional[]
  Optional[3]
  0ptional[5]
  Optional.empty
  */
  ```
  映射函数的结果会被自动地包在一个Optional中  

  Optional的flatMap()被应用于已经会生成Optional的映射函数，所以flatMap()不会像map()那样把结果包在Optional中:  
  ```java
  static String!] elements = { "12", "", "23", "45" };
  static Stream<String> testStream() {
    return Arrays.stream(elements);
  }
  static void test(String descr, Function<String, Optional<Strin>> func) {
    System.out.println(" ---( " + descr + " )---");
    for(int i = 0; 0; ii <= elements.length; i++) {
      System.out.println(
        testStream()
          .skip(i)
          .findFirst()
          .flatMap(func));
    }
  }
  public static void main(String[] args) {
    test("Take last digit",
      s -> Optional.of(s.length() > 0 ?
        s.charAt(s.length() - 1) + ""
        :s));
  }
  ```
  ```java
  /*输出:
  ---( Take last digit )---
  Optional[2]
  Optional
  Optional(3]
  Optional[5]
  Optional.empty
  */
  ```
  - flatMap()会获得非empty的Optional中的对象.并将其交给映射函数
  - flatMap()不会将结果包在Optional中，因为这个事映射函数已经做了  
  显然Optional.flatMap()是为已经能够自己生成Optional的函数设计的

## 由Optional组成的流: map(流元素 -> Optional.ofNullable(流元素))
  ```java
  static Random rand = new Random(47);
  public static Signal morse() {
    switch(rand.nextlnt(4)) {
      case 1: return new Signal("dot");
      case 2: return new Signal("dash");
      default: return null;
    }
  }
  public static Stream<Optional<Signal>> stream() {
    return Stream.generate(Signal::morse)
      .map(signal -> Optional.ofNullable(signal));        //Stream<Signal> 转为 Stream<Optional<Signal>>
  }
  ```

  如何获得Optional中的对象:  
  ```java
  Signal.stream()
    .limit(10)
    .filter(Optional::isPresent)
    .map(Optional::get)              // Optional::get 获得Optional中的对象
    .forEach(System.out::printin);
  ```

# 终结流操作(消费流元素): 由Stream<T>调用
  接受一个流，并生成一个最终结果。不会再把任何东西发给某个后端的流。  
  因此，终结操作总是我们在一个管线内可以做的最后一件事  

## 将流转换为一个数组:  toArray(), toArray(generator)
  - toArray()：将流元素转换到适当类型的数组中
  - toArray(generator): generator用于在特定情况下分配自己的数组存储

  想获得随机数，同时希望以流的形式复用它们，这样我们每次得到的都是相同的流。可以将其保存在一个数组中，来实现这个目的  
  ```java
  public class Randlnts {
    private static int[] rints = new Random(47).ints(0, 1000).limit(100).toArray();
    public static IntStream rands() {
      return Arrays.stream(rints);
    }
  }
  ```
  由100个0~1000范围内的int类型随机数组成的流，被转换成了一个数组.并存储在rints中  
  这样每次调用rands()就能重复获得相同的流了  

## 在每个流元素上应用某个终结操作: forEach(Consumer)，forEachOrdered(Consumer)
  - forEach(Consumer)：这种用法我们已经看到过很多次了——以 System.out::printin作为 Consumer 函数
  - forEachOrdered(Consumer):这个版本确保forEach对元素的操作顺序是原始的流的顺序

  第二种形式被明确地设计为可以以任何顺序操作元素，这只有在引入parallel()操作时才有意义  
  parallel()让Java尝试在多个处理器上执行操作 它可以做到这一点，正是因为使用了流一它可以将流分割为多个流(通常情况是，每个处理器一个流)，并在不同的处理器上运行每个流  

  ```java
  public class ForEach {
    static final int SZ = 14;
    public static void main(String[] args) {
      rands().limit(SZ)
        .forEach(n -> System.out.format("%d ", n));
      System.out.printin();
      rands().limit(SZ)
        .parallel()
        .forEach(n -> System.out.format("%d ", n));
      System.out.printin();
      randsO .limit(SZ)
        .parallel()
        .forEachOrdered(n -> System.out.format("%d ", n));
    }
  }
  ```
  ```java
  /*输出：
  258 555 693 861 961 429 868 200 522 207 288 128 551 589
  551 589 861 555 288 128 429 207 693 200 258 522 868 961
  258 555 693 861 961 429 868 200 522 207 288 128 551 589
   */
  ```
  - 在第一个流中，我们没有使用parallel().所以结果的显示顺序就是它们从rands()中出现的顺序
  - 第二个流引入了 parallel().即便是这么小的一个流，我们也可以看到输出的顺序和之前不一样了。这是因为有多个处理器在处理这个问题,而旦如果多次运行这个程序.你会发现每一次的输出还会有所不同,原因在于多个处理器同时处理这个问题所带来的不确定性因素
  - 最后一个流仍然使用了 parallel()，但是又使用forEachOrdered()来强制结果回到原始的顺序

## 收集操作: collect(Collector), collect(Supplier, BiConsumer, BiConsumer)
  - collect(Collector):使用这个Collector将流元素累加到一个结果集合中
  - collect(Supplier, BiConsumer, BiConsumer):和上面类似.但是Supplier会创建一个新的结果集合，第一个BiConsumer是用来将下一个元素包含到结果中的函数,第二个BiConsumer用于将两个值组合起来

  java.util.stream.Collectors: Collectors 中没有特定的toTreeSet()方法  
  但是可以使用Collectors.toCollection(),并将任何类型的Collection的构造器引用传给它  
  ```java
  public static void main(String[] args) throws Exception {
    Set<String> words2 =
      Files.lines (Paths.get("TreeSetOfWords.java"))
        .flatMap(s -> Arrays.stream(s.split("\\W+")))
        .filter(s -> !s.matches("\\d+"))       // 不要纯数字
        .map(String::trim)
        .filter(s -> s.length() > 2)
        .limit(100)
        .collect (Collectors. toCollection(TreeSet::new));
    System.out.println(words2)
  }
  ```
  - Files.lines()打幵Path所指向的文件，并将其变为由文本行组成的Stream
  - 下一行代码以一个或多个非单词字符(\\W+)为边界来分割这些文本行
  - matches(\\d+)会找到并删除全是数字的String (注意words2可以通过)

  从某个流生成一个Map：  
  ```java
  class Pair {
    public final Character c;
    public final Integer i;
    Pair(Character c, Integer i) {
      this.c = c;
      this.i = i；
    }
    public Character getC() ( return c; }
    public Integer getI() { return i； }
    ©Override
    public String toString() {
      return "Pair(" + c + "," + i + ")";
    }
  }

  class RandomPair {
    Random rand = new Random(47);
    // 一个无限大的迭代器,指向随机生成的大写字为：
    Iterator<Character> capChars = rand.ints(65,91)    // [1]
      .mapToObj(i -> (char)i)
      .iterator()；
    public Stream<Pair> stream() {
      return rand.ints(100, 1000).distinct()
        .mapToObj(i —>new Pair(capChars.next(), i));
    }
  }

  public class MapCollector {
    public static void main(String[] args) {
      Map<Integer, Character〉 map =
        new RandomPair().stream()
          .limit(8)
          .collect(
            Collectors.toMap(Pair::getl, Pair::getC));
      System.out.println(map);
    }
  }
  ```
  ```java
  /*输出：
  {688=W, 309=C, 293=B, 761=N, 858=N, 668=G, 622=F, 751=N}
  */
  ```
  - [1]capChars是一个会生成大写字母的Iterator<Character>。
  - capChars的定义从一个流开始,mapToObj()用于将这些int转为char,它们会通过自动装箱变为Character。
  - main()使用的是Collectors.toMap()的最简单形式，它只需要从流中取出键和值的函数  
    (还有其他形式，其中之一是接受一个可以处理键碰撞的函数)

  java.util.stream.Collectors不满足我们要求的预定义Collector(极少数),这时候可以使用collect()的第二种形式：  
  ```java
  public class Specialcollector {
    public static void main(String[] args) throws Exception {
      ArrayList<String> words =
        FileToWords.stream("Cheese.dat")
          .collect(ArrayList::new,                  //collect(Supplier, BiConsumer, BiConsumer)
                    ArrayList::add,
                    ArrayList::addAll);
      words.stream()
        .filter(s -> s.equals("cheese"))
        .forEach(System.out::printin);
    }
  }
  ```
  ```java
  /*
  cheese
  cheese
  */
  ```

# 累积计算流元素: reduce(BinaryOperator), reduce(identity, BinaryOperator)
  通过BinaryOperator累积计算全部的流元素，最后只返回一个元素类型的结果。  
  - reduce(BinaryOperator):使用BinaryOperator来组合所有的流元素。因为这个流可能为空，所以返回的是一个Optional。
  - reduce(identity, BinaryOperator)：和上面一样，但是将 identity 用作这个组合的初始值。因此，即使这个流是空的，我们仍然能得到identity作为结果
  reduce(BinaryOperator)中BinaryOperator中的第一个参数是上次调用这个reduce()时带回的结果，第二个参数是来自流中的新值  
  ```java
  static Frobnitz supply() {
    return new Frobnitz(rand.nextInt(BOUND));
  }

  public static void main(String[] args) {
    Stream.generate(Frobnitz::supply)
      .limit(10)
      .peek(System.out::println)
      .reduce((fr0，fr1) -> fr0.size < 50 ? fr0 : fr1)
      .ifPresent(System.out::println);
  }
  ```
  ```java
  /*输出：
  Frobnitz(58)
  Frobnitz(55)
  Frobnitz(93)
  Frobnitz(61)
  Frobnitz(61)
  Frobnitz(29)
  Frobnitz(68)
  Frobnitz(0)
  Frobnitz(22)
  Frobnitz(7)
  Frobnitz(29)
  */
  ```
  - Stream.generate()与Supplier<Frobnitz>是签名兼容的(这种签名兼容叫作结构一致性)
  - 在使用reduce()时，没有提供作为“初始值”的第一个参数，这意味着它会生成一个Optional
  - 只有当结果不是empty时，Optional.ifPresent()方法才会调用Consumer<Frobnitz> (之所以println能够符合，是因为它可以通过toString()将Fiobnitz转化为一个String)
  - lambda表达式中的第一个参数fr0是上次调用这个reduce()时带回的结果，第二个参数fr1是来自流中的新值

## 匹配: allMatch(Predicate), anyMatch(Predicate), noneMatch(Predicate)
  - allMatch(Predicate):当使用所提供的Predicate检测流中的元素时，如果每一个元素都得到true,则返回true。在遇到第一个false时，会短路计算 也就是说,在找到一个false之后，它不会继续计算
  - anyMatch(Predicate):当使用所提供的Piedicate检测流中的元素 ，如果有任何—个元素能得到true,则返回true。在遇到第一个true.会短路计算
  - noneMatch(Predicate):当使用所提供的Piedicate检测流中的元素时.如果没有元素得到true,则返回true。在遇到第一个true时，会短路计算
  ```java
  interface Matcher extends BiPredicate<Stream<Integer>, Predicate<Integer>> {}

  public class Matching {
    static void show(Matcher match, int val) {
      System.out.println(
        match.test(
          IntStream.rangeClosed(1, 9)
            .boxed()
            .peek(n -> System.out.format("%d ", n)),
          n -> n < val));
    }
    public static void main(String[] args) {
      show(Stream::allMatch, 10):
      show(Stream::allMatch, 4);
      show(Stream::anyMatch, 2):
      show(Stream::anyMatch, 0);
      show(Stream::noneMatch, 5);
      show(Stream::noneMatch, 0);
    }
  }
  ```
  ```java
  /*输出：
  1 2 3 4 5 6 7 8 9 true
  1 2 3 4 false
  1 true
  1 2 3 4 5 6 7 8 9 false
  1 false
  1 2 3 4 5 6 7 8 9 true
  */
  ```
  - 为Matcher能匹配所有Stream::*Match函数的模式  
    所以我们可以把每一个Match函数传给show()。对match.test()的调用会被翻译成对Stream::*Match函数的调用  
  - peek()表明在短路发生之前测试已经走了多远

## 选择一个元素
  - findFirst()：返回一个包含流中第一个元素的Optional,如果流中没有元素，则返回 Optional.empty
  - findAny()：返回一个包含流中某个元素的Optional,如果流中没有元素，则返回Optional.empty
  ```java
  System.out.println(rands().findFirst().getAsInt());
  System.out.println(
    rands().parallel().findFirst().getAsInt());
  System.out.println(rands().findAny().getAsInt());
  System.out.println(
    rands().parallel().findAny().getAsInt());
  ```
  ```java
  /*输出
  258
  258
  258
  242
  */
  ```
  - findFirst()总是会选择流中的第一个元素，不管该流是否为并行的(即通过Parallel()获得的流)  
  - 对于非并行的流，findAny()会选择第一个元素。当这个流是并行流时，FindAny()有可能选择第一个元素之外的其他元素  

  如果必须选择某个流的最后一个元素，使用reduce()：  
  ```java
  Optionallnt last = IntStream.range(10, 20)
    .reduce((nl, n2) -> n2);
  ```
  ```java
  /*输出
  19
  */
  ```
  - reduce()的参数: 即(n1, n2) -> n2, 是用两个元素中的后一个替换了这两个，这样最终得到的就是流中的最后一个元素了

## 获得流相关的信息
  - count()：获得流中元素的数量
  - max(Comparator):通过Comparator确定这个流中的"最大’元素
  - min(Comparator):通过Comparator确定这个流中的"最小’元素
  ```java
  System.out.println(
    FileToWords.streamC'Cheese.dat") .count());
  System.out.println(
    FileToWords.stream("Cheese.dat")
      .min(String.CASE_INSENSITIVE_ORDER)
      .orElse("NONE"));
  System.out.println(
    FileToWords.streamC'Cheese.dat")
      .max(String.CASE_INSENSITIVE_ORDER)
      .orElse("NONE"));
  ```
  ```java
  /*输出
  32
  a
  you
  */
  ```

  获得数值化流相关的信息：  
  - average()：就是通常的意义，获得平均值
  - max()与min()：这些操作不需要一个Comparator,因为它们处理的是数值化流
  - sum()：将流中的数值累加起来
  - summaryStatistics()：返回可能有用的摘要数据
  ```java
  System.out.println(rands().average().getAsDouble());
  System.out.println(rands().max().getAsInt());
  System.out.printin(rands().min().getAsInt());
  System.out.println(rands().sum());
  System.out.println(rands().summaryStatistics());
  ```
  ```java
  /*输出
  507.94
  998
  8
  50794
  IntSummaryStatistics{count=100, sum=50794, min=8, average=507.940000, max=998}
  */
  ```

# 小结
  流改变了Java编程的本质.而且带来了极大的提升
