集合优化了对象的存储,而流（stream）与对象的成批处理有关  

不同于在集合中遍历元素，使用流的时候，我们是从一个管道中抽取元素，并对它们逬行操作。这些管道通常会被串联到一起，形成这个流上的一个操作管线  

```java
public class Randoms {
  public static void main(String[] args) {
    new Random(47)
      .ints(5, 20)
      .distinct()
      .limit(7)
      .sortedf()
      .forEach(System.out::println);
  }
}
```
- ints()方法会生成一个流，该方法有多个重载版本，其中两个参数的版本可以设置所生成值的上下界
- 我们使用中间流操作distinct()去掉重复的值，再使用limit()选择前7个值
- sorted()使元素有序
- forEach(),它会根据我们传递的函数，在每个流对象上执行一个操作
- 方法引用System.out::println,用于将各每个条目显示在控制台上

声明式编程/命令式编程是一种编程风格，我们说明想要完成什么(what),而不是指明怎么做(how),这就是我们在函数式编程中看到的  
清晰的表达是应该使用Java 8的流的最有说服力的原因之一  

显式地编写迭代机制，称为外部迭代。而函数式编程看不到任何这样的机制，所以这被称为内部迭代，这是流编程的一个核心特性   
内部迭代产生的代码不仅可读性更好，而且更容易利用多处理器：通过放宽对具体迭代方式的控制，我们可以将其交给某种并行化机制  

流的另一个重要方面是惰性求值，这意味着它们只在绝对必要时才会被求值。   
我们可以把流想象成一个“延迟列表” 。因为延迟求值，所以流使我们可以表示非常大的（甚至是无限大的）序列，而不用考虑内存问题  

# Java 8对流的支持
  他们有一套现有的库，不仅用在了Java库本身之中，还用在了用户编写的无数代码之中。他们如何将流这个新的基本概念整合到现有的
库中呢？  

  最大的挑战来自使用了接口的库。因为我们想将集合转换为流，所以集合类是至关重要的一部分。  
  但如果向接口中加入新方法，就会破坏每一个实现了该接口，但是没有实现这个新方法的类  

  Java 8引入的解决方案是接口中的默认（default）方法，Java的设计者们可以将流方法硬塞进现有的类中，而且他们几乎把我们可
能需要的每个操作都添加进去了。  
  这些操作可分为三种类型：创建流、修改流元素（中间操作）和 终结流（消费流元素） 最后一种类型的操作往往意味着收集一个流的元素（通常是将其放进某个集合）

# 流的创建: Stream.of()和[Collection].stream()
  使用Stream.of(),可以轻松地将一组条目变成一个流  
  ```java
  Stream.of(3.14159, 2.718, 1.618)
    .forEach(System.out::println);
  ```
  ```java
  /*输出：
  3.14159
  2.718
  1.618
  */
  ```

  每个Collection都可以使用stream()方法来生成一个流:  
  ```java
  Set<String> w = new HashSet<>(Arrays.asList(
    "It's a wonderful day for pie!n.split(" ")));
  w.stream()
    .map(x -> x + " ")
    .forEach(System.out::print);
  System.out.println();

  Map<String, Doubl> m = new HashMap<>();
  m.put("pi", 3.14159);
  m.put("e", 2.718);
  m.put("phi", 1.618);
  m.entrySet().stream()
    .map(e -> e.getKey() + ": " + e.getValue())
    .forEach(System.out::println);
  ```
  ```java
  /*输出：
  a pie! It's for wonderful day
  phi: 1.618
  e: 2.718
  pi: 3.14159
  */
  ```
  中间的map()操作接受流中的毎个元素，在其上应用一个操作来创建一个新的元素，然后将这个新元素沿着流继续传递下去   
  普通的map()接受对象并生成对象，但是当希望输出流持有的是数值类型的值时,map()还有一些特殊的版本  
  mapToTnt()将一个对象流转变成了一个包含Integer的IntStream。对于Float和Double,也有名字类似的操作  

## 随机数流: Random(...).ints(...).boxed()
  Random类已经得到增强，有一组可以生成流的方法：  
  ```java
  public static <T> void show(Stream<T> stream) {
    stream
      .limit(4)
      .forEach(System.out::println);
    System .out .println ("++++++++");
  }

  public static void main(String[] args) {
    Random rand = new Random(47);
    show(rand.ints().boxed());
  }
  ```
  ```java
  /*输出：
  -1172628779
  1717241110
  -2614573909
  229493722
  */
  ```
  为消除冗余代码,上面的示例创建了泛型方法: show(Stream<T> stream)  
  Random类只会生成int、long和double等基本类型的值  
  boxed()流操作会自动将基本类型转换为其对应的包装器类型,这就使得show()能够接受这个流  

  ```java
  public static void main(String[] args) throws Exception {
    System.out.println(
      Stream.generate (new RandomWords ("Cheese, dat"))
        .limit(10)
        .collect(Collectors.joining("")));
  }
  ```
  - collect()操作，它会根据其参数将所有的流元素组合起来  
  - 当我们使用Collectors.joining()时，得到的结果是一个String,每个元素都会以joining()的参数分隔  
  - Stream.generate(),它可以接受任何的Supplier<T>,并生成一个由T类型的对象组成的流

## int类型的区间范围: range(...)
  IntStream类提供了一个range()方法，可以生成一个流————由int值组成的序列  
  ```java
  // for-in搭配一个区间范困：
  result = 0;
  for(int i : range(10, 20) .toArray())
    result += i;
  System.out.println(result);

  //使用流：
  System.out.println(range(10, 20).sum());
  ```
  ```java
  /*输出：
  145
  145
  */
  ```

  为了取代简单的for循环，可自定义repeat()工具函数：  
  ```java
  public class Repeat {
    public static void repeat(int n, Runnable action) {
      range(0, n).forEach(i -> action.run()):
    }
  }
  
  public class Looping {
    static void hi() ( System.out.println("Hi!"); }
    public static void main(String[] args) {
      repeat(3, () -> System.out.println("Looping!"));
      repeat(2, Looping::hi);
    }
  }
  ```
  ```java
  /*输出:
  Looping!
  Looping!
  Looping!
  Hi!
  Hi!
  */
  ```
  然而把repeat()放到自己的代码中，还要向别人解释，这么做可能并不值得。这取决于你的团队和公司的工作方式  

## generate()
  Supplier<T> 和 Stream.generate()搭配使用  
  
  如果想创建一个由完全相同的对象组成的流，只需要将一个生成这些对象的lambda表达式传给generate()  
  ```
  public class Duplicator {
    public static void main(String[] args) {
      Stream.generate(() -> "duplicate")
        .linit(3)
        .forEach(System.out::println);
    }
  }
  ```
  ```java
  /*
  duplicate
  duplicate
  duplicate
  */
  ```

  只要被引用方法和与Supplier<T>接口兼容：参数类型和返回类型一致，我们就可以将其方法引用传给Stream.generate()  

## iterate()
  Stream.iterate( <T>参数, 函数 )  ————从一个种子开始（第一个参数）.然后将其传给第二个参数所引用的方法  
  其结果被添加到iterate()的返回值：Stream<T>中，并且保存下来作为下一次iterate()调用的第一个参数,以此类推  
  ```java
  public class Fibonacci {
    int x = 1;
    Stream<Integer> numbers() {
      return Stream.iterate(0, i -> {
        int result = x + i;
        x = i;
        return result;
      });
    }

    public static void main(String[] args) {
      new Fibonacci().numbers()
        .skip(20)             //不使用前20个
        .limit(10)             //然后从中取10个
        .forEach(System.out::printin);
    }
  }
  ```
  ```java
  /*输出:
  6765
  10946
  17711
  28657
  46368
  75025
  121393
  196418
  317811
  514229
  */
  ```
  - skip()操作,它会直接丢弃由其参数指定的相应数目的流元素

## 流生成器
  Stream库提供了这样一个FileToWordsBuilder————设计模式：建造者模式（Builder Pattern）  
  ```java
  public class FileToWordsBuilder {
    Stream.Builder<String> builder = Stream. builder();
    public FileToWordsBuilder(String filePath)
    throws Exception {
      Files.lines(Paths.get(filePath))
        .skip(l) //建过开头的注释行
        .forEach(line -> {
          for(String w : line.split("[ .?,]+"))
            builder.add(w);
        });
    }
    Stream<String> stream() ( return builder.build(); )
    public static void main(String[) args) throws Exception {
      new FileToWordsBuilder("Cheese.dat").stream()
      .limit(7)
      .map(w -> w + " ")
      .forEach(System.out::print);
    }
  }
  ```
  - 构造器没有调用build()。这意味着，只要不调用stream(),就可以继续向builder对象中添加单词
  - 如果在调用build()之后还尝试向Stream.Builder中添加单词，则会产生异常

## Arrays
  Arrays类中包含了名为stream()的静态方法，可以将数组转换为流  
  ```java
  public class MetalWork2 {
    public static void main(String(] args) {
      Arrays.stream(new Operation[] {
        () -> Operation.show("Heat"),
        () -> Operation.show("Hammer"),
        () -> Operation.show("Twist"),
        () -> Operation .show("Anneal")
      }).forEach(Operation::execute);
    }
  }
  ```
  ```java
  /*输出：
  Heat
  Hammer
  Twist
  Anneal
  */
  ```

  ```java
  Arrays.stream(
    new int[] { 1, 3, 5, 7, 15, 28, 37 }, 3, 6)
      .forEach(n -> System.out.format("%d ", n));
  ```
  调用stream(),使用了两个额外的参数：第一个告诉stream()从数组的哪个位置幵始选择元素，  
  第二个告诉它在哪里停止,每个不同类型的stream()方法都有这个版本  

## 正则表达式
  Java 8 向 java.util.regex.Pattern类中加入了一个新方法splitAsStream()  
  这里有个约束：splitAsStream()的输入应该是一个CharSequence,所以我们不能将一个流传到splitAsStream()中  
  ```java
  import java.util.regex.Pattern;

  private String all;
  public Stream<String> stream() {
    return Pattern
      .compile("[ .,?]+").splitAsStream(all);
  }
  ```

# 中间操作






