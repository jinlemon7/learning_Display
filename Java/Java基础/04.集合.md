Java.util库提供集合类（容器类）  

# 泛型和类型安全的集合
  钻石语法：<ClassName>  

  new容器<>后()可传入容器类构造器支持的参数  
  不适用泛型，会造成由于默认支持Object，所有对象都可以加入容器，但编译器不会报错，但使用容器中对象时报错。  

  泛型 例：ArrayList<Apple> apples = new ArrayList<>();         //左侧已有Apple，此处不需要再写  
  类型推断  var apple = new ArrayList<Apple>();         //此处需添加，左侧没有<ClassName>，不加的话仅支持Object

# 基本概念
  - Collection:
    - List
    - Set
    - Queue
  - Map
  以上均为接口（抽象类型）

  类：（单继承：类 <- 类）  
  - 字段
  - 方法

  接口：（多继承：接口 <- 接口）  
  - 抽象方法：abstract
  - 静态方法：static
  - 默认方法：default

  抽象类：（多实现：接口 <- 类）  
  - 抽象方法
  - 普通方法
  - 构造方法
  - 字段

  容器向上转型为接口：（便于更换集合）  
  List<Apple> apples = new ArrayList<>();  
  List<Apple> apples = new LinkedList<>();  
  Collection<Apple> apples = new ArrayList<>();  

# 添加一组元素
  List<Integer> list = Arrays.asList(16, 17, 18);  //半可变(只能改，不能增删)列表转List（固定大小，底层为数组），List变原数组也变  
  Collection<Integer> collection = new ArrayList<>(Arrays.asList(1, 2, 3));  //将数组元素传递给构造器（由new()引发），不影响原数组  
  collection.addAll(list);  //只能加collection对象  
  collection.addAll(collection, 1, 2, 3);  
  list.add(21);  //报错，asList()底层是数组，不能调整大小  

# List：特定顺序维护元素  （继承自Collection，但多了新方法，实现多态）
  - ArrayList：擅长随机访问元素
  - LinkedList：插入和删除成本小

# 迭代器（Iterator）：统一对集合的访问  （设计模式：迭代器模式）
  1. 使用iterator()方法使Collection返回一个Iterator(无论使用的是什么具体Collection)
  2. 使用next()获得序列中的下一个对象
  3. 使用hasNext()方法检查序列的一个位序后是否还有对象
  4. remove()删除最近next()产生的元素（该方法不强制存在）

  PS: 初次next()返回的是序列中第1个(位序0)的对象引用  

# ListIterator
  1. 只有List类生成
  2. 可双向检查 hasNext(), hasPrevious()
  3. 前后索引 nextIndex(), previousIndex()
  4. 指定位置索引 listIterator(n)
  5. 替换元素 set()

# LinkedList (可作Queue, Stack)
  ```mermaid
  graph TD;
    头部 --> x1;
    x1 --> x2;
    x2 --> 尾部;
  ```
  1. 返回列表头部元素
     - getFirst() / elment()         //list为空时则报错
     - peek()                        //list为空返回null
  2. 移除并返回头部元素
     - removeFirst() / remove()      //list为空时则报错
     - poll()                        //list为空返回null
  3. 头部插入元素
     - addFirst()
  4. 尾部插入元素
     - offer() / add() / addLast()
  5. 移除并返回尾部元素
     - removeLast()
    
# Stack(栈)  先进后出LIFO(Last In First out)
  ```mermaid
  graph TD;
    栈顶 --> x1;
    x1 --> x2;
    x2 --> 栈底;
  ```
  基于Deque.ArrayDeque实现  

  1. 入栈：push()
  2. 返回栈顶元素：peek()
  3. 出栈：pop()
  4. 判断空：isEmpty()
  5. 打印函数：toString()

  例：Deque<T> dq = new ArrayDeque();  

# Set(集合)
  - HashSet：使用哈希
  - TreeSet：使用红黑树实现排序存储
  - LinkedHashSet：链表+ 哈希

  1. 添加元素
     - add(x)
     - addAll(x)
  2. 判断是否含有某元素
     - contains(x)
     - containsAll(list)
  3. 移除元素
     - remove(x)
     - removeAll(list)

  例：Set<T> se = new TreeSet<>();  

# Map(映射)
  1. 添加键值对：put(k, v)
  2. 获得值： get(k)
  3. 检查是否包含键/值：containsKey(k), containsValue(v)

  - entryset()：获得所有k:v键值对的set
  - keyset()：获得所有k的set
  - values()：获得所有v的set

  例：Map<T1, List< ? extends T2 > > m = new HashMap<>();
  List<T2>    //存T2
  List< ? extends T2 >  //存T2及其子类                ——不能添加元素（除null），编译器无法验证具体类型
  List< ? super T2 >  //存T2及其父类                  ——随意添加，读取类型为Object

# record类型
  
  
   
  
  















