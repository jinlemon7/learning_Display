Java.util库提供集合类（容器类）  

# 泛型和类型安全的集合
  钻石语法：<ClassName>  

  new容器<>后()可传入容器类构造器支持的参数  
  不适用泛型，会造成由于默认支持Object，所有对象都可以加入容器，但编译器不会报错，但使用容器中对象时报错。  

  泛型 例：ArrayList<Apple> apples = new ArrayList<>();         //左侧已有Apple，此处不需要再写  
  类型推断  var apple = new ArrayList<Apple>();         //此处需添加，左侧没有<ClassName>，不加的话仅支持Object

# 基本概念
  - Collection:
    - List
    - Set
    - Queue
  - Map
  以上均为接口（抽象类型）

  类：（单继承：类 <- 类）  
  - 字段
  - 方法

  接口：（多继承：接口 <- 接口）  
  - 抽象方法：abstract
  - 静态方法：static
  - 默认方法：default

  抽象类：（多实现：接口 <- 类）  
  - 抽象方法
  - 普通方法
  - 构造方法
  - 字段

  容器向上转型为接口：（便于更换集合）  
  List<Apple> apples = new ArrayList<>();  
  List<Apple> apples = new LinkedList<>();  
  Collection<Apple> apples = new ArrayList<>();  

# 添加一组元素
  List<Integer> list = Arrays.asList(16, 17, 18);  //半可变(只能改，不能增删)列表转List（固定大小，底层为数组），List变原数组也变  
  Collection<Integer> collection = new ArrayList<>(Arrays.asList(1, 2, 3));  //将数组元素传递给构造器（由new()引发），不影响原数组  
  collection.addAll(list);  //只能加collection对象  
  collection.addAll(collection, 1, 2, 3);  
  list.add(21);  //报错，asList()底层是数组，不能调整大小  

# List：特定顺序维护元素  （继承自Collection，但多了新方法，实现多态）
  - ArrayList：擅长随机访问元素
  - LinkedList：插入和删除成本小

# 迭代器（Iterator）：统一对集合的访问  （设计模式：迭代器模式）
  1. 使用iterator()方法使Collection返回一个Iterator(无论使用的是什么具体Collection)
  2. 使用next()获得序列中的下一个对象
  3. 使用hasNext()方法检查序列的一个位序后是否还有对象
  4. remove()删除最近next()产生的元素（该方法不强制存在）

  PS: 初次next()返回的是序列中第1个(位序0)的对象引用  

# ListIterator
  1. 只有List类生成
  2. 可双向检查 hasNext(), hasPrevious()
  3. 前后索引 nextIndex(), previousIndex()
  4. 指定位置索引 listIterator(n)
  5. 替换元素 set()

# LinkedList (可作Queue, Stack)
  ```mermaid
  graph TD;
    头部 --> x1;
    x1 --> x2;
    x2 --> 尾部;
  ```
  1. 返回列表头部元素
     - getFirst() / elment()         //list为空时则报错
     - peek()                        //list为空返回null
  2. 移除并返回头部元素
     - removeFirst() / remove()      //list为空时则报错
     - poll()                        //list为空返回null
  3. 头部插入元素
     - addFirst()
  4. 尾部插入元素
     - offer() / add() / addLast()
  5. 移除并返回尾部元素
     - removeLast()
    
# Stack(栈)  先进后出LIFO(Last In First out)
  ```mermaid
  graph TD;
    栈顶 --> x1;
    x1 --> x2;
    x2 --> 栈底;
  ```
  基于Deque.ArrayDeque实现  

  1. 入栈：push()
  2. 返回栈顶元素：peek()
  3. 出栈：pop()
  4. 判断空：isEmpty()
  5. 打印函数：toString()

  例：Deque<T> dq = new ArrayDeque();  

# Set(集合)
  - HashSet：使用哈希
  - TreeSet：使用红黑树实现排序存储
  - LinkedHashSet：链表+ 哈希

  1. 添加元素
     - add(x)
     - addAll(x)
  2. 判断是否含有某元素
     - contains(x)
     - containsAll(list)
  3. 移除元素
     - remove(x)
     - removeAll(list)

  例：Set<T> se = new TreeSet<>();  

# Map(映射)
  1. 添加键值对：put(k, v)
  2. 获得值： get(k)
  3. 检查是否包含键/值：containsKey(k), containsValue(v)

  - entryset()：获得所有k:v键值对的set
  - keyset()：获得所有k的set
  - values()：获得所有v的set

  例：Map<T1, List< ? extends T2 > > m = new HashMap<>();
  List<T2>    //存T2
  List< ? extends T2 >  //存T2及其子类                ——不能添加元素（除null），编译器无法验证具体类型
  List< ? super T2 >  //存T2及其父类                  ——随意添加，读取类型为Object

# record类型
  1. 类和字段隐含final，record不可继承
  2. record在类和方法中创建引用时，隐含static，是一个类级别的常量引用

  record关键字：定义作数据载体的类  
  使用record时，编译器自动生成  
  1. 不可变字段（隐含final修饰）
  2. 一个规范的构造器（全字段参数列表-构造器）
  3. 每个元素都有的访问器方法
  4. equals(), hashCode(), toString()

  例：
  ```java
  record Employee(String name, int id){}     //字段列表即定义record
  var bob = new Employee("Bob", 11);         //全字段参数构造器
  System.out.println(bob.name());            //访问器
  System.out.println(bob);                   //toString()调用
  ```

  1. record字段是隐含final修饰，所以不允许初始化后修改  
     定义的方法也不允许修改字段，只能读取
  2. record可以由其他对象/record组成  
     record隐含final，不能被其他类继承，也不能继承其他类
  3. record可镶嵌在类和局部方法中，隐含static修饰
  4. 除了自动构建构造器，程序员可使用紧凑构造器（compact constructor）初始化字段  
     例：  
     ```java
     record PlusTen (int x ){
       PlusTen{ x += 10 }               //紧凑构造器（没有参数列表）  紧凑构造器会执行Java默认初始化
     }
     ```
  5. 普通构造器替代紧凑构造器  
     例：  
     ```java
     record Value(int x){
       Value(int x ){                 //带参数列表
         this.x = x;                  //必须显式初始化this.x, 否则报错  因为使用非构造器，字段不会执行Java默认初始化
       }
     }
     ```

# Queue  先进先出FIFO
  ```mermaid
  队首 --> x1;
  x1 --> x2;
  x2 --> 队尾;
  ```

  LinkedList实现了Queue接口，可作为Queue的一种实现类使用。  
  例：  
  Queue <Integer> qu = new LinkedList<>();  //向上转型为Queue  

  PriorityQueue(优先队列：下一个拿出的元素是需求最强烈的元素，通过提供自己的Comparator)  
  例：  
  1. PriorityQueue<Integer> pq = new PriorityQueue<>();
  2. PriorityQueue<Integer> pq = new PriorityQueue<>(list.size(), Collections.reverseOrder() );  //Collections.reverseOrder():倒序比较器
     pq.addAll(list);

# Collection和Iterator对比
  Collection：序列集合共同的根接口。实现面向接口（Collection/Map）编程而非面向实现（ArrayList/HashMap）  
  例：  
  ```java

  
  
   
  
  















