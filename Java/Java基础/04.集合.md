Java.util库提供集合类（容器类）  

# 泛型和类型安全的集合
  钻石语法：`<ClassName>` 

  new容器<>后()可传入容器类构造器支持的参数  
  不适用泛型，会造成由于默认支持Object，所有对象都可以加入容器，但编译器不会报错，但使用容器中对象时报错。  

  泛型 例：`ArrayList<Apple> apples = new ArrayList<>();`         //左侧已有Apple，右侧不需要再写  
  类型推断  `var apple = new ArrayList<Apple>();`         //右侧需添加，左侧没有<ClassName>，不加的话仅支持Object

# 基本概念
  - Collection:
    - List
    - Set
    - Queue
  - Map  
  以上均为接口（抽象）  

  类：（单继承：类 <- 类）  
  - 字段
  - 方法

  接口：（多继承：接口 <- 接口）  
  - 抽象方法：abstract
  - 静态方法：static
  - 默认方法：default

  抽象类：（多实现：接口 <- 类）  
  - 抽象方法
  - 普通方法
  - 构造方法
  - 字段

  容器向上转型为接口：（便于更换集合）  
  `List<Apple> apples = new ArrayList<>(); `   
  `List<Apple> apples = new LinkedList<>();`    
  `Collection<Apple> apples = new ArrayList<>();`  

# 添加一组元素
  `List<Integer> list = Arrays.asList(16, 17, 18);`  //半可变(只能改，不能增删)列表转List（固定大小，底层为数组），List变原数组也变  
  `Collection<Integer> collection = new ArrayList<>(Arrays.asList(1, 2, 3));`  //将数组元素传递给构造器（由new()引发），不影响原数组  
  `collection.addAll(list);` //只能加collection对象  
  `collection.addAll(collection, 1, 2, 3);`  
  `list.add(21);`  //报错，asList()底层是数组，不能调整大小  

# List：特定顺序维护元素  （继承自Collection，但多了新方法，实现多态）
  - ArrayList：擅长随机访问元素
  - LinkedList：插入和删除成本小

# 迭代器（Iterator）：统一对集合的访问  （设计模式：迭代器模式）
  1. 使用iterator()方法使Collection返回一个Iterator(无论使用的是什么具体Collection)
  2. 使用next()获得序列中的下一个对象
  3. 使用hasNext()方法检查序列的一个位序后是否还有对象
  4. remove()删除最近next()产生的元素（该方法不强制存在）

  PS: 初次next()返回的是序列中第1个(位序0)的对象引用  

# ListIterator
  1. 只有List类生成
  2. 可双向检查 hasNext(), hasPrevious()
  3. 前后索引 nextIndex(), previousIndex()
  4. 指定位置索引 listIterator(n)
  5. 替换元素 set()

# LinkedList (可作Queue, Stack)
  ```mermaid
  graph TD;
    头部 --> x1;
    x1 --> x2;
    x2 --> 尾部;
  ```
  1. 返回列表头部元素
     - getFirst() / elment()         //list为空时则报错
     - peek()                        //list为空返回null
  2. 移除并返回头部元素
     - removeFirst() / remove()      //list为空时则报错
     - poll()                        //list为空返回null
  3. 头部插入元素
     - addFirst()
  4. 尾部插入元素
     - offer() / add() / addLast()
  5. 移除并返回尾部元素
     - removeLast()
    
# Stack(栈)  先进后出LIFO(Last In First out)
  ```mermaid
  graph TD;
    栈顶 --> x1;
    x1 --> x2;
    x2 --> 栈底;
  ```
  基于Deque.ArrayDeque实现  

  1. 入栈：push()
  2. 返回栈顶元素：peek()
  3. 出栈：pop()
  4. 判断空：isEmpty()
  5. 打印函数：toString()

  例：`Deque<T> dq = new ArrayDeque();`  

# Set(集合)
  - HashSet：使用哈希
  - TreeSet：使用红黑树实现排序存储
  - LinkedHashSet：链表+ 哈希

  1. 添加元素
     - add(x)
     - addAll(x)
  2. 判断是否含有某元素
     - contains(x)
     - containsAll(list)
  3. 移除元素
     - remove(x)
     - removeAll(list)

  例：Set<T> se = new TreeSet<>();  

# Map(映射)
  1. 添加键值对：put(k, v)
  2. 获得值： get(k)
  3. 检查是否包含键/值：containsKey(k), containsValue(v)

  - entryset()：获得所有k:v键值对的set
  - keyset()：获得所有k的set
  - values()：获得所有v的set

  例：`Map<T1, List< ? extends T2 > > m = new HashMap<>();`  
  `List<T2>`    //存T2  
  `List< ? extends T2 >`  //存T2及其子类                ——不能添加元素（除null），编译器无法验证具体类型  
  `List< ? super T2 >`  //存T2及其父类                  ——随意添加，读取类型为Object  

# record类型
  1. 类和字段隐含final，record不可继承
  2. record在类和方法中创建符号引用时，隐含static修饰，是一个类级别的常量引用

  record关键字：定义作数据载体的类  
  使用record时，编译器自动生成  
  1. 不可变字段（隐含final修饰）
  2. 一个规范的构造器（全字段参数列表-构造器）
  3. 每个元素都有的访问器方法
  4. equals(), hashCode(), toString()

  例：
  ```java
  record Employee(String name, int id){}     //参数列表即定义record
  var bob = new Employee("Bob", 11);         //全字段参数构造器
  System.out.println(bob.name());            //访问器
  System.out.println(bob);                   //toString()调用
  ```

  1. record字段是隐含final修饰，所以不允许初始化后修改  
     定义的方法也不允许修改字段，只能读取
  2. record可以由其他对象/record组成  
     record隐含final，不能被其他类继承，也不能继承其他类
  3. record可镶嵌在类和局部方法中，隐含static修饰
  4. 除了自动构建构造器，程序员可使用紧凑构造器（compact constructor）初始化字段  
     例：  
     ```java
     record PlusTen (int x ){
       PlusTen{ x += 10 }               //紧凑构造器（没有参数列表）  紧凑构造器会执行Java默认初始化
     }
     ```
  5. 普通构造器替代紧凑构造器  
     例：  
     ```java
     record Value(int x){
       Value(int x ){                 //带参数列表
         this.x = x;                  //必须显式初始化this.x, 否则报错  因为使用非构造器，字段不会执行Java默认初始化
       }
     }
     ```

# Queue  先进先出FIFO
  ```mermaid
  graph TD;
  队首 --> x1;
  x1 --> x2;
  x2 --> 队尾;
  ```

  LinkedList实现了Queue接口，可作为Queue的一种实现类使用。  
  例：  
  `Queue <Integer> qu = new LinkedList<>();`  //向上转型为Queue  

  PriorityQueue(优先队列：下一个拿出的元素是需求最强烈的元素，通过提供自己的Comparator)  
  例：  
  1. `PriorityQueue<Integer> pq = new PriorityQueue<>();`
  2. `PriorityQueue<Integer> pq = new PriorityQueue<>(list.size(), Collections.reverseOrder() );`  //Collections.reverseOrder():倒序比较器  
     pq.addAll(list);

# Collection和Iterator对比
  Collection：序列集合共同的根接口。实现面向接口（Collection/Map）编程而非面向实现（ArrayList/HashMap）  
  例：  
  ```java
  public static  void display(Collection<T> c){
    for(T t: c){
      ...
    }
  }
  ```
  编写一个以Collection为参数的方法，可以应用于任何实现了Collection的类  

  Iterator
  1. 一个Collection外部类实现Collection接口，通过继承AbstractCollection实现较为简单，但需强制实现size(),  
     iterator():  
     - hasNext()
     - next()
     - remove()  
     总结：具体序列类（ 实现size(), iterator() ） 继承AbstractCollection
  2. 或先创建一个类，再创建迭代器类（独立）：  
     此时Iterator就有优势了：
     - 将序列和处理序列的方法连接起来的耦合性最低的方式
     - 对序列类的约束少的多  
     总结：具体序列类 + 迭代器类（ 继承序列类，仅实现iterator() ）

# for-in语法和迭代器
  for-in语法：例：`for(String s: CS)`, 用于遍历  
  适用于：  
  - 数组（需显示转换为Iterable） 例：Arrays.asList(1, 2, 3); 或 int[] a = {1, 2, 3}
  - 实现了Iterable接口的类：Collection类（不包括Map）
      
  for-in语法底层原理就是迭代器（前向），想要反向遍历，则可写一个适配器类（继承已有容器），写一个返回Iterable接口的reversed()方法  
  例：用匿名类重写一个反向iterator  

# 适配器  （设计模式: Adapter适配器模式）
  已有一个类满足for-in语句要求的接口，还需另一个，则可编写一个适配器类：  
  新类（继承类） ——> 新方法（返回Iterator对象）  

  例：  
  ```java
  class ReverseArrayList<T> extends ArrayList<T> {
    ReverseArrayList(Collection<T> c){          //构造器
      super(c);
    }

    public Iterable<T> reversed(){           //返回Iterable对象（即接口）
      return new Iterable<T>() {             //匿名类
        public Iterator<T> iterator(){       //返回Iterator迭代器对象
          return new Iterator<T> (){         //匿名类
            int current = size() - 1;
            @Override
            public boolean hasNext(){
              return current > -1;
            }
            @Override
            public T next(){
              return get(current--);
            }
            @Override
            public void remove(){
              ...
            }
          };
        }
      };
    }

    ...
  }
  ```

# 集合图
  <img width="1184" height="734" alt="image" src="https://github.com/user-attachments/assets/77626c1e-5c89-437c-9959-37ffdca64874" />

  - Produces: 表明一个类可以生成箭头所指的类的对象
  - 虚线框：接口
  - 实现框：具体类
  - Utilities：java.util包

  Collection均实现了Iterable接口，可使用迭代器的for-in语法遍历  
  Map不行（无迭代器），遍历Map需使用方法：  
  - entrySet()
  - keySet()
  - values()
