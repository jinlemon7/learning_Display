enum关键字用于创建一个新类型，其中包含一组数量有限的命名变量，并视这些变量为常规程序组件  

# 枚举类型的基本特性
  values()方法生成一个由枚举常量组成的数组，其中常量的顺序和常量声明的顺序保持一致，这样你就可以方便地（比如通过for-in循环）使用结果数组了。  
  
  当创建枚举类型时，编译器会为你生成一个辅助类，这个类自动继承自java.lang.Enum  
  ```java
  public class EnumClass {
    public static void main(String[] args) {
      for(Shrubbery s : Shrubbery.values()) {
        System.out.println(
          s + " ordinal: " + s.ordinal());
        System.out.print(
          s.compareTo(Shrubbery.CRAWLING) + " ");
        System.out.print(
          s.equals(Shrubbery.CRAWLING) + " ");
        System.out.println(s == Shrubbery.CRAWLING);
        System.out.printin(s.getDeclaringClass());
        System.out.println(s.name());
        System.out.println("********************");
      }
      //
      for(String s :
          "HANGING CRAWLING GROUND".split(" ")) {
        Shrubbery shrub =
          Enum.valueOf(Shrubbery.class, s);
        System.out.printin(shrub);
      }
    }
  }
  ```
  ```java
  /* 输出：
  GROUND ordinal: 0
  -1 false false
  class Shrubbery
  GROUND
  ********************
  CRAWLING ordinal: 1
  0 true true
  class Shrubbery
  CRAWLING
  ********************
  HANGING ordinal: 2
  1 false false
  class Shrubbery
  HANGING
  ********************
  HANGING
  CRAWLING
  GROUND
  */
  ```
  - 可以放心地使用==来比较枚举实例（equals()和hashCode()方法会由编译器自动为你生成）。Enum类实现了Comparable接口（因此可比较），所以自动包含了compare()方法，另外它还实现了Serializable接口（因此可序列化）
  - getDeclaringClass()方法，则会得到该枚举实例所属的外部包装类
  - valueOf()方法是Enum类中的静态方法，它根据传入的String，返回名称与该String匹配的枚举实例

## 静态导入枚举实例
  ```java
  public enum SpicinessEnum {
    NOT, MILD, MEDIUM, HOT, FLAMING
  }

  import static enums.SpicinessEnum.*;
  public class Burrito2 {
    SpicinessEnum degree;
    public Burrito2(SpicinessEnum degree) {
      this.degree = degree;
    }
    @Override public String toString() {
      return "Burrito is "+ degree;
    }
    public static void main(String[] args) {
      System.out.printin(new Burrito2(NOT));
      System.out.printin(new Burrito2(MEDIUM));
      System.out.printin(new Burrito2(HOT));
    }
  }
  ```
  ```java
  /* 输出：
  Burrito is NOT
  Burrito is MEDIUM
  Burrito is HOT
  */
  ```
  - static import将所有的枚举实例标识符都引入了本地命名空间

# 在枚举类型中增加自定义方法
  可以在枚举中增加自定义的方法，甚至可以增加一个main()方法  
  ```java
  public enum OzWitch {
    // 实例必须在方法之前定义
    WEST("Miss Gulch, aka the Wicked Witch of the West"),
    NORTH("Glinda, the Good Witch of the North"),
    EAST("Wicked Witch of the East, wearer of the Ruby " +
      "Slippers, crushed by Dorothy's house"),
    SOUTH("Good by inference, but missing");

    private String description;
    // 构造器的访问权限必须是包级或private
    private OzWitch(String description) {
      this.description = description;
    }
    public String getDescription() { return description; }
    public static void main(String[] args) {
      for(OzWitch witch : OzWitch.values())
        System.out.println(
          witch + ": " + witch.getDescription());
    }
  }
  ```
  ```java
  /* 输出：
  WEST: Miss Gulch, aka the Wicked Witch of the West
  NORTH: Glinda, the Good Witch of the North
  EAST: Wicked Witch of the East, wearer of the Ruby
  Slippers, crushed by Dorothy's house
  SOUTH: Good by inference, but missing
  */
  ```
  - 如果你想增加自定义方法，则必须先用分号结束枚举实例的序列

## 重载枚举类型中的方法
  与重载任何普通类的方法相同：  
  ```java
  public enum Spaceship {
    SCOUT, CARGO, TRANSPORT,
    CRUISER, BATTLESHIP, MOTHERSHIP;

    @Override public String toString() {
      String id = name();
      String lower = id.substring(1).toLowerCase();
      return id.charAt(0) + lower;
    }
    public static void main(String[] args) {
      Stream.of(values())
        .forEach(System.out::println);
    }
  }
  ```
  ```java
  /* 输出：
  Scout
  Cargo
  Transport
  Cruiser
  Battleship
  Mothership
  */
  ```

# 在switch语句中使用枚举
  通常，switch语句只能使用整型或字符串的值，但是由于enum内部已经构建了一个整型序列，并且可以通过ordinal()方法来得到枚举实例的顺序(显然编译器做了相应的工作),所以枚举类型可以用在switch语句中  
  
  虽然通常要使用枚举实例，就必须用枚举的类型名来限定它，但在case语句中你无需这么做  
  ```java
  enum Signal { GREEN, YELLOW, RED, }

  public class TrafficLight {
    Signal color = Signal.RED;
    public void change() {
      switch(color) {
      // 注意在case语句中，无需使用Signal.RED
      case RED: color = Signal.GREEN ;
                break;
      case GREEN: color = Signal.YELLOW;
                break;
      case YELLOW: color = Signal.RED;
                break;
      }
    }
    @Override public String toString() {
      return "The traffic light is " + color;
    }
    public static void main(String[] args) {
      TrafficLight t = new TrafficLight();
      for(int i = 0; i < 7; i++) {
        System.out.printin(t);
        t.change();
      }
    }
  }
  ```
  ```
  /* 输出
  The traffic light is RED
  The traffic light is GREEN
  The traffic light is YELLOW
  The traffic light is RED
  The traffic light is GREEN
  The traffic light is YELLOW
  The traffic light is RED
  */
  ```
  - 如果此时你在case语句中调用了return（而且没有编写default），则编译器会报错，即使你已经覆盖到了枚举中的所有值

# values()方法的神秘之处
  所有的枚举类型都是由编译器通过继承Enum类来创建的的。然而如果仔细查看Enum类的代码，你会发现里面根本没有values()方法，我们却已经能直接使用它了  
  ```java
  enum Explore { HERE, THERE }

  public class Reflection {
    public static
    Set<String> analyze(Class<?> enumClass) {
      System.out.printin(
        "_____ Analyzing " + enumClass + "_____");
      System.out.printin("Interfaces:");
      for(Type t : enumClass.getGenericlnterfaces())
        System.out.println(t);
      System.out.println(
        "Base: " + enumClass.getSuperclass());
      System.out.printin("Methods: ");
      Set<String> methods = new TreeSet<>();
      for(Method m : enumCtass.getMethods())
        methods.add(m.getName());
      System.out.printin(methods);
      return methods;
    }

    public static void main(String[] args) {
      Set<String> exploreMethods =
        analyze(Explore.class);
      Set<String> enumMethods = analyze(Enum.class);
      System.out.println(
        "Explore. containsAll (Enum)? " +
        exploreMethods.containsAll(enumMethods));
      System.out.print("Explore.removeAll(Enum): ");
      exploreMethods.removeAll(enumMethods);
      System.out.printin(exploreMethods);
      // 反编译enum
      OSExecute.command(
        "javap -cp build/classes/java/main Explore");
    }
  }
  ```
  ```java
  /* 输出：
  _____Analyzing class Explore_____
  Interfaces:
  Base: class java.lang.Enum
  Methods:
  [compareTo, equals, getClass, getDeclaringClass,
  hashCode, name, notify, notifyAll, ordinal, toString,
  valueOf, values, wait]
  _____Analyzing class java.lang.Enum_____
  Interfaces:
  java.lang.Comparable<E>
  interface java.io.Serializable
  Base: class java.lang.Object
  Methods:
  [compareTo, equals, getClass, getDeclaringClass,
  hashCode, name, notify, notifyAll, ordinal, toString,
  valueOf, wait]
  Explore.containsAll(Enum)? true
  Explore.removeAll(Enum): [values]
  Compiled from "Reflection.java"
  final class Explore extends java.lang.Enum<Explore> {
    public static final Explore HERE;
    public static final Explore THERE;
    public static Explore[] values();
    public static Explore valueOf(java.lang.String);
    static {};
  }
  */
  ```
  - values()方法是由编译器添加的一个静态方法
  - 打印结果显示Explore枚举被编译器限定为final类，所以你无法继承一个枚举类。此外还有一个static的初始化子句
  - values()方法是由编译器在枚举类的定义中插入的一个静态方法，因此如果你将枚举向上转型为Enum，则values()方法将不可用

  Class中有个getEnumConstants()方法，即使Enum的getMethods()中没有values()方法，仍然可以通过Class对象来得到enum的实例:  
  ```java
  enum Search { HITHER, YON }

  public class UpcastEnum {
    public static void main(String[] args) {
      Search[] vals = Search.values();
      Enum e = Search.HITHER;         // 向上转型
      // e.values();                  // Enum中没有values()方法
      for(Enum en : e.getClass().getEnumConstants() )
        System.out.println(en);
    }
  }
  ```
  ```java
  /* 输出：
  HITHER
  YON
  */
  ```
  
# 实现，而不是继承
  我们已经确认所有的enum对象都继承自java.lang.Enum, Java不支持多重继承,这意味着你无法通过以下这样的继承方式创建一个枚举对象：  
  `enum NotPossible extends Pet{...`    //无法执行  

   不过， 可以创建实现了一个或多个接口的枚举类型：  
   ```java
   enum CartoonCharacter
   implements Supplier<CartoonCharacter> { 
      SLAPPY, SPANKY, PUNCHY,
      SILLY, BOUNCY, NUTTY, BOB;
      private Random rand =
        new Random(47);
      @Override public CartoonCharacter get() {
        return values()[rand.nextInt(values().length)];
      }
   }
  ```

# 随机选择
  需要从enum中随机选择实例，可以使用泛型将这项任务的实现抽象成公共能力：  
  ```java
  public class Enums {
    private static Random rand = new Random(47);
    public static
    <T extends Enum<T>> T random(Class<T> ec) {
      return random(ec.getEnumConstants());
    }
    public static <T> T random(T[] values) {
      return values[rand.nextInt(values.length)];
    }
  }
  ```
  - 这个看起来相当奇怪的语法<T extends Enum<T>>, 声明了T是一个枚举的实例

  下面对random()方法做个简单的测试：  
  ```java
  enum Activity { SITTING, LYING, STANDING, HOPPING,
    RUNNING, DODGING, JUMPING, FALLING, FLYING }

  public class RandomTest {
    public static void main(String[] args) {
      for(int i = 0; i < 20; i++)
        System.out.print(
          Enums.random(Activity.class) + " ");
    }
  }
  ```
  ```java
  /* 输出：
  STANDING FLYING RUNNING STANDING RUNNING STANDING LYING
  DODGING SITTING RUNNING HOPPING HOPPING HOPPING RUNNING
  STANDING LYING FALLING RUNNING FLYING LYING
  */
  ```

# 使用接口来组织枚举
  你可以在一个接口内对元素进行分组，然后基于这个接口生成一个枚举，通过这样的方式来实现元素的分类：  
  ```java
  public interface Food {
    enum Appetizer implements Food {
      SALAD, SOUP, SPRING_ROLLS;
    }
    enum MainCourse implements Food {
      LASAGNE, BURRITO, PAD_THAI,
      LENTILS, HUMMUS, VINDALOO;
    }
    enum Dessert implements Food {
      TIRAMISU, GELATO, BLACK_FOREST_CAKE,
      FRUIT, CREME_CARAMEL;
    }
    enum Coffee implements Food {
      BLACK_COFFEE, DECAFCOFFEE, ESPRESSO,
      LATTE, CAPPUCCINO, TEA, HERBTEA;
    }
  }
  ```

  实现接口是唯一可子类化枚举的方式  
  ```java
  public enum Course {
    APPETIZER(Food.Appetizer.class),
    MAINCOURSE(Food.MainCou rse.class),
    DESSERT(Food.Dessert.class),
    COFFEE(Food.Coffee.class);

    private Food[] values;
    private Course(Class<? extends Food> kind) {
      values = kind.getEnumConstants();
    }
    public Food randomSelection() {
      return Enums.random(values);
    }
  }
  ```
  - 每个枚举类型都接受相应的Class对象以作为构造参数

  另一种更简洁的分类方法是在枚举内嵌套枚举：  
  ```java
  enum Securitycategory {
    STOCK(Security.Stock.class),
    BOND(Security.Bond.class);

    Security[] values;
    SecurityCategory(Class<? extends Security> kind) {
      values = kind.getEnumConstants();
    }
    interface Security {
      enum Stock implements Security {
        SHORT, LONG, MARGIN
      }
      enum Bond implements Security {
        MUNICIPAL, JUNK
      }
    }
    public Security randomselection() {
      return Enums.random(values);
    }
    public static void main(String[] args) {
      for(int i = 0; i < 10; i++) {
        Securitycategory category =
          Enums.random(SecurityCategory.class);
        System.out.printin(category + ": " +
          category.randomSelection());
      }
    }
  }
  ```
  ```java
  /* 输出：
  BOND: MUNICIPAL
  BOND: MUNICIPAL
  STOCK: MARGIN
  STOCK: MARGIN
  BOND: JUNK
  STOCK: SHORT
  STOCK: LONG
  STOCK: LONG
  BOND: MUNICIPAL
  BOND: JUNK
  */
  ```
  - Security接口用于将内部的枚举类型作为公共类型聚合到一起，然后再将它们归类到SecurityCategory中的枚举中

# 用EnumSet来代替标识
  性能是EnumSet的设计目标之一，因为它需要和位标识竞争（位操作的性能通常远高于HashSet）。其内部实现其实是一个被用作位数组的long型变量  
  拥有了一种更具表现力的方式来表达二进制特征的存在与否，而且无需担心性能  

  EnumSet中的元素必须来自某个枚举类型：
  ```java
  public enum AlarmPoints {
    STAIR1, STAIR2, LOBBY, OFFICE1, OFFICE2, OFFICE3,
    OFFICE4, BATHROOM, UTILITY, KITCHEN
  }

  import static enums.AlarmPoints.*;
  public class EnumSets {
    public static void main(String[] args) {
      EnumSet<AlarmPoints> points =
        EnumSet.noneOf(AlarmPoints.class) ;       // 为空
      points.add(BATHROOM);
      System.out.println(points);
      points.addAll(
        EnumSet.of(STAIR1, STAIR2, KITCHEN));
      System.out.println(points);
      points = EnumSet.allOf(AlarmPoints.class);
      points.removeAll(
        EnumSet.of(STAIR1, STAIR2, KITCHEN));
      System.out.println(points);
      points.removeAll(
        EnumSet.range(OFFICE1, OFFICE4));
      Systern.out.println(points);
      points = EnumSet.complementOf(points);
      System.out.println(points);
    }
  }
  ```
  ```java
  /* 输出：
  [BATHROOM]
  [STAIR1, STAIR2, BATHROOM, KITCHEN]
  [LOBBY, OFFICE1, OFFICE2, OFFICE3, OFFICE4, BATHROOM,
  UTILITY]
  [LOBBY, BATHROOM, UTILITY]
  [STAIR1, STAIR2, OFFICE1, OFFICE2, OFFICE3, OFFICE4,
  KITCHEN]
  */
  ```
  - 静态导入（static import）的作用是简化枚举常量的使用

  Enum是基于64位的long构建的，每个枚举实例需要占用1位来表达是否存在的状态，这意味者在单个long的支撑范围内，1个EnumSet最多可支持包含64个元素的枚举类型  
  如果枚举类型中的元素超过了64个，会发生什么呢？  
  ```java
  public class BigEnumSet {
    enum Big { AO, A1, A2, A3, A4, A5, A6, A7, A8, A9,
      A1O, All, A12, A13, A14, A15, A16, A17, A18, A19,
      A20, A21, A22, A23, A24, A25, A26, A27, A28, A29,
      A30, A31, A32, A33, A34, A35, A36, A37, A38, A39,
      A40, A41, A42, A43, A44, A45, A46, A47, A48, A49,
      A50, A51, A52, A53, A54, A55, A56, A57, A58, A59,
      A60, A61, A62, A63, A64, A65, A66, A67, A68, A69,
      A70, A71, A72, A73, A74, A75 }
    public static void main(String[] args) {
      EnumSet<Big> bigEnumSet = EnumSet.allOf(Big.class);
      System.out.println(bigEnumSet);
    }
  }
  ```
  ```java
  /* 输出:
  [A0, Al, A2, A3, A4, A5, A6, A7, A8, A9,. AIO,, All,, A12,
  A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23,
  A24, A25, A26, A27, A28, A29, A30, A31, A32, A33, A34,
  A35, A36, A37, A38, A39, A40, A41, A42, A43, A44, A45,
  A46, A47, A48, A49, A50, A51, A52, A53, A54, A55, A56,
  A57, A58, A59, A60, A61, A62, A63, A64, A65, A66, A67,
  A68, A69, A70, A71, A72, A73, A74, A75]
  */
  ```
  - 显然EnumSet可以支持包含超过64个元素的枚举类型，所以可以推测，它在必要的时候会引入新的long型变量

# 使用EnumMap
  EnumMap是一种特殊的Map，它要求自身所有的键来自某个枚举类型，EnumMap的内部可以作为一个数组来实现，因此它们的性能非常好，你可以放心的使用EnumMap来实现基于枚举的查询  
  ```java
  interface Command { void action(); }

  public class EnumMaps {
    public static void main(String[] args) {
      EnumMap<AlarmPoints,Command> em =
        new EnuMap<>(AlarmPoints. class);
      em.put(KITCHEN,
        () -> System.out.println("Kitchen fire!"));
      em.put(BATHROOM,
        () -> System.out.println("Bathroom alert!"));
      for(Map.Entry<AlarmPoints,Command> e: em.entrySet()) {
        System.out.print(e.getKey() + ": ");
        e.getValue().action() ;
      }
      try {       // 如果指定的key没有对应值
        em.get(UTILITY).action();
      } catch(Exception e) {
        System.out.println("Expected: " + e);
      }
    }
  }
  ```
  ```java
  /* 输出:
  BATHROOM: Bathroom alert!
  KITCHEN: Kitchen fire!
  Expected: java.lang.NullPointerException
  */
  ```

  相较于常量特定方法（constant-specific method ）,EnumMap的优势在于：利用EnumMap，你可以改变值对象。
  EnumMap支持多路分发（multiple dispatching）,以应对多个类型的枚举共存且相互影响的各种场景  

# 常量特定方法
  Java的枚举机制可以通过为每个枚举实例编写不同的方法，来赋予它们不同的行为  
  ```java
  public enum ConstantSpecificMethod {
    DATE_TIME {
      @Override String getInfo() {
        return
          DateFormat.getDate!nstance()
            .format(new Date());
      }
    },
    CLASSPATH {
      @Override String getInfo() {
        return System.getenv("CLASSPATH");
      }
    },
    VERSION {
      @Override String getInfo() {
        return Systern.getProperty("java.version");
      }
    };

    abstract String getInfo();
    public static void main(String[] args) {
      for(ConstantSpecificMethod csm : values())
        System.out.println(csm.getlnfo() );
    }
  }
  ```
  ```java
  /*
  Jan 24, 2021
  C:\Git\0nJava8\ExtractedExamplesWgradle\wrapper\gradle
  -wrapper.jar
  1.8.0_41
  */
  ```

  你无法将enum实例等同于类类型：  
  ```java
  enum LikeClasses {
    WINKEN {
      @Override void behavior() {
        System.out.println("Behaviorl");
      }
    },
    BLINKEN {
      @Override void behavior() {
        System.out.printin("Behavior2");
      }
    },
    NOD {
      @Override void behavior() {
        System.out.printin("Behavior3");
      }
    };

    abstract void behavior();
  }
  public class NotClasses {
    // void fl(LikeClasses.WINKEN instance) {}             // 不行
  }
  ```
  - 在f1()方法中，编译器不允许将枚举实例作为类类型来使用————因为每个枚举元素都是LikeClasses的一个static final的实例
  
  EnumSet是一种Set，所以用相同的参数对add()方法的重复调用会被忽略  
  添加枚举实例的顺序并不重要————输出顺序由枚举声明的顺序决定  

## 用枚举实现职责链模式
  职责链（Chain of Responsibility）设计模式先创建了一批用于解决目标问题的不同方法，然后将它们连成一条“链”  

  可以很容易地用常量特定方法实现一条简单的职责链，每种尝试都可以看作一个策略（另一种设计模式），而每个策略列表放在一起就是一条职责链  
  ```java
  public class PostOffice {
    enum MailHandler {
      GENERAL_DELIVERY {
        @Override boolean handle(Mail m) {
          switch(m.generalDelivery) {
            case YES:
              System.out.println(
                "Using general delivery for " + m);
              return true;
            default: return false;
          }
        }
      },
      MACHINE_SCAN {
        @Override boolean handle(Mail m) {
          switch(m.scannability) {
            case UNSCANNABLE: return false;
            default:
              switch(m.address) {
                case INCORRECT: return false;
                default:
                  System.out.printin(
                    "Delivering "+ m + " automatically");
                  return true;
              }
          }
        }
      },
      VISUAL-INSPECTION {
        @Override boolean handle(Mail m) {
          switch(m.readability) {
            case ILLEGIBLE: return false;
            default:
              switch(m.address) {
                case INCORRECT: return false;
                default:
                  System.out.println(
                    "Delivering " + m + " normally");
                  return true;
              } 
          }
        }
      },
      RETURN_TO_SENDER {
        @Override boolean handle(Mail m) {
          switch(m.returnAddress) {
            case MISSING: return false;
            default:
              System.out.println(
                "Returning " + m + " to sender");
              return true;
          }
        }
      };
  
      abstract boolean handle(Mail m);
    }
    static void handle(Mail m) {
      for(MailHandler handler : MailHandler.values())
        if(handler.handle(m))
          return;
      System.out.println(m + " is a dead letter");
    }
  }
  ```
  - 职责链模式的作用体现在了MailHandler枚举中，枚举的定义顺序则决定了各个策略在每封邮件上被应用的顺序

## 用枚举实现状态机
  枚举类型很适合用来实现状态机。状态机可以处于有限数量的特定状态。它们通常根据输入，从一个状态移动到下一个状态，但同时也会存在瞬态。当任务执行完毕后，状态机器会立即跳出所有状态  
  ```java
  public enum Input {
    NICKEL(5), DIME(10), QUARTER(25), DOLLAR(100),
    TOOTHPASTE(200), CHIPS(75), SODA(1O0), SOAP(50),
    ABORT_TRANSACTI0N {
      @Override public int amount() {       // 不允许
        throw newRuntimeException("ABORT.amount()");
      }
    },
    STOP {         // 这必须是最后一个实例
      @Override public int amount() {         // 不允许
        throw new
          RuntimeException("SHUT_DOWN.amount()");
      }
    };

    int value;         // 单位为美分（cent）
    Input(int value) { this.value = value; }
    Input() {}
    int amount() { return value; };       // 单位为美分（cent）
    static Random rand = new Random(47);
    public static Input randomselection() {
      // 不包括STOP：
      return
        values()[rand.nextInt(values().length - 1)];
    }
  }

  enum Category {
    MONEY(Input.NICKEL, Input.DIME,
          Input.QUARTER, Input.DOLLAR),
    ITEM_SELECTION(Input.TOOTHPASTE, Input.CHIPS,
                    Input.SODA, Input.SOAP),
    QUIT_TRANSACTION(Input.ABORTTRANSACTION),
    SHUT_DOWN(Input.STOP);

    private Input[] values;
    Category(Input... types) { values = types; }
    private static EnumMap<Input,Category> categories =
      new EnumMap<>(Input.class);
    static {
      for(Category c : Category.class.getEnumConstants())
        for(Input type : c.values)
          categories.put(type, c);
    }
    public static Category categorize(Input input) {
      return categories.get(input);
    }
  }

  public class VendingMachine {
    private static State state = State.RESTING;
    private static int amount = 0;
    private static Input selection = null;
    enum StateDuration { TRANSIENT }             // 标识enum
    enum State {
      RESTING {
        @Override void next(Input input) {
          switch(Category.categorize(input)) {
            case MONEY:
              amount += input.amount();
              state = ADDING_MOIMEY;
              break;
            case SHUTDOWN;
              state = TERMINAL;
            default:
          }
        }
      },
      ADDING_MONEY {
        @Override void next(Input input) {
          switch(Category.categorize(input)) {
            case MONEY:
              amount += input.amount();
              break;
            case ITEM_SELECTION:
              selection = input;
              if(amount < selection.amount())
                System.out.printin(
                  "Insufficient money for " + selection);
              else state = DISPENSING;
              break;
            case QUIT_TRANSACTION:
              state = GIVING_CHANGE;
              break;
            case SHUT_DOWN:
              state = TERMINAL;
            default:
          }
        }
      },
      DISPENSING(StateDuration.TRANSIENT) {
        @Override void next() {
          System.out.printin("here is your " + selection);
          amount -= selection.amount();
          state = GIVING_CHANGE;
        }
      },
      GIVING_CHANGE(StateDuration.TRANSIENT) {
        @Override void next() {
          if(amount > 0) {
            System.out.printin("Your change: " + amount);
            amount = 0;
          }
          state = RESTING;
        }
      },
      TERMINAL {
        @Override
        void output() { System.out.println("Halted");}
      };
  
      private boolean isTransient = false;
      State() {}
      State(StateDuration trans) { isTransient = true; }
      void next(Input input) {
        throw new RuntimeException("Only call " +
        "next(Input input) for non-transient states");
      }
      void next() {
        throw new RuntimeException(
          "Only call next() for " +
          "StateDuration.TRANSIENT states");
      }
      void output() { System.out.printin(amount); }
    }
    static void run(Supplier<Input> gen) {
      while(state != State.TERMINAL) {
        state.next(gen.get());
        while(state.isTransient)
          state.next();
        state.output();
      }
    }
    public static void main(String[] args) {
      Supplier<Input> gen = new RandomInputSupplier();
      if(args.length == 1)
        gen = new FilelnputSupplier(args[0]);
      run(gen);
    }
  }

  // 基本的稳健性检查：
  class Randominputsupplier implements Supplier<Input> {
    @Override public Input get() {
      return Input.randomSelection();
    }
  }
  ```
  ```java
  /* 
  25
  50
  75
  here is your CHIPS
  0
  100
  200
  here is your TOOTHPASTE
  0
  25
  35
  Your change: 35
  0
  25
  35
  Insufficient money for SODA
  35
  60
  70
  75
  Insufficient money for SODA
  75
  Your change: 75
  0
  Halted
  */
  ```
  - 通过switch语句在枚举实例中进行选择操作是最常见的方式（注意：为了使switch便于枚举，语言层面需要付出额外的代价），所以在组织多个枚举类型时，最常见的问题之一就是“我需要在什么东西之上（即以什么粒度）进行switch”
  - 在run()方法中，售货机等待一个Input，并且会一直在状态间移动，直到它不再处于每个瞬态中

  ```java
  // 从以; 分隔的字符串的文件创建输入
  class FilelnputSupplier implements Supplier<Input> {
    private Iterator<String> input;
    FilelnputSupplier(String fileName) {
      try {
        input = Files.lines(Paths.get(fileName))
        .skip(l)           // 跳过注释行
        .flatMap(s -> Arrays.stream(s.split(";")))
        .map(String::trim)
        .collect(Collectors.toList())
        .iterator();
      } catch(lOException e) {
        throw new RuntimeException(e);
      }
    }
    @Override public Input get() {
      if(!input.hasNext())
        return null;
      return Enum.valueOf(
        Input.class, input.next().trim());
    }
  }
  ```
  - String.split()方法将每一行都根据分号拆开。这样就能生成一个字符串数组，可以通过将该数组转化为Stream，然后执行flatMap(), 来将其注入（前面FileInputSupplier中生成的）Stream中
  - 上述设计有个限制：VendingMachine中会被State枚举实例访问到的字段都必须是静态的，这意味者只能存在一个VendingMachine实例

# 多路分发
  当你处理多个交互类型时，程序可能会变得相当混乱  
  
  答案一开始可能让你意外：Java只能进行单路分发。也就是说，如果你想对多个类型未知的对象进行操作，Java只会对其中一个类型调用动态绑定机制  

  这个问题的解决方法就是多路分发，多态只能在方法调用时发生，所以如果你要使用双路分发，就必须执行两次方法调用，第一次用来确定第一个未知类型，第二次用来确定第二个未知类型。  
  要使用多路分发，就必须对每个类型都进行虚拟调用————如果是在操作两个不同的交互类型层次结构，则需要在每个层次结构都执行虚拟调用。这通常会启用一个配置，使得一次方法调用能够调用多种重载的虚拟调用，从而服务于过程中的多个类型  

  ```java
  public enum Outcome { WIN, LOSE, DRAW }

  public interface Item {
    Outcome compete(Item it);
    Outcome eval(Paper p);
    Outcome eval(Scissors s);
    Outcome eval(Rock r);
  }
      
  public class Paper implements Item {
    @Override public Outcome compete(Item it) {
      return it.eval(this);
    }
    @Override
    public Outcome eval(Paper p) { return DRAW; }
    @Override
    public Outcome eval(Scissors s) { return WIN; }
    @Override
    public Outcome eval(Rock r) { return LOSE; }
    @Override public String toString() {
      return "Paper";
    }
  }
   
  public class Scissors implements Item {
    @Override public Outcome compete(Item it) {
      return it.eval(this);
    }
    @Override
    public Outcome eval(Paper p) { return LOSE; }
    @Override
    public Outcome eval(Scissors s) { return DRAW; }
    @Override
    public Outcome eval(Rock r) { return WIN; }
    @Override public String toString() {
      return "Scissors";
    }
  }

  public class Rock implements Item {
    @Override public Outcome compete(Item it) {
      return it.eval(this);
    }
    @Override
    public Outcome eval(Paper p) { return WIN; }
    @Override
    public Outcome e
    val(Scissors s) { return LOSE; }
    @Override
    public Outcome eval(Rock r) { return DRAW; }
    @Override public String toString() {
      return "Rock";
    }
  }

  public class RoShamBol {
    static final int SIZE = 20;
    private static Random rand = new Random(47);
    public static Item newltem() {
      switch(rand.nextlnt(3)) {
        default:
        case 0: return new Scissors();
        case 1: return new Paper();
        case 2: return new Rock();
      }
    }
    public static void match(Item a, Item b) {
      System.out.println(
        a + " vs. " + b + ": " + a.compete(b));
    }
    public static void main(String[] args) {
      for(int i = 0; i < SIZE; i++)
        match(newItem(), newItem());
    }
  }
  ```
  ```java
  /* 
  Rock vs. Rock: DRAW
  Paper vs. Rock: WIN
  Paper vs. Rock: WIN
  Paper vs. Rock: WIN
  Scissors vs. Paper: WIN
  Scissors vs. Scissors: DRAW
  Scissors vs. Paper: WIN
  Rock vs. Paper: LOSE
  Paper vs. Paper: DRAW
  Rock vs. Paper: LOSE
  Paper vs. Scissors: LOSE
  Paper vs. Scissors: LOSE
  Rock vs. Scissors: WIN
  Rock vs. Paper: LOSE
  Paper vs. Rock: WIN
  Scissors vs. Paper: WIN
  Paper vs. Scissors: LOSE
  Paper vs. Scissors: LOSE
  Paper vs. Scissors: LOSE
  Paper vs. Scissors: LOSE
  */
  ```
  - 虚拟机制决定了a的类型，因此它在a的实际类型的compete()函数中唤醒
  - compete()函数通过对剩余类型调用eval()方法，调用执行了第二次分发。将自身（this）作为参数传入eval()，会产生一个对重载eval()的调用，由此保留了第一次分发的类型

## 使用枚举类型分发
  因为枚举实例并不是类型，所以无法重载eval()方法······你无法将枚举实例作为参数类型  
  ```java
  public enum RoShamBo2 implements Competitor<RoShamBo2> {
    PAPER(DRAW, LOSE, WIN),
    SCISSORS(WIN, DRAW, LOSE),
    ROCK(LOSE, WIN, DRAW);

    private Outcome vPAPER, vSCISSORS, vROCK;
    RoShamBo2(Outcome paper,
      Outcome scissors, Outcome rock) {
      this.vPAPER = paper;
      this.vSCISSORS = scissors;
      this.vROCK = rock;
    }
    @Override public Outcome compete(RoShamBo2 it) {
      switch(it) {
        default:
        case PAPER: return vPAPER;
        case SCISSORS: return vSCISSORS;
        case ROCK: return vROCK;
      }
    }
    public static void main(String[] args) {
      RoShamBo.play(RoShamBo2.class, 20);
    }
  }
  ```
  - RoShamBo2比最初的版本更为简单明了，也因此更容易理解
  - 只有第一次分发使用了虚拟方法调用，第二次分发用的是switch。不过这样做是安全的，因为枚举限制了switch中的状态可选范围

## 使用常量特定方法分发
  由于常量特定方法允许为不同的枚举实例提供不同的方法实现，所以看起来似乎是实现多路分发的完美解决方案。  
  但是即使可以通过这种方法赋予枚举实例不同的行为，枚举实例也仍然不是类型，因此你无法将它们作为方法签名中的参数类型  
  ```java
  public enum RoShamBo3 implements Compelitor<RoShamBo3> {
    PAPER {
      @Override public Outcome compete(RoShamBo3 it) {
        switch(it) {
          default:         // 为了安抚编译器
          case PAPER: return DRAW;
          case SCISSORS: return LOSE;
          case ROCK: return WIN;
        }
      }
    }
    SCISSORS {
      @Override public Outcome compete(RoShamBo3 it) {
        switch(it) {
          default:
          case PAPER: return WIN;
          case SCISSORS: return DRAW;
          case ROCK: return LOSE;
        }
      }
    },
    ROCK {
      @Override public Outcome compete(RoShamBo3 it) {
        switch(it) {
          default:
          case PAPER: return LOSE;
          case SCISSORS: return WIN;
          case ROCK: return DRAW;
        }
      }
    };
    @Override
    public abstract Outcome compete(RoShamBo3 it);
    public static void main(String[] args) {
      RoShamBo.play(RoShamBo3.class, 20);
    }
  }
  ```

  ```java
  public enum RoShamBo4 implements Competitor<RoShamBo4> {
    ROCK {
      @Override
      public Outcome compete(RoShamBo4 opponent) {
        return compete(SCISSORS, opponent),
      }
    },
    SCISSORS {
      @Override
      public Outcome compete(RoShamBo4 opponent) {
        return compete(PAPER, opponent);
      }
    },
    PAPER {
      @Override
      public Outcome compete(RoShamBo4 opponent) {
        return compete(ROCK, opponent);
      }
    };

    Outcome compete(RoShamBo4 loser, RoShamBo4 opponent) {
      return ((opponent == this) ? Outcome.DRAW
          : ((opponent == loser) ? Outcome.WIN
                                  : Outcome.LOSE));
    }
    public static void main(String[] args) {
      RoShamBo.play(RoShamBo4.class, 20);
    }
  }
  ```
  - 此版本更简短，却更难理解，如果将其用于大型系统的开发，这一混淆可能会削弱系统的可维护性

## 使用EnumMap分发
  ```java
  enum RoShamBo5 implements Compelitor<RoShamBo5> {
    PAPER, SCISSORS, ROCK;
    static EnumMap<RoShamBo5,EnumMap<RoShamBo5,Outcome>>
      table = new EnumMap<>(RoShamBoS.class);
    static {
      for(RoShamBo5 it : RoShamBo5.values())
        table.put(it, new EnumMap<>(RoShamBoS.class));
      initRow(PAPER, DRAW, LOSE, WIN);
      initRow(SCISSORS, WIN, DRAW, LOSE);
      initRow(ROCK, LOSE, WIN, DRAW);
    }
    static void initRow(RoShamBo5 it,
      Outcome vPAPER, Outcome vSCISSORS, Outcome vROCK) {
      EnumMap<RoShamBo5,Outcome> row =
        RoShamBo5.table.get(it);
      row.put(RoShamBo5.PAPER, vPAPER);
      row.put(RoShamBo5.SCISSORS, vSCISSORS);
      row.put(RoShamBo5.ROCK, vROCK);
    }
    @0verride public Outcome compete(RoShamBo5 it) {
      return table.get(this).get(it);
    }
    public static void main(String[] args) {
      RoShamBo.play(RoShamBo5.class, 20);
    }
  }
  ```
  - EnumMap是用一个static{}子句进行初始化的，可以看到对initRow()的调用是类似表格的结构。
  - 注意compete()方法，其在内部的一条语句内发生了两次分发

## 使用二维数组分发
  ```java
  enum RoShamBo6 implements Competitor<RoShamBo6> {
    PAPER, SCISSORS, ROCK;
    private static Outcome[][] table = {
      { DRAW, LOSE, WIN },         // 布
      { WIN, DRAW, LOSE },         // 剪刀
      { LOSE, WIN, DRAW },         // 石头
    };
    @Override public Outcome compete(RoShamBo6 other) {
      return table[this.ordinal()][other.ordinal()];
    }
    public static void main(String[] args) {
      RoShamBo.play(RoShamBo6.class, 20);
    }
  }
  ```

# 支持模型匹配的新特性
  模式匹配（pattern matching）是在switch关键字上进行了显著的功能扩充。它是分成了多个模块、历经了Java的多个版本持续实现的。这保证了每个模块在其他模块加入前都可以安全地运行。  

  
# 新特性：switch中的箭头语法
  JDK14增加了在switch中使用一种不同语法的case的能力。  
  colons()用的是旧方式，arrows()用的是新方式：  
  ```java
  public class ArrowInSwitch {
    static void colons(int i) {
      switch(i) {
        case 1: System.out.printin("one");
                break;
        case 2: System.out.printin("two");
                break;
        case 3: System.out.println("three");
                break;
        dfault: System.out.println("default");
      }
    }  
    static void arrows(int i) {
      switch(i) {
        case 1 -> System.out.println("one");
        case 2 -> System.out.printtn("two");
        case 3 -> System.out.printtn("three");
        default -> System.out.printtn("default");
      }
    }
    public static void main(String[] args) {
      range(0, 4).forEach(i -> colons(i));
      range(0, 4).forEach(i -> arrows(i));
    }
  }
  ```
  ```java
  /* 
  default
  one
  two
  three
  default
  one
  two
  three
  */
  ```

# 新特性：switch中的case null
  JDK17新增了（预览）功能，可以在switch中引入原本非法的case null。以前只能在switch的外部检查是否为null  
  ```java
  static void combineNullAndCase(String s) {
    switch(s) {
      case "XX", null -> System.out.println("XX|null");
      default -> System.out.println("default");
    }
  }
  static void combineNullAndDefault(String s) {
    switch(s) {
      case "XX" -> System.out.printin("XX");
      case null, default -> System.out.println("both");
    }
  }
  static void test(Consumer<String> cs) {
    cs.accept("XX");
    cs.accept("YY");
    try {
      cs.accept(null);
    } catch(NullPointerException e) {
      System.out.println(e.getMessage());
    }
  }
  public static void main(String[] args) {
    test(CaseNull::combineNullAndCase);
    test(CaseNull::combineNullAndDefault);
  }
  ```
  ```java
  /*
  XX|null
  default
  XX|null
  XX
  both
  both
  */
  ```
  - null现在在switch中可以作为合法的case了，而且同时使用于箭头和冒号这两种语法
  - Java声称switch会覆盖所有可能的值，即使它实际并未覆盖null。这是向后兼容性导致的问题————如果Java突然开始强制进行null检查，那么大部分已有代码会通过编译

# 新特性：将switch作为表达式
  JDK14使得switch还可以作为一个表达式来使用，因此它可以得到一个值：  
  ```java
  public class SwitchExpression {
    static int colon(String s) {
      var result = switch(s) {
        case "i": yield 1;
        case "j": yield 2;
        case "k": yield 3;
        default: yield 0;
      };
      return result;
    }
    static int arrow(String s) {
      var result = switch(s) {
        case "i" -> 1;
        case "j" -> 2;
        case "k" -> 3;
        default -> 0;
      };
      return result;
    }
    public static void main(String[] args) {
      for(var s: new String[]{"i", "j", "k", "z"})
        System.out.format(
          "%s %d %d%n", s, colon(s), arrow(s));
    }
  }
  ```
  ```java
  /*
  i 1 1
  j 2 2
  k 3 3
  z 0 0
  */
  ```
  - 在使用旧的冒号语法的同时，可以使用新的yield关键字从switch中返回结果。注意在使用yield的时候，并不需要用到break————实际上如果加上了break，反而会在编译时产生错误“试图跳出switch表达式”（attempt to break out of a switch expression）
  - 如果试图在switch语句中使用yield，编译器会产生错误消息“在switch表达式外部yield”（yield outside of switch expression）

  ```java
  public class EnumSwitch {
    enum Signal { GREEN, YELLOW, RED, }
    Signal color = Signal.RED;
    public void change() {
      color = switch(color) {
        case RED -> Signal.GREEN;
        case GREEN -> Signal.YELLOW;
        case YELLOW -> Signal.RED;
      };
    }
  }
  ```
  - 如果在不加上case BLUE的情况下将BLUE加入到enum Signal中，Java的反应则是“switch表达式并未覆盖所有可能的输入值”（the switch expression does not cover all possible input values)。编译器会确保在修改代码的时候不会缺少case

# 新特性：智能转型
  模式匹配支持（support for pattern matching）,在Kotlin语言中，该特性被简单地称为“智能转型”（smart casting）  
  ```java
  public class SmartCasting {
    static void dumb(Object x) {
      if(x instanceof String) {
        String s = (String)x;
        if(s.length() > 0) {
          System,out,format(
            "%d %s%n", s.length(), s.toUpperCase());
        }
      }
    }
    static void smart(Object x) {
      if(x instanceof String s && s.length() > 0) {
        System.out.format(
          "%d %s%n", s.length(), s.toUpperCase());
      }
    }
    static void wrong(Object x) {
      // “|| ”
      // if(x instanceof String s || s.lengthO > 0) {}
      // error: cannot find symbol
    }
    public static void main(String[] args) {
      dumb("dumb");
      smart("smart");
    }
  }
  ```
  ```java
  /* 
  4 DUMB
  5 SMART
  */
  ```
  - x instanceof String s 自动用String类型创建了一个新的变量s。s在整个作用域中都可用，即使是在剩余的if条件中
  - 在if智能转型表达式中只能使用&&。使用||则意味着可能x是个instanceof String，也可能s.length()>0。但这也就意味着x也可能不是String，在这种情况下，Java就不会将x智能转型以生成s，因此s在||右侧是不可用的
  - Java将s称为模式变量（pattern variable）

# 新特性：模式匹配
  
## 违反里式替换原则
  模式匹配也实现了基于类型的行为，却并不要求类型全都具有相同的接口，或都处于相同的继承层次结构中  
  这是一种不同的反射使用方式。你仍然需要在运行时确定类型，但该方式比反射更加正式、更加结构化  

  模式匹配允许使用SmallTalk的方式向子类添加新方法，同时仍然保持里式替换原则的大部分形式。基本上，模式匹配允许违反里式替换原则，而不产生不可控的代码  
  有了模式匹配，就可以通过为每种可能的类型进行检查编写不同的代码，来处理Pet继承层次结构的非里式替换原则的性质：  
  ```java
  public class PetPatternMatch {
    static void careFor(Pet p) {
      switch(p) {
        case Dog d -> d.walk();
        case Fish f -> f.changeWater();
        case Pet sp -> sp.feed();
      };
    }
    static void petCare() {
      List.of(new Dog(), new Fish())
        .forEach(p -> careFor(p));
    }
  }
  ```
  - switch(p)中的p称为选择器表达式（selector expression）。在模式匹配诞生之前，选择器表达式只能是完整的基本类型（char、byte、short或int）、对应的包装类形式（Character、Byte、Short或Integer）、String或enum类型。有了模式匹配，选择器表达式可以支持任何引用类型

  编译器强制增加了case Pet，因为该类可以在不是Dog或Fish的情况下仍然合法的存在。如果没有增加case Pet，switch就无法覆盖所有可能的输入值。为基类使用接口可以消除该约束，但会增加另一个约素。  
  ```java
  sealed interface Pet {
    void feed();
  }
  final class Dog implements Pet {
    @0verride public void feed() {}
    void walk() {}
  }
  final class Fish implements Pet {
    @Override public void feed() {}
    void changeWater() {}
  }
  
  public class PetPatternMatch2 {
    static void careFor(Pet p) {
      switch(p) {
        case Dog d -> d.walk();
        case Fish f -> f.changeWater();
      };
    }
    static void petCare() {
      List.of(new Dog(), new Fish())
        .forEach(p -> careFor(p));
    }
  }
  ```
  - 如果Pet没有用sealed（密封，Java15引入的关键字，用于限制类或方法的随意继承扩充）修饰，编译器会再次发出警告“switch语句没有覆盖所有可能的输入值”
  - 具体原因则是interface Pet可以被其他任何文件中的任何类实现，所以破坏了switch语句覆盖的完整性

  你可以匹配任意类型。想要这样做，就需要将Object传入switch：  
  ```java
  record XX() {}

  public class ObjectMatch {
    static String match(Object o) {
      return switch(o) {
        case Dog d -> "Walk the dog";
        case Fish f -> "Change the fish water";
        case Pet sp -> "Not dog or fish";
        case String s -> "String " + s;
        case Integer i -> "Integer " + i;
        case String[] sa -> String.join(", ", sa);
        case null, XX xx -> "null or XX: " + xx;
        default -> "Something else";
      };
    }

    public static void main(String[] args) {
      List.of(new Dog(), new Fish(), new Pet(),
        "Oscar", Integer.valueOf(12),
        Double.valueOf("47.74"),
        new String[]{ "to", "the", "point" },
        new XX()
      ).forEach(
        p -> System.out.println(match(p))
      );
    }
  }
  ```
  ```java
  /*
  Walk the dog
  Change the fish water
  Not dog or fish
  String Oscar
  Integer 12
  Something else
  to, the, point
  null or Object: XX[]
  */
  ```
  
## 守卫
  守卫（guard）使你可以进一步细化匹配条件，而不只是简单地匹配类型。它是出现在类型判断和&&后的一项测试。守卫可以是任何布尔表达式。如果选择器表达式和case的类型相同，并且守卫判断为true，那么模式就匹配上了：  
  ```java
  sealed interface Shape {
    double area();
  }
  record Circle(double radius) implements Shape {
    @0verride public double area() {
      return Math.PI * radius * radius;
    }
  }
  record Rectangle(double sidel, double side2)
    implements Shape {
    @0verride public double area() {
      return sidel * side2;
    }
  }
  public class Shapes {
    static void classify(Shape s) {
      System.out.println(switch(s) {
        case Circle c && c.area() < 100.0
          -> "Small Circle: " + c;
        case Circle c -> "Large Circle: " + c;
        case Rectangle r && r.sidel() == r.side2()
          -> "Square: " + r;
        case Rectangle r -> "Rectangle: " + r;
      });
    }
    public static void main(String[] args) {
      List.of(
        new Circle(5.0),
        new Circle(25.0),
        new Rectangle(12.0, 12.0),
        new Rectangle(12.0, 15.0)
      ).forEach(t -> classify(t));
    }
  }
  ```
  ```java
  /* 
  Small Circle: Circle[radius=5.0]
  Large Circle: Circle[radius=25.0]
  Square: Rectangle[sidel=12.0, side2=12.0]
  Rectangle: Rectangle[sidel=12.0, side2=15.0]
  */
  ```

## 支配性
  switch中case语句的顺序很重要。如果基类先出现，就会支配任何出现在后面的子类case  

  如果在同一个模式上有多个守卫，更具体的模式必须出现在更泛化的模式之前，否则更泛化的模式会在更具体的模式之前进行匹配，后者就永远没有机会被检查了  
  编译器只有在一个模式中的类型支配了另一个模式中的类型时，才能检测出支配性问题。它无法知道守卫中的逻辑是否会导致问题：  
  ```java
  record Person(String name, int age) {}

  public class People {
    static String categorize(Person person) {
      return switch(person) {
        case Person p && p.age() > 40             
          -> p + " is middle aged";
        case Person p &&
          (p.name().contains("D") || p.age() == 14)
          -> p + " D or 14";
        case Person p && !(p.age() >= 100)        
          -> p + " is not a centenarian";
        case Person p -> p + " Everyone else";
      };
    }
    public static void main(String[] args) {
      List.of(
        new Person("Dorothy", 15),
        new Person("John Bigboote", 42),
        new Person("Morty", 14),
        new Person("Morty Jr.", 1),
        new Person("Jose", 39),
        new Person("Kane", 118)
      ).forEach(
        p -> System.out.println(categorize(p))
      );
    }
  }
  ```
  ```java
  /* 
  Person[name=Dorothy, age=15] D or 14
  Person[name=John Bigboote, age=42] is middle aged
  Person[name=Morty, age=14] D or 14
  Person[name=Morty Jr., age=l] is not a centenarian
  Person[name=Jose, age=39] is not a centenarian
  Person[name=Kane, age=118] is middle aged
  */
  ```

## 覆盖范围
  模式匹配会引导你逐渐使用sealed关键字，这有助于你已覆盖了所有可能传入选择器表达式的类型  
  ```java
  sealed interface Transport {};
  record Bicycle(St ring id) implements Transport {};
  record Glider(int size) implements Transport {};
  record Surfboard(double weight) implements Transport {};

  //如果取消下面这行的注释：
  // record Skis(int length) implements Transport {};
  //便会得到错误消息“switch表达式未覆盖所有可能的输入值”

  public class SealedPatternMatch {
    static String exhaustive(Transport t) {
      return switch(t) {
        case Bicycle b -> "Bicycle " + b.id();
        case Glider g -> "Glider " + g.size();
        case Surfboard s -> "Surfboard " + s.weight();
      };
    }
    public static void main(String[] args) {
      List.of(
        new Bicycle("Bob"),
        new Glider(65),
        new Surfboard(6.4)
      ).forEach(
        t -> System.out.println(exhaustive(t))
      );
      try {
        exhaustive (null);             // 永远有可能发生！
      } catch(NullPointerException e) {
        System.out.println("Not exhaustive: " + e);
      }
    }
  }
  ```
  ```java
  /* 
  Bicycle Bob
  Glider 65
  Surfboard 6.4
  Not exhaustive: java.lang.NullPointerException
  */
  ```

# 总结
  虽然枚举类型本身并不是特别复杂，但由于enum可以与多态、泛型和反射等特性结合使用，所以本章被安排在了比较靠后的位置  
