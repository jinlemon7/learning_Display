有些时候,你需要用到一些反常规的方式,而这时事情就会突然变得复杂。Java也不例外，理解在传递和操纵对象时究竟具体发生了些什么，这一点非常重要  

Java的所有对象标识（除了基本类型）都是指针，但是他们的使用都受到了严格的限制和保护，这些限制和保护不仅来自编译器，而且还来自运行时系统。换句话说，Java有指针，但是没有指针运算。Java的指针即“引用”，你可以认为它是“安全的指针”  

# 传递引用
  当你将一个引用传递给方法后，该引用指向的仍然是原来的对象  
  ```java
  public class PassReferences {
    public static void f(PassReferences h) {
      System.out.println("h inside f(): " + h);
    }
    public static void main(String[] args) {
      PassReferences p = new PassReferences();
      System.out.println("p inside main(): " + p);
      f(p);
    }
  }
  ```
  ```java
  /*
  p inside main(): PassReferences@19e0bfd
  h inside f(): PassReferences@19e0bfd
  */
  ```

  这比只是为了能够向方法传递参数，而专门复制一个新的对象要高效的多。但是这会带来一个重要的问题  

## 引用别名
  引用别名真指的是不止一个引用被绑定到了同一个对象上的情。别名导致的问题主要发生在有人对对象进行写操作时，如果该对象的其他引用的持有者并不希望对象发生变更，那么结果将使其大感意外  

  最好的解决方法其实很简单，就是不要这么做。不要在同一个作用域内，有意识地对一个对象使用一个以上的引用别名。这样你的代码就会很大程度上简化理解和调试的难度。  
  不过，将引用作为参数传入的时候————这正是Java的工作方式————你实际上已经自动命名引用别名了，因为本地创建的引用可以修改“外部的对象”   

  当方法修改了其参数，即外部的对象。当这种情况出现时，你必须判断设是否合理，是否符合用户的预期，以及是否会导致问题。这三个问题的答案通常是不合理、不符合预期、会导致问题，这也是纯粹函数式语言并不允许这种行为的原因  

  通常来说，调用方法是为了得到返回值，以及/或者改变调用方法的对象的状态（内部属性）。很少有为了操作方法的参数而调用方法的情况，这是“调用方法只是为了利用其副作用”的一种形式  

  如果你在方法调用的过程中必须修改参数，同时又不想改变该参数在方法外部的状态，那么就要通过在方法内部复制出一个参数的副本的方式对其进行保护  

# 创建本地副本
  Java 并未提供防止对象并修改和消除别名负面影响的相关支持（例如“const”）。你不能简单地在参数列表中使用final关键字，这只能阻止你将该引用重新绑定到另一个不同的对象上，但引用指向的对象本身是可以改变的  

  现在编程语言支持在方法内自动创建外部对象的本地副本的能力。Java并不支持这样做，但是它可以让你实现相同的效果  

## 值传递
  值传递（pass by value）：无论你传递的是什么，你都会得到一个本地的副本  
  java在传递基本类型时，传递的是值，但在传递对象时，传递的则是引用  

## 克隆对象
  创建对象的本地副本，最可能的原因是你要修改该对象，但并不想修改调用者的原有对象。一种方法是使用clone()方法。clone()是在基类Object中定义的，并且访问权限为protected。你需要在任何你想要克隆的子类中将clone()方法重写为public方法  
  ```java
  class Int {
    private int i;
    Int(int ii) { i = ii; }
    public void incremento { i++; }
    @Override public String toString() {
      return Integer.toString(i);
    }
  }
  public class CloneArrayList {
    public static void main(String[] args) {
      ArrayList<Int> v = IntStream.range(0, 10)
        .mapToObj(Int::new)
        . collect(Collectors
          .toCollection(ArrayList::new));
      System.out.println("v: " + v);
      (@SuppressWarnings ("unchecked")
      ArrayList<Int> v2 = (ArrayList<Int>)v.clone();
      // 对v2中的所有元素进行自增
      v2.forEach(Int:¡increment);
      // 看看是否修改了v中的元素
      System.out.println("v: " + v);
    }
  }
  ```
  ```java
  /*
  v: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
  v: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
  */
  ```
  - clone()方法生成了一个Object,然后该Object必须被转换为合适的类型
  - 原有的ArrayList和克隆的ArrayList都是同一个对象的不同引用别名。这是一种浅拷贝（shallow copy），因为只复制了对象的“表层”部分
  - 创建所有内容的完整副本————“对象网络”，被称为深拷贝（deep copy）

## 为类增加可克隆能力
  理论上基类中的方法应该在子类中也总是可用的。Java中的克隆确实违反了这个概念，如果你希望某个类具备克隆能力，就必须专门添加代码来使其生效  

### 利用protected的技巧
  为了避免你创建的所有类都具有默认的可克隆能力，基类Object中的clone()方法是protected的。这意味着对于那些只是简单使用某个类（并不继承出子类）的调用方程序员来说，可克隆能力并不是默认可用的。  

  基类中的clone()的功能有用，它会执行实际子类对象的按位复制，因此充当了公用的克隆操作。不过为了使你的克隆操作可被访问，你必须将它设为public的。因此，在你克隆时，有两个关键步骤：  
  - 调用super.clone()
  - 将你的克隆操作设为public的

  protected的技巧只有一次使用时机，即你首次继承一个不具备克隆能力的类，且希望继承出的类具备可克隆性时。对于从该继承类再度继承出的任何类，clone()方法都是可用的，因为在Java中是不可能在派生过程中缩小方法访问权限的  

### 实现Cloneable接口
  要让对象实现完整的克隆能力，还需要进一步操作实现Cloneable接口。这是一个空（标记）接口  

  第一个原因是，你可能有个对某父类型的向上转型的引用，但并不知道是否可以克隆该对象。这时可以使用instanceof关键字来找出该引用是否和某个可克隆的对象有关联：  
  `if(myReference instanceof Cloneable) // ...`  

  第二个原因是，可克隆能力的设计背后有一种考虑，即可能你并不希望所有类型的对象都是可克隆的  
  一般来说你是被迫加上implements Cloneable的，以作为支持克隆的必要操作  

## 成功的克隆
  ```java
  class Duplo implements Cloneable {
    private int n;
    Duplo(int n) { this.n = n; }
    @Override public Duplo clone() {               // [1]
      try {
        return (Duplo)super.clone();
      } catch(CloneNotSupportedException e) {
        throw new RuntimeException(e);
      }
    }
    public int getValue() { return n; }
    public void setValue(int n) { this.n = n; }
    public void increment() { n++; }
    @Override public String toString() {
      return Integer.toString(n);
    }
  }

  public class LocalCopy {
    public static Duplo g(Duplo v) {
      // 传递引用，修改了外部的对象
      v.increment();
      return v;
    }
    public static Duplo f(Duplo v) {
      v = v.clone();             // 本地副本     //[2]
      v.increment();
      return v;
    }
    public static void main(String[] args) {
      Duplo a = new Duplo(11);
      Duplo b = g(a);
      // 引用相等，并不是对象相等
      System.out.println("a == b: " + (a == b) +
        "\na = “ + a + "\nb = " + b);
      Duplo c = new Duplo(47);
      Duplo d = f(c);
      System.out.println("c == d: " + (c == d) +
        "\nc = " + c + "\nd = " + d);
    }
  }
  ```
  ```java
  /* 
  a == b: true
  a = 12
  b = 12
  c == d: false
  c = 47
  d = 48
  */
  ```
  - 首先，为了使clone()能被访问，必须将它设为public的。
  - 其次在你的clone()操作的开始部分，调用基类版本的clone()。这里调用的clone()即在Object中预先定义好的那个clone(),你可以调用该方法，因为它是protected的，可以在子类中被访问
  - Object.clone()会检测出该对象有多大,并为新对象创建足够的内存空间，然后将旧对象所有的二进制位都复制到新对象中。这称为按位复制，通常也是你希望clone()方法做的事
  - Object.clone()在执行操作之前，会先检查（在继承层次结构中）是否有类似Cloneable的，也就是它是否实现了Cloneable接口。如果没有,Object.clone()会抛出CloneNotSupportException异常,表明你无法对它进行克隆。因此，你必须用try块，将对super.clone()的调用包裹起来,以捕获那个永远不会发生的异常(因为你已经实现了Cloneable接口)

  [1]注意此处用到的协变返回类型。基类Object的clone()方法只能返回Object，但是子类的clone()可以返回更具体的类型。在协变返回类型出现之前，你必须将返回类型向下转型为合适的类型，但现在它可以在编译器进行验证  
  Java中的相等判定并不会深入对象的内部去看两者的值是否相等。==和!=操作只是简单的比较引用  

## Object.clone()的效果
  根类中的clone()方法负责创建正确大小的存储空间，并执行了从原始对象中的所有二进制位到新对象存储中的按位复制  
  根类并不知道具体哪个对象会被继承，因此你可以猜到，这个过程中用到了反射来确定要克隆的实际对象。这样，clone()方法就可以创建大小合适的存储空间，并正确地对该类型执行按位复制  

  克隆过程通常应该从super.clone()开始,这样便通过创建精确的副本，为克隆操作奠定了基础，然后就可以执行所需的其他操作来完成克隆了  

  ```java
  public class Snake implements Cloneable {
    private Snake next;
    private char c;
    // i 的值 == 蛇身的段数
    public Snake(int i, char x) {
      c = x;
      if(--i > 0)
        next = new Snake(i, (char)(x + 1));
    }
    public void increment() {
      c++; 
      if(next != null)
        next.increment();
    }
    @Override public String toString() {
      String s = ":" + c;
      if(next != null)
        s += next.toString();
      return s;
    }
    @Override public Snake clone() {
      try {
        return (Snake)super.clone();
      } catch(CloneNotSupportedException e) {
        throw new RuntimeException(e);
      }
    }
    public static void main(String[] args) {
      Snake s = new Snake(5, 'a');
      System.out.println("s = " + s);
      Snake s2 = s.clone();
      System.out.println("s2 = " + s2);
      s.increment();
      System.out.println (
        "after s.increment, s2 = " + s2);
    }
  }
  ```
  ```java
  /*
  s = :a:b:c:d:e
  s2 = :a:b:c:d:e
  after s.increment,
  s2 = :a:c:d:e:f
  */
  ```
  - 从结果可以看出，只有第一段被Object.clone()复制了,因此他执行的是浅拷贝。如果要想要复制整条蛇，也就是深拷贝，你需要在重写的clone()方法中执行额外的操作

  在任何派生自可克隆类的类中，你通常需要调用super.clone(),以确保所有基类的操作(包括Object.clone() )都执行了。然后对对象中的所有引用都显式的执行clone()，否则这些引用都将只是原始对象中对应引用的别名  
  这和调用构造器的方法相似，区别在于clone()并不是构造器，因此无法自动实现这种调用机制。你必须确保自己实现这种机制  

## 克隆组合对象
  你必须假设所有成员对象中的clone()方法都会按顺序对各自的引用执行深拷贝，并照此进行下去。这一点是必须确保的。  
  它实际上意味着为了正确执行深拷贝，你要么需要控制所有类的所有代码，要么至少对深拷贝涉及的所有类都足够了解，以确定他们都能正确地执行各自的深拷贝  
  ```java
  public class OceanReading implements Cloneable {
    private DepthReading depth;
    private TemperatureReading temperature;
    public OceanReading(double tdata, double ddata) {
      temperature = new TemperatureReading(tdata);
      depth = new DepthReading(ddata);
    }
    @Override public OceanReading clone() {
      OceanReading or = null;
      try {
        or = (OceanReading)super.clone();
      } catch(CloneNotSupportedException e) {
        throw new RuntimeException(e);
      }
      // 必须克隆引用
      or.depth = (DepthReading)or.depth.clone();
      or.temperature =
        (TemperatureReading)or.temperature.clone();
      return or;
    }
    public TemperatureReading getTemperatureReading() {
      return temperature;
    }
    public void
    setTemperatureReading(TemperatureReading tr) {
      temperature = tr;
    }
    public DepthReading getDepthReading() {
      return depth;
    }
    public void setDepthReading(DepthReading dr) {
      this.depth = dr;
    }
    @Override public String toString() {
      return "temperature: " + temperature +
        ", depth: " + depth;
    }
  }
  ```
  - DepthReading和Temperature很相似，它们都只包含基本类型。因此，clone()方法可以很简单：调用super.clone()
  - OceanReading是由DepthReading和TemperatureReading对象组合而成的，因此，要实现深拷贝，它的clone()就必须克隆OceanReading内部的所有引用。要完成这项任务,super.clone()的结果必须转型为OceanReading对象(这样才可以访问depth和temperature的引用)

## 深拷贝ArrayList
  ```java
  class Int2 implements Cloneable {
    private int i;
    Int2(int ii) { i = ii; }
    public void increment() { i++; }
    @Override public String toString() {
      return Integer.toString(i);
    }
    @Override public Int2 clone() {
      try {
        return (Int2)super.clone();
      } catch(CloneNotSupportedException e) {
        throw new RuntimeException(e);
      }
    }
  }

  //继承不会移除可克隆性：
  class Int3 extends Int2 {
    private int j;       // 自动创建了副本
    Int3(int i) { super(i); }
  }

  public class AddingClone {
    @SuppressWarnings("unchecked")
    public static void main(String[] args) {
      Int2 x = new Int2(10);
      Int2 x2 = x.clone();
      x2.increment();
      System.out.println(
        "x = " + x + ", x2 = " + x2);
      // 继承出的任何事物同样也是可克隆的：
      Int3 x3 = new Int3(7);
      x3 = (Int3)x3.clone();
      ArrayList<Int2> v = IntStream.range(0, 10)
        .mapToObj(Int2::new)
        .collect(Collectors
          .toCollection(ArrayList::new));
      System.out.println("v: " + v);
      ArrayList<Int2> v2 =
        (ArrayList<Int2>)v.clone();
      // 现在克隆每个元素：
      IntStream.range(0, v.size() )
        .forEach(i -> v2.set(i, v.get(i).clone()));
      // 对v2的所有元素进行加1：
      v2.forEach(Int2:¡increment);
      System.out,pnntln("v2: " + v2);
      // 看看是否改变了v中的所有元素：
      System.out.println("v: " + v);
    }
  }
  ```
  ```java
  /* 
  X = 10, x2 = 11
  v: [0, 1, 2f 3, 4, 5, 6, 7, 8, 9]
  v2: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
  v: [0, 1, 2, 3, 4f 5, 6, 7, 8, 9]
  */
  ```
  - 在调用Int3的clone()时，其内部所调用的Int2的clone()，实际上调用的是Object.clone(),它检测到此处起作用的是Int3，并对int3执行按位复制。
  - 只要你不增加需要克隆的引用，对Object.clone()的一次调用便可以执行所有必要的复制,无论clone()定义在继承层次结构中多么深的位置

  要深拷贝ArrayList,需要这样做：在克隆ArrayList后，还要进一步克隆ArrayList所指向的每一个对象。如果要深拷贝如HashMap这样的内容，你也需要执行类似的操作  

## 通过序列化进行深拷贝
  如果一个对象先进行序列化，再将其反序列化，那么它实际上就是被克隆了  
  ```java
  class Thing1 implements Serializable {}
  class Thing2 implements Serializable {
    Thing1 t1 = newThing1();
  }
  class Thing3 implements Cloneable {
    @Override public Thing3 clone() {
      try {
        return (Thing3)super.clone();
      } catch(CloneNotSupportedException e) {
        throw new RuntimeException(e);
      }
    }
  }
  class Thing4 implements Cloneable {
    private Thing3 t3 = new Thing3();
    @Override public Thing4 clone() {
      Thing4 t4 = null;
      try {
        t4 = (Thing4)super.clone();
      } catch(CloneNotSupportedException e) {
        throw new RuntimeException(e);
      }
      //对字段也进行克隆：
      t4.t3 = t3.clone(); 
      return t4;
    }
  }

  public class Compete {
    public static final int SIZE = 100000;
    public static void
    main(String[] args) throws Exception {
      Thing2[] a = new Thing2[SIZE];
      for(int i = 0; i < SIZE; i++)
        a[i] = new Thing2();
      Thing4[] b = new Thing4[SIZE];
      for(int i = 0; i < SIZE; i++)
        b[i] = new Thing4();
      Timer timer = new Timer();
      try(
        ByteArrayOutputStream buf =
          new ByteArrayOutputStream();
        ObjectOutputStream oos =
          new ObjectOutputStream(buf)
      ) {
        for(Thing2 a1 : a) {
          oos.writeObject(a1);
        }
        // 现在获取副本：
        try(
          ObjectInputStream in =
            new ObjectInputStream(
              new ByteArrayInputStream(
                buf.toByteArray()))
        ){
          Thing2[] c = new Thing2[SIZE];
          for(int i = 0; i < SIZE; i++)
            c[i] = (Thing2)in.readObject();
        }
      }
      System.out.println(
        "Duplication via serialization: " +
        timer.duration() + " Milliseconds");
      // 现在试试克隆:
      timer = new Timer();
      Thing4[] d = new Thing4[SIZE];
      for(int i = 0; i < SIZE; i++)
        d[i] = b[i].clone();
      System.out.printin(
        "Duplication via cloning: " +
        timer.duration() + " Milliseconds");
    }
  }
  ```
  ```java
  /* 
  Duplication via serialization: 385 Milliseconds
  Duplication via cloning: 38 Milliseconds
  */
  ```
  - Serializable类很容易构建，但是需要大量的额外操作来复制它们。
  - 在克隆所需要的操作中，类的构建工作更多，但是实际的对象复制操作相对简单

  序列化至少要比克隆慢一个数量级  

## 在继承层次结构中增加可克隆性并向下覆盖
  如果你创建了一个新的类，则其基类默认是Object，因此默认是不具备可克隆性的。只要你不显示的增加可克隆性，它就不会具备该能力。  
  你可以在继承层次结构中的任意一层增加该能力，并且从该层开始向下的所有层次都会具备该能力  
  ```java
  class Person {}
  class Hero extends Person {}
  class Scientist extends Person implements Cloneable {
    @Override public Scientist clone() {
      try {
        return (Scientist)super.clone();
      } catch(CloneNotSupportedException e) {
        throw new RuntimeException(e);
      }
    }
  }

  class MadScientist extends Scientist {}
  public class HorrorFlick {
    public static void main(String[] args) {
      Person p = new Person();
      Hero h = new Hero();
      Scientist s = new Scientist();
      MadScientist m = new MadScientist();
      //- p = (Person)p.clone();         // 编译错误
      //- h = (Hero)h.clone();           // 编译错误
      s = s.clone();
      m = (MadScientist)m.clone();
    }
  }
  ```
  - 在向继承层次结构中增加可克隆性之前，编译器会阻止你进行克隆
  - 在对Scientist加入可克隆性后，Scientist及它的所有后代就都是可克隆的了
  - 注意Scientist的clone()返回的是Scientist，而在克隆MadScientist时，它并未创建自己的克隆方法，而是使用了继承自Scientist的clone()，因此需要转型

## 为什么用这种奇怪的设计
  Java是为了控制硬件设备而设计的一种语言  
  当Java被视为互联网编程语言后，事情就变得不同了。安全问题开始出现，并且这些问题都是用对象处理的，而你并不一定想让任何人都可以复制你的安全相关的对象。  
  因此你可以看到原本简单易懂的设计上增加了许多补丁：Object中的clone()现在是protected的了，你必须重写它，并且实现Cloneable接口，还要处理异常  

  你只有在需要调用Object的clone()方法时才必须实现Cloneable接口，因为该方法会在运行时进行检查，确保你的类实现了Cloneable接口

# 控制可克隆性
  可以通过不实现Cloneable接口并重写clone()，使其抛出异常，来尽量避免克隆。不过程序员可以不调用super.clone()，绕过限制，使用自己的方法实现clone()  
  
  将类定义为final的，以阻止克隆。如果clone()没有被任何父类重写，那么它就不能被重写。如果被重写过，那么就再次重写，并抛出CloneNotSupportException异常。  
  将类定义为final是唯一保证可以阻止克隆的方法  

  ```java
  // 无法克隆——未重写clone()：
  class Ordinary {}

  //重写clone(),未实现Cloneable接口：
  class WrongClone extends Ordinary {
    @Override public Object clone()
    throws CloneNotSupportedException {
      return super.clone();         // 抛出异常
    }
  }

  //完美克隆：
  class IsCloneable extends Ordinary
  implements Cloneable {
    @Override public Object clone()
    throws CloneNotSupportedException {
      return super.clone();
    }
  }

  //通过抛出异常来关闭克隆
  class NoMore extends IsCloneable {
    @Override public Object clone()
    throws CloneNotSupportedException {
      throw new CloneNotSupportedException();
    }
  }

  class TryMore extends NoMore {
    @Override public Object clone()
    throws CloneNotSupportedException {
      // 调用NoMore.clone()，抛出异常
      return super.clone();
    }
  }

  class BackOn extends NoMore {
    private BackOn duplicate(BackOn b) {
    // 以某种方式生成b的副本，并返回该副本，这个副本毫无作用，只是为了举例：
      return new BackOn();
    }
    @Override public Object clone() {
      // 未调用NoMore.clone()
      return duplicate(this);
    }
  }

  //你无法继承该类，因此无法像在BackOn中一样重写clone()
  final class ReallyNoMore extends NoMore {}

  public class CheckCloneable {
    public static
    Ordinary tryToClone(Ordinary ord) {
      String id = ord.getClass().getName();
      System.out.println("Attempting " + id);
      Ordinary x = null;
      if(ord instanceof Cloneable) {
        try {
          x = (Ordinary)((IsCloneable)ord).clone();
          System.out.println("Cloned " + id);
        } catch(CloneNotSupportedException e) {
          System.out.println(
            "Could not clone " + id);
        }
      } else {
        System.out.println("Doesn't implement Cloneable");
      }
      return x;
    }
    public static void main(String[] args) {
      // 向上转型：
      Ordinary[] ord = {
        new IsCloneable(),
        new WrongClone(),
        new NoMore(),
        new TryMore(),
        new BackOn(),
        new ReallyNoMore(),
      };
      Ordinary x = new Ordinary();
      // 这样无法编译，因为Object中的clone()是protected的；
      //- x = (Ordinary)x.clone();
      // 先检查该类是否实现了Cloneable接口：
      for(Ordinary ord1 : ord) {
        tryToClone(ord1);
      }
    }
  }
  ```
  ```java
  * 
  Attempting IsCloneable
  Cloned IsCloneable
  Attempting WrongClone
  Doesn't implement Cloneable
  Attempting NoMore
  Could not clone NoMore
  Attempting TryMore
  Could not clone TryMore
  Attempting BackOn
  Cloned BackOn
  Attempting ReallyNoMore
  Could not clone ReallyNoMore
  */
  ```
  - WrongClone类演示了一种不正确的实现可控的方式。它确实重写了Object.clone()并将其改为public的，但是并未实现Cloneable接口，因此在调用super.clone()是（会导致调用Object.clone()），会抛出CloneNotSupportedException异常，所以这样克隆时不行的
  - NoMore试图关闭克隆能力，它使用的是Java设计者们预期的方法：在子类的clone()方法中抛出CloneNotSupportException异常。TryMore类中的clone()方法正确地调用了super.clone()，这指向了NoMore.clone(),它抛出了异常，阻止了克隆
  - 但是程序员并没有遵循在重写的clone()中调用super.clone()这个"正确"的途径,又会怎么样呢?在BackOn中,可以看到这是如何发生的。该类通过一个单独的duplicate()方法创建了一个当前对象的副本，并在clone()中调用了这个方法，而不是super.clone()方法。异常永远不会被抛出，而新的类依旧是可克隆的
  - final类中的clone()方法抛出了异常，无法通过继承来修改，确保阻止了克隆（在层次结构中，你无法在任何一层的类上显示的调用Object.clone()。你被限制于仅能调用super.clone(),该方法只能访问直接的上一层基类）
        
  如果你想要一个可克隆的类，则需要：  
  1. 实现Cloneable接口；
  2. 重写clone()方法；
  3. 在clone()方法中调用super.clone()方法；
  4. 在clone()方法中捕获异常

## 复制构造器
  复制构造器（copy constructor，又称拷贝构造器，即会创建对象副本的构造器）  
  ```java
  public class CopyConstructor {
    public static void ripen(Tomato t) {
      // 使用“复制构造器”
      t = new Tomato(t);                            //[1]
      System.out.println("In ripen, t is a " +
        t.getClass().getName()) ;
    }
    public static void slice(Fruit f) {
      f = new Fruit(f);          // 这样行的通吗？   //[2]
      System.out.println("In slice, f is a " +
        f.getClass().getName());
    }
    @SuppressWarnings("unchecked")
    public static void ripen2(Tomato t) {
      try {
        Class c = t.getClass();
        // 使用“复制构造器”
        Constructor et =
          c.getConstructor(new Class[] { c });
        Object obj =
          ct.newInstance(new Object[] { t });
        System.out.println("In ripen2, t is a "
          obj.getClass().getName());
      } catch(NoSuchMethodException |
              SecurityException |
              InstantiationException |
              IllegalAccessException |
              IllegalArgumentException |
              InvocationTargetException e) {
        System.out.println(e);
      }
    }
    @SuppressWarnings("unchecked" )
    public static void slice2(Fruit f) {
      try {
        Class c = f.getClass();
        Constructor et =
          c.getConstructor(new Class[] { c });
        Object obj =
          ct.newInstance(new Object[] { f });
        System.out.println("In slice2, f is a " +
          obj.getClass().getName());
      } catch(NoSuchMethodException |
              SecurityException |
              InstantiationException |
              IllegalAccessException |
              IllegalArgumentException |
              InvocationTargetException e) {
        System.out.printin(e);
      }
    }
    public static void main(String[] args) {
      Tomato tomato = new Tomato();
      ripen(tomato);       // OK
      slice(tomato);       // OOPS!
      ripen2(tomato);      // OK
      slice2(to=mato);     // OK
      GreenZebra g = new GreenZebra();
      ripen(g);            // OOPS!
      slice(g);            // OOPS!
      ripen2(g);           // OK
      slice2(g);           // OK
      g.evaluate();
    }
  }
  ```
  ```java
  /* 
  In ripen, t is a Tomato
  In slice, f is a Fruit
  java.lang.NoSuchMethodException: Tomato.<init>(Tomato)
  java.lang.NoSuchMethodException: Tomato.<init>(Tomato)
  In ripen, t is a Tomato
  In slice, f is a Fruit
  java.lang.NoSuchMethodException:
  GreenZebra.<init>(GreenZebra)
  j ava.lang.NoSuchMethodException:
  GreenZebra.<init>(GreenZebra)
  */
  ```
  - [1]ripen()以Tomato为参数，并为其实现了复制构造器以生成该对象
  - [2]slice()以更泛化的Fruit对象为构造器，并同样生成了该对象的副本
  - slice()中的复制构造器对Tomato发生作用后，输出的结果不再是Tomato对象，而只是一个Fruit。它已经丢失了所有tomato的特征。并且，使用GreenZebra的时候，ripen()和slice()分别将其转换成了Tomato和Fruit

  C++中，你可以操纵类似引用的实体，也可以直接传递对象。这就是C++的复制构造器的目的：接收对象并将其按值传递，从而复制该对象。因此在C++中它可以正常工作，但是要记住这种方法在Java中会失败，所以不要使用

# 不可变类
  一种解决方案(已在纯函数式编程语言中使用)是创建属于只读类的不可变对象(immutable object)  
  如果各处代码对同一个对象只会进行读取，那么就不会出现问题  

## 创建不可变类
  ```java
  public class Immutable1 {
    private int data;
    public Immutablel(int initVal) {
      data = initVal;
    }
    public int read() { return data; }
    public boolean nonzero() { return data != 0; }
    public Immutablel multiply(int multiplier) {
      return new Immutable1(data * multiplier);
    }
    public static void f(Immutable1 i1) {
      Immutable1 quad = i1.multiply(4);
      System.out.println("il = " + il.read());
      System.out.println (" quad = " + quad.read());
    }
    public static void main(String[] args) {
      Immutable1 x = new Immutable1(47);
      System.out.printin ("x = " + x.read());
      f(x);
      System.out.printin ("x = " + x.read());
    }
  }
  ```
  ```java
  /*
  x = 47
  i1 = 47
  quad = 188
  x = 47
  */
  ```
  - 各处的data都是private的,并且你可以发现没有任何public方法可以修改这些data
  - x的对象可以无风险地使用任意多个引用别名, 因为Immutable1类从设计上就确保了对象不会被改变

## 不可变性的缺点
  创建不可变类，乍一看似乎为我们提供了一种优雅的解决方案。不过每当你确实需要修改这种新类型的对象时，就必须忍受创建新对象的开销，并可能导致更频繁的垃圾收集  
  解决方法是创建一个可以被修改的伴生类。然后，如果你要做很多的修改工作，就可以切换使用该可被修改的伴生类，并在完成后切换回不可变类  
  ```java
  class Mutable {
    private int data;
    Mutable(int initVal) {
      data = initVal;
    }
    public Mutable add(int x) {
      data += x;
      return this;
    }
    public Mutable multiply(int x) {
      data *= x;
      return this;
    }
    public Immutable2 makeImmutable2() {
      return new Immutable2(data);
    }
  }
  public class Immutable2 {
    private int data;
    public Immutable2(int initVal) {
      data = initVal;
    }
    public int read() { return data; }
    public boolean nonzero() {
      return data != 0;
    }
    public Immutable2 add(int x) {
      return new Immutable2(data + x);
    }
    public Immutable2 multiply(int x) {
      return new Immutable2(data * x);
    }
    public Mutable makeMutable() {
      return new Mutable(data);
    }
    public static
    Immutable2 modify1(Immutable2 y) {
      Immutable2 val = y.add(12);
      val = val.multiply(3);
      val = val.add(11);
      val = val.multiply(2);
      return val;
    }
    // 这样会得到相同的结果：
    public static
    Immutable2 modify2(Immutable2 y) {
      Mutable m = y.makeMutable();
      m.add(l2).multiply(3).add(11).multiply(2);
      return m.makeImmutable2();
    }
    public static void main(String[] args) {
      Immutable2 i2 = new Immutable2(47);
      Immutable1 r1 = modify1(i2);
      Immutable2 r2 = modify2(i2);
      System.out.println("i2 = " + i2.read());
      System.out.println("rl = " + rl.read());
      System.out.println("r2 = " + r2.read());
    }
  }
  ```
  ```java
  /*
  i2 = 47
  r1 = 376
  r2 = 376
  */
  ```
  - modify2()中的第一个行为是接受Immutable2 y参数，并用该参数生成了Mutable对象（这就和你之前看到的clone()调用一样，不过这次是成立了一个不同类型的对象）。然后便用Mutable对象执行了很多多修改操作，并不需要创建那么多新对象。最后，他又变回了Immutable2对象。此处创建了两个新对象（Mutable和结果对象Immutable2），而不是四个

  因此这种方法在以下情况下是合理的选择：  
  1. 你需要不可变对象
  2. 并且你经常需要做很多修改操作
  3. 或者创建新的不可变对象的开销很大

## String很特殊
  String本质上是不可变的  
  你会看到当String出现的内容发生变化时，每个String的方法都会谨慎地返回一个新的String对象。如果内容不需要更改，则该方法只返回指向原始String的引用，这样便节省了存储空间和开销  

  String中有很多特殊情况，最重要的一点是，他是内建的类，也是Java的重要基础。因此，你会看到编译器将双引号包围的字符转换为String，以及特殊的重载操作符+和+=的使用  

# 总结
  在C或C++方法中初始化一段内存空间的时候，你可能会要求用户向方法中传递该段内存的地址。否则，你就必须确保存储的正确销毁。因此，这类方法的接口和所需的理解都会更加复杂。但在Java中，你不必担心这些职责，也不必担心对象在需要时是否仍然存在，因为这些总会自动为你处理好  

  这种简化有时不会引起你的注意，但有时则会令你大吃一惊  
  1. 额外的内存管理总是会导致运行效率降低，尽管这通常不是问题
  2. 引用别名：有时你最终会遇到两个指向同一个对象的引用，这只有在这两个引用都应该指向不同的对象时，才会成为问题。必要时可以使用clone()或其他方式复制对象，来防止其他引用被意外的修改。或者，你可以通过创建不可变的对象来支持引用别名，以提高效率，这些对象的操作可以返回相同类型或某些不同类型的新对象，但绝不会更改原始对象，因此任何指向该对象的引用别名都不会看到任何更改

  相较于自行编写支持克隆的代码，你更应该考虑使用Apache通用序列化实用工具类（Apache Commons Serialization Utility Classes）,或深克隆库(deep cloning library)或者一些其他的克隆库  
