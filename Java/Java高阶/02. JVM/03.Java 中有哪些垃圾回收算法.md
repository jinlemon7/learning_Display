关于垃圾回收算法，其实不用死记硬背，它们本质上就是处理内存碎片的几种不同策略。  
你就想象成我们在打扫房间，主要有这么三种流派：  

# 标记-清除算法（Mark-Sweep）
  这是最基础的流派。  
  它的逻辑很简单：先遍历一遍，把有用的东西打个勾（标记），然后把没打勾的垃圾直接扔掉（清除）。 但这有个大坑，就是内存碎片。  

  你想啊，你把垃圾扔了，空出来的地方东一块西一块的，像蜂窝煤一样。下次想放个大件家具（大对象），明明总空间够，但就是找不到一块完整的地儿，这就很尴尬。  

  <img width="866" height="162" alt="image" src="https://github.com/user-attachments/assets/b8deaedf-22f2-4e2e-a2d8-805510b9001a" />

  为了解决碎片问题，就有了复制算法  

# 复制算法（Copying）
  它把内存一分为二，平时只用一半。回收的时候，把活着的对象全部复制到另一半去，整整齐齐排好，然后把原来那一半直接清空。  

  好处是快，而且绝对没有碎片。坏处也很明显，太浪费空间了，得空着一半地盘不能用。  

  <img width="925" height="176" alt="image" src="https://github.com/user-attachments/assets/d61fd46f-4660-4744-a8c9-9baa7a1e79d9" />

  不过，在 Java 的新生代里，因为绝大部分对象都是“朝生夕死”的，存活的很少，复制成本低，  
  所以这种算法特别好使（当然实际不用 1:1 分，而是 Eden/Survivor 这种更聪明的比例）。  

# 标记-整理（Mark-Compact）
  这是老年代常用的算法。  
  老年代的对象活得久，如果你用复制算法，得复制一大堆，太慢！如果用标记-清除，又有碎片  

  所以标记-整理就折中了一下：也是先标记，但在清理之前，先把所有活着的对象往一端推，像整理书架一样把它们排紧凑，然后再把剩下的空间全部清空。  
  这样既没有碎片，又不需要浪费一半空间，代价就是整理（移动对象）这个动作比较耗时。  

  <img width="841" height="160" alt="image" src="https://github.com/user-attachments/assets/0ffa7d81-5664-428d-8481-795833a8d50a" />

# 标记-清除详细分析
  分为两个阶段：  
  - 标记阶段：tracing 阶段，从根（栈、寄存器、全局变量等）开始遍历对象图，标记所遇到的每个对象。
  - 清除阶段：扫描堆中的对象，将未标记的对象作为垃圾回收。

  <img width="867" height="630" alt="image" src="https://github.com/user-attachments/assets/51bb5501-3080-4d75-89d9-0191f4b68a77" />

  清除不会移动和整理内存空间，一般都是通过空闲链表(双向链表)来标记哪一块内存空闲可用，因此会导致一个情况：空间碎片。  
  这会使得明明总的内存是够的，但是申请内存就是不足。  
  
  <img width="388" height="192" alt="image" src="https://github.com/user-attachments/assets/710cb1d7-1533-4463-834b-35ab116ce75d" />

  而且在申请内存的时候也有点麻烦，需要遍历链表查找合适的内存块，会比较耗时。  

  所以会有多个空闲链表的实现，也就是根据内存分块大小组成不同的链表，比如分为大分块链表和小分块链表，  
  这样根据申请的内存分块大小遍历不同的链表，加快申请的效率。  

  <img width="723" height="204" alt="image" src="https://github.com/user-attachments/assets/759552f0-9e13-4d8a-ba16-b5314a58402c" />

  当然还可以分更多个链表。  
  
  还有标记，标记的话一般我们会觉得应该是标记在对象身上，比如标记位放在对象头中，但是这对写时复制不兼容。  
  等于每一次 GC 都需要修改对象，假设是 fork 出来的，其实是共享一块内存，那修改必然导致复制。  
  
  所以有一种位图标记法，其实就是将堆的内存某个块用一个位来标记。就像我们的内存是一页一页的，堆中的内存可以分成一块一块，而对象就是在一块，或者多块内存上。  
  根据对象所在的地址和堆的起始地址就可以算出对象是在第几块上，然后用一个位图中的第几位在置为 1 ，表明这块地址上的对象被标记了。  

  <img width="620" height="298" alt="image" src="https://github.com/user-attachments/assets/33a9c9da-a0fd-4dd6-8e83-1ec27e935a62" />

  而且用位图表格法不仅可以利用写时复制，清除也更加高效，如果标记在对象头上，那么需要遍历整个堆来扫描对象，现在有了位图，可以快速遍历清除对象。  

  但是不论是标记对象头还是利用位图，标记-清除的碎片问题还是处理不了。  

  因此就引出了标记-复制和标记-整理。  

# 标记-复制详细分析
  首先这个算法会把堆分为两块，一块是 From、一块是 To。  

  对象只会在 From 上生成，发生 GC 之后会找到所有存活对象，然后将其复制到 To 区，之后整体回收 From 区。  

  再将 To 区和 From 区身份对调，即 To 变成 From ， From 变成 To，我再用图来解释一波。  

  <img width="1307" height="733" alt="image" src="https://github.com/user-attachments/assets/4dc3c0df-711c-462f-b696-b57ff361b001" />

  可以看到内存的分配是紧凑的，不会有内存碎片的产生。  

  不需要空闲链表的存在，直接移动指针分配内存，效率很高。  

  对 CPU缓存亲和性高，因为从根开始遍历一个节点，是深度优先遍历，把关联的对象都找到，然后内存分配在相近的地方。  

  这样根据局部性原理，一个对象被加载了那它所引用的对象也同时被加载，因此访问缓存直接命中。  

  当然它也是有缺点的，因为对象的分配只能在 From 区，而 From 区只有堆一半大小，因此内存的利用率是 50%。  

  其次如果存活的对象很多，那么复制的压力还是很大的，会比较慢。  

# 标记-整理详细分析
  标记-整理其实和标记-复制差不多，区别在于复制算法是分为两个区来回复制，而整理不分区，直接整理。  

  <img width="600" height="545" alt="image" src="https://github.com/user-attachments/assets/e4ad8b5a-ccf9-46af-89ad-ed9d5a79f91c" />

  算法思路还是很清晰的，将存活的对象往边界整理，也没有内存碎片，也不需要复制算法那样腾出一半的空间，所以内存利用率也高  

  缺点就是需要对堆进行多次搜索，毕竟是在一个空间内又标记，又移动的，所以整体而言花费的时间较多，而且如果堆很大的情况，那么消耗的时间将更加突出。 

# 垃圾回收算法对比
  <img width="1762" height="1286" alt="image" src="https://github.com/user-attachments/assets/56d5c86b-e06c-4c2c-bf6f-c3d65b2c771d" />
  
