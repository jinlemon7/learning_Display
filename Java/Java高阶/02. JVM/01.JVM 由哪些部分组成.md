JVM 主要由四个部分组成：
- 类加载器子系统（ClassLoader）
- 运行时数据区（Runtime Data Area）
- 执行引擎（Execution Engine）
- 本地方法接口（Native Interface，简称 JNI）。

简单来说，JVM 就像一个虚拟的“电脑”，它能让 Java 程序在不同操作系统上跑起来，而这些部分就是它的核心“硬件”。  

想象一下，你写好 Java 代码，编译成 class 文件后，怎么让它运行？  
1. 首先，类加载器负责把 class 文件从磁盘或网络拉进来，放到内存里准备好；
2. 然后，运行时数据区就是内存的“仓库”，存放代码、变量什么的；
3. 执行引擎像个翻译官，把 Java 的字节码转成机器能懂的指令去执行；
4. 如果需要调用 C++ 之类的外部代码，比如访问硬件，JNI 就来帮忙桥接

<img width="1139" height="749" alt="image" src="https://github.com/user-attachments/assets/74399470-a308-40c6-bd43-d297216def70" />

# 类加载器子系统（ClassLoader）
  类加载器子系统负责将 .class 文件加载到 JVM 中。它负责将 Java 类从文件系统或网络中加载，并将它们转化为 JVM 能理解的数据结构。  

  类加载器的主要过程包括：  
  - 加载（Loading）：找到类的字节码，并以 JVM 内部规定的格式把它存起来，同时创建一个访问入口。  
    1. 通过类名获取二进制字节流: 根据类的全限定名（如 java.lang.String），  
       去找到并拿到这个类的"原始产品"——二进制字节流（符合 Class 文件格式的二进制数据）。
    2. 转化存储结构: 把上一步拿到的"原始产品"（字节流），转换成 JVM 方法区这个"中央仓库"所能识别的内部数据结构。
    3. 生成 Class 对象: 在 Java 堆 中创建一个 java.lang.Class 对象。

  - 链接（Linking）：将类文件的数据合并到 JVM 中，分为验证（Verification）、准备（Preparation）和解析（Resolution）三个阶段。  
    - 验证（Verification）：确保你要加载的 Class 文件是个"良民"，而不是一个携带病毒或逻辑炸弹的"黑客"，从而保证 JVM 自身的安全。
      1. 文件格式验证 - "文件格式与合法性检查"：魔数是不是 0xCAFEBABE？主次版本号是否支持？常量池里的常量类型、索引值是否合法？UTF-8编码是否正确？
      2. 元数据验证 - "语义检查"： 对类的元信息进行语义分析，看是否符合 Java 语言规范。（继承和实现的正确性、final类的合法性、重写/重载的规则）
      3. 字节码验证 - "逻辑检查"： 对方法体中的代码进行逻辑校验。（类型使用/类型转换的正确性、跳转指令的合法性）
      4. 符号引用验证 - "外部依赖检查"：发生在解析阶段（将符号引用转换为直接引用时）。检查类是否能够成功访问到它所引用的外部类、方法、字段等资源。  
      验证阶段是 JVM 抵御恶意代码的第一道也是最重要的一道防线，它通过层层递进的严格检查，确保了后续操作的基础安全。

    - 准备 (Preparation)：为类变量（static 变量）分配内存并给每个static变量执行Java默认初始化（0/false/null）的阶段。  
      1. 特殊情况：常量 (static final), 若类字段的字段属性表中存在 ConstantValue 属性，变量值就会直接被初始化为 ConstantValue 属性所指定的值
      2. 当变量同时被 static 和 final 修饰，并且它的值是编译期常量时，编译器 (javac) 会为它生成 ConstantValue 属性。

    - 解析 (Resolution) - "查地址"阶段:将常量池中的符号引用（一个名字）替换为直接引用（一个具体的地址或句柄）。  
      1. 解析的时机: 只要求在执行某些特定字节码指令（如 getfield, invokevirtual, new 等）之前，必须先对它们用到的符号引用进行解析。  
         - eager resolution (急切解析)：在类加载完成后，立刻解析所有符号引用。
         - lazy resolution (懒惰解析)：等到第一次使用某个符号引用时，才去解析它。

      2. 解析的内容: 四大类: 类或接口、字段、类方法、接口方法, 先解析所有者，再在其基础上查找目标成员。  
         - 类或接口的解析 (从 CONSTANT_Class_info 解析)  
           权限检查：检查当前类 D 是否有权访问这个被解析的类 C。如果没有（例如，C 不是 public 且也不和 D 在同一个包内），则抛出 IllegalAccessError。
         - 字段解析 (从 CONSTANT_Fieldref_info 解析)
           如果找不到匹配字段，抛出 NoSuchFieldError  
           权限检查：检查当前类是否有权访问该字段（如不能访问 private 字段），否则抛出 IllegalAccessError。  
         - 方法解析 (从 CONSTANT_Methodref_info 解析)
           解析所有者 & 合法性检查：解析方法所属的类 C。如果发现 C 是一个接口，直接抛出 IncompatibleClassChangeError（因为 invokevirtual 指令不能调用接口方法）  
           如果找不到匹配方法，否则抛出 NoSuchMethodError  
           权限检查：检查访问权限，失败则抛出 IllegalAccessError。  
         - 接口方法解析 (从 CONSTANT_InterfaceMethodref_info 解析)
           解析所有者 & 合法性检查：解析方法所属的接口 C。如果发现 C 是一个类，直接抛出 IncompatibleClassChangeError。  
           找到则返回直接引用，否则抛出 NoSuchMethodError。  
           权限检查：在 JDK 9 之前，接口方法都是 public，无需检查。JDK 9 引入私有静态方法后，也需要进行权限检查。  
  - 初始化（Initialization）：执行类的静态代码块static{}和静态变量赋值。  
    1. `<clinit>`() 方法: 初始化阶段就是执行一个叫做 `<clinit>`() 方法的过程, 由 javac 编译器自动生成的。
       - `<clinit>` 代表 class initialization。
       - 它是由编译器自动收集类中的所有静态变量的赋值语句和静态代码块 (static {} 块) 中的语句合并而成的。
       - 收集的顺序就是这些语句在源文件中出现的顺序。

    2. 关键特性与规则  
       - 顺序重要性与"非法前向引用": 静态代码块中只能访问定义在它之前的静态变量。
       - 父类优先原则: JVM 会保证在子类的`<clinit>`()方法执行前，其父类的`<clinit>`()方法已经执行完毕
       - 接口的初始化: 执行一个接口的 `<clinit>()` 方法并不需要先执行其父接口的`<clinit>()`。父接口只有在真正被使用时（如其定义的变量被访问）才会被初始化。
       - 线程安全与同步（极其重要！）:
         1. JVM 会保证一个类的 `<clinit>()` 方法在多线程环境中被正确地加锁同步。
         2. 多个线程如果同时去初始化同一个类，只有一个线程会去执行`<clinit>()`方法，其他所有线程都会被阻塞等待。
         3. 直到那个活动线程执行完 `<clinit>()` 方法后，其他线程才会被唤醒，并且不会再重新执行初始化过程。

    3. 这个机制会导致一个严重的风险  
       `<clinit>()` 方法中包含一个耗时极长的操作（比如一个死循环），或者由于某些原因卡住了，  
       那么所有其他试图初始化这个类的线程都会被无限期地阻塞在那里，从而导致系统瘫痪。

    4. 初始化触发时机（"主动引用"）  
       只有当类被"主动引用"时，才会触发初始化：  
       - 遇到 new, getstatic, putstatic, invokestatic 字节码指令时。
       - 使用 java.lang.reflect 包的方法对类进行反射调用时。
       - 初始化一个类时，如果其父类还未初始化，则先触发父类的初始化
       - 虚拟机启动时，需指定一个包含 main() 方法的主类，虚拟机会先初始化这个主类。  
       初始化阶段是类加载过程中开发人员最能直接施加影响的阶段。  
