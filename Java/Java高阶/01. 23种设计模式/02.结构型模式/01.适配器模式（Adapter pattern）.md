# 概念
  通过创建一个适配器类，将一个接口转换成业务端所期望的另一个接口。  
  为了让大家更好地‌感受到适配器模式的作用，以音频⁢播放器为例，我们需要支持多种音‏频格式（MP3、VLC、MP4等）‍的播放。  
  让我们来看看使用和⁡不使用适配器模式的区别：  
  <img width="1906" height="812" alt="image" src="https://github.com/user-attachments/assets/0db15f22-459a-474b-9d3a-6b1cbb30fddc" />

# 基本结构
  1. 目标接口（Target）：业务端希望使用的接口。
  2. 适配器‌类（Adapter⁢）：实现了目标接口‏，并且通过委托的方‍式将请求转换为适配的⁡接口调用。
  3. 适配者‌类（Adaptee）⁢：已有的、需要适配‏的类。
  4. 业务端：通过目标接口与系统交互的代码。
  <img width="400" height="930" alt="image" src="https://github.com/user-attachments/assets/018c4400-2172-4e84-920a-05c0ea894e6c" />

# 代码实现
  下面就以 ‌“多格式音频播放”⁢ 为例，我们用适配‏器模式实现一个简单‍的播放器系统。  
  
  1. 目标接口
     ```java
      public interface AudioPlayer {
          void play(String audioType, String fileName);
      }
     ```
     这一步是适‌配器模式的目标接口，⁢它规定了客户端希望使‏用的标准功能（比如只‍认 play 方法）⁡，这也是适配器的“插口”。  
  2. 适配者类的接口
     ```java
      public interface AdvancedMediaPlayer {
          void playVlc(String fileName);
          void playMp4(String fileName);
      }
     ```
     这一步是被适配的接口，定义了外部不兼容的格式支持方法，比如 playVlc() 和 playMp4()，这些接口不能直接被老播放器识别，需要一个适配器做中间转换。  
  3. 适配者类
     ```java
      public class VlcPlayer implements AdvancedMediaPlayer {
          @Override
          public void playVlc(String fileName) {
              System.out.println("播放VLC格式的文件: " + fileName);
          }
      
          @Override
          public void playMp4(String fileName) {
              // 什么也不做
          }
      }
      
      public class Mp4Player implements AdvancedMediaPlayer {
          @Override
          public void playVlc(String fileName) {
              // 什么也不做
          }
      
          @Override
          public void playMp4(String fileName) {
              System.out.println("播放MP4格式的文件: " + fileName);
          }
      }
     ```
     这一步是具体的实现类，真正负责播放 .mp4 和 .vlc 文件，但它们的接口和我们播放器的 AudioPlayer 不兼容，不能直接使用。  
  4. 适配器类
     ```java
      public class MediaAdapter implements AudioPlayer {
          private AdvancedMediaPlayer advancedMediaPlayer;
      
          public MediaAdapter(String audioType) {
              if (audioType.equalsIgnoreCase("vlc")) {
                  advancedMediaPlayer = new VlcPlayer();
              } else if (audioType.equalsIgnoreCase("mp4")) {
                  advancedMediaPlayer = new Mp4Player();
              }
          }
      
          @Override
          public void play(String audioType, String fileName) {
              if (audioType.equalsIgnoreCase("vlc")) {
                  advancedMediaPlayer.playVlc(fileName);
              } else if (audioType.equalsIgnoreCase("mp4")) {
                  advancedMediaPlayer.playMp4(fileName);
              }
          }
      }
     ```
     这一步是适配器的核心，通过 MediaAdapter 将外部的高级播放器“包一层”，让它看起来像是 AudioPlayer 的实现，这样旧系统就可以无感接入新格式。  
  5. 实现默认播放器：支持 MP3，其他格式交给适配器
     ```java
      public class DefaultAudioPlayer implements AudioPlayer {
          private MediaAdapter mediaAdapter;
      
          @Override
          public void play(String audioType, String fileName) {
              if (audioType.equalsIgnoreCase("mp3")) {
                  System.out.println("播放MP3格式的文件: " + fileName);
              } else if (audioType.equalsIgnoreCase("mp4") || audioType.equalsIgnoreCase("vlc")) {
                  mediaAdapter = new MediaAdapter(audioType);
                  mediaAdapter.play(audioType, fileName);
              } else {
                  System.out.println("不支持的格式: " + audioType);
              }
          }
      }
     ```
     这一步是客户端真正使用的播放器类，对外提供统一的 play() 方法，内部智能判断是否需要适配器介入，扩展性和兼容性都非常好  
  6. 业务端
     ```java
      public class Client {
          public static void main(String[] args) {
              AudioPlayer player = new DefaultAudioPlayer();
              player.play("mp3", "歌曲.mp3");
              player.play("mp4", "电影.mp4");
              player.play("vlc", "直播秀.vlc");
              player.play("avi", "老的媒体格式.avi");
          }
      }
     ```
     输出结果：  
     ```java
      复制代码
      播放MP3格式的文件: 歌曲.mp3
      播放MP4格式的文件: 电影.mp4
      播放VLC格式的文件: 直播秀.vlc
      不支持的格式: avi
     ```
     客户端调用展示了适配器的使用场景，原本只支持 .mp3 的播放器，现在通过 MediaAdapter 轻松扩展到支持 .mp4 和 .vlc，  
     而不需要修改原来的接口和逻辑，这就是适配器模式的优势。   
    
# 优缺点
  优点: 
  - 解耦系统
  - 复用现有类
  - 增强可扩展性
  - 简化接口

  缺点：
  - 增加系统复杂性
  - 性能开销
  - 潜在的过度使用
  - 不适合所有场景：适配器模式主要适用于接口不兼容的情况，对于接口设计不合理的情况，可能并不适用。
    过度依赖适配器可能掩盖了系统设计的问题，造成长期维护上的困难。

# 应用场景
  - 旧系统与新系统对接
  - 不同数据库引擎访问
  - 不同格式的文件读取与处理
  - 音频播放器支持多种格式播放

# 开源框架中的应用
  1. Spring MVC 中的HandlerAdapter  
     在 Spring MVC 中，HandlerAdapter 是一个非常典型的适配器模式的实现。我们知道，Spring MVC 中的处理器（Controller）有很多种形式，  
     比如注解方式的 @RequestMapping，实现接口的 HttpRequestHandler。这些处理器的定义方式不同，调用方法也不一样，  
     但 DispatcherServlet 是整个请求的统一入口。它不可能针对每种 Handler 都写死调用逻辑。这个时候，适配器模式就派上了用场。  

     我们来看下 HandlerAdapter的接口定义：  
     ```java
      public interface HandlerAdapter {
          // 判断当前适配器是否支持给定的 handler 类型（即 Controller 对象）
          boolean supports(Object handler);
      
          // 执行 handler 的逻辑处理，并返回 ModelAndView（用于渲染视图）
          @Nullable
          ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;
      
      }
     ```

     Spring 提供了多个不同的适配器实现，比如：  
     - RequestMappingHandlerAdapter：用来支持注解方式的 @RequestMapping 方法；
     - HttpRequestHandlerAdapter：用来支持实现了 HttpRequestHandler 接口的类；
     - SimpleControllerHandlerAdapter：用来支持实现了 Controller 接口的处理器。

     来看下 HttpRequestHandlerAdapter 的结构：  
     ```java
      public class HttpRequestHandlerAdapter implements HandlerAdapter {
      
         	@Override
      	public boolean supports(Object handler) {
      		return (handler instanceof HttpRequestHandler);
      	}
      
      	@Override
      	@Nullable
      	public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)
      			throws Exception {
      
      		((HttpRequestHandler) handler).handleRequest(request, response);
      		return null;
      	}
          // 省略其他代码...
      }
     ```
     我们可以看‌到，核心逻辑在于判⁢断是否支持某种类型‏的 Handler‍，然后进行适配调用⁡。  

     而 Dis‌patcherSe⁢rvlet 的处理‏流程中，也有这样一‍段逻辑：  
     ```java
      // 从已注册的 HandlerAdapter 列表中，选择一个支持指定 handler 的适配器。
      protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException {
          if (this.handlerAdapters != null) {
              for (HandlerAdapter adapter : this.handlerAdapters) {
                  if (adapter.supports(handler)) {
                      return adapter;
                  }
              }
          }
          throw new ServletException("No adapter for handler [" + handler +
                                     "]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler");
      }
     ```
     这就是 Spring 中典型的接口适配器模式：通过不同的 HandlerAdapter 实现类，把各种处理器适配成统一的执行模型。  
     为了更清晰‌地理解这个结构，我⁢们用一张类图表示出‏ Spring M‍VC 中适配器模式⁡的关键类之间的关系  
     <img width="3128" height="1496" alt="image" src="https://github.com/user-attachments/assets/6aabdd07-358c-4fea-a474-faaf6032519c" />

     在这个类图中，我们可以看到 DispatcherServlet 只依赖接口 HandlerAdapter，而不直接依赖任何具体实现类。  
     新增新的处理器类型时，只需要实现一个新的 HandlerAdapter，完全符合开闭原则。  

  2. JDK中的 java.util.Arrays#asList()  
     我们在用 JDK 提供的一些工具类时，其实已经接触过适配器模式了。最常见的一个例子是 java.util.Arrays#asList() 这个方法。   
     这个方法的作用，是把一个普通的数组“包装”成一个 List 接口的实现。它的底层实现就是一个典型的适配器   

     ```java
      public static <T> List<T> asList(T... a) {
          return new ArrayList<>(a);
      }
      
      // 这是 Arrays 的静态内部类，不是 java.util.ArrayList
      private static class ArrayList<E> extends AbstractList<E>
      implements RandomAccess, java.io.Serializable
      {
          private static final long serialVersionUID = -2764017481108945198L;
          private final E[] a;
      
          ArrayList(E[] array) {
              a = Objects.requireNonNull(array);
          }
          // ...省略其他代码
      }
     ```
     这个 ArrayList 并没有重新设计数据结构，而是持有了原始数组的引用，底层依旧是数组。但是通过继承 AbstractList，  
     它变成了 List 类型的实例，对外暴露的就是一个标准 List 接口。这就是一种对象适配器模式，通过组合已有对象（数组），  
     将它包装成期望的接口（List）。  

     另一个常用的例子是 InputStreamReader，这个类的作用是把一个字节流（InputStream）适配成一个字符流（Reader）：  
     ```java
      public class InputStreamReader extends Reader {
          private final StreamDecoder sd;
      
            // 构造方法
            public InputStreamReader(InputStream in) {
              super(in);
              try {
                  sd = StreamDecoder.forInputStreamReader(in, this, (String)null); // ## check lock object
              } catch (UnsupportedEncodingException e) {
                  // The default encoding should always be available
                  throw new Error(e);
              }
          }
      
          // 调用 StreamDecoder 的 read()，将字节转字符
          public int read(char cbuf[], int offset, int length) throws IOException {
              return sd.read(cbuf, offset, length);
          }
      }
     ```
