# 概念
  用统一的方式来处理单个对象和一组对象。  
  为了让大家更‌好地感受到组合模式的作用⁢，以文件系统管理为例，我‏们需要管理文件和文件夹的层‍级结构。让我们来看看使⁡用和不使用组合模式的区别：  
  
  <img width="1872" height="932" alt="image" src="https://github.com/user-attachments/assets/b254e65a-2394-4823-9a75-2ab2c484ab45" />

# 基本结构
  1. 抽象组件‌（Component）：⁢定义了所有组件（包括基本‏组件和容器组件）必须遵循‍的接口，比如公共的方法，⁡比如添加、删除、获取子组件等。 ——组件的接口
  2. 叶子节点‌（Leaf）：代表最基⁢本的、不能再分的对象，‏比如普通员工。叶子节点‍实现了抽象组件定义的接⁡口，但不会再包含子节点。         ——具体叶子节点类
  3. 容器节点（C‌omposite）：代表可以包⁢含子组件的对象，比如部门经理。‏容器节点同样实现了抽象组件接口‍，同时内部维护着子节点集合，并⁡实现对子节点的添加、删除等操作。            ——容器节点类

  <img width="848" height="518" alt="image" src="https://github.com/user-attachments/assets/2cbf8eb7-6e92-4f53-b020-d3910242b55d" />

# 代码实现
  下面就以 ‌“文件系统管理” ⁢为例，我们用组合模‏式实现一个简单的文件结‍构系统。   
  1. 抽象组件接口
     ```java
      public interface FileComponent {
          void display(String indent);
      }
     ```
     这一步定义了组合模式的“抽象组件”，统一所有文件系统节点的操作接口，比如 display() 方法用于展示目录结构。  
  2. 具体叶子节点类
     ```java
      public class FileLeaf implements FileComponent {
          private String name;
      
          public FileLeaf(String name) {
              this.name = name;
          }
      
          public void display(String indent) {
              System.out.println(indent + "- 文件：" + name);
          }
      }
     ```
     FileLeaf 是叶子节点类，代表文件，不包含其他子节点，只负责输出自己的名字，是组合结构中最底层的节点。  
  3. 容器节点类
     ```java
      import java.util.ArrayList;
      import java.util.List;
      
      public class FolderComposite implements FileComponent {
          private String name;
          private List<FileComponent> children = new ArrayList<>();
      
          public FolderComposite(String name) {
              this.name = name;
          }
      
          public void add(FileComponent component) {
              children.add(component);
          }
      
          public void remove(FileComponent component) {
              children.remove(component);
          }
      
          public void display(String indent) {
              System.out.println(indent + "+ 文件夹：" + name);
              for (FileComponent child : children) {
                  child.display(indent + "  ");
              }
          }
      }
     ```
     FolderComposite 是组合节点，代表文件夹，可以包含任意数量的子文件或子文件夹，实现递归遍历并展示结构，是组合模式的核心。  
  4. 测试使用
     ```java
      public class FileSystemClient {
          public static void main(String[] args) {
              // 创建文件
              FileLeaf file1 = new FileLeaf("readme.txt");
              FileLeaf file2 = new FileLeaf("logo.png");
              FileLeaf file3 = new FileLeaf("data.csv");
      
              // 创建文件夹
              FolderComposite root = new FolderComposite("根目录");
              FolderComposite docs = new FolderComposite("文档");
              FolderComposite images = new FolderComposite("图片");
      
              // 构建层级关系
              docs.add(file1);
              images.add(file2);
      
              root.add(docs);
              root.add(images);
              root.add(file3);
      
              // 显示结构
              root.display("");
          }
      }
     ```
     输出结果：  
     ```java
      + 文件夹：根目录
        + 文件夹：文档
          - 文件：readme.txt
        + 文件夹：图片
          - 文件：logo.png
        - 文件：data.csv\
     ```
     客户端不需要关心节点到底是文件还是文件夹，只调用 display() 方法即可，组合模式让“整体”和“部分”拥有一致的操作方式，实现了对复杂结构的透明访问。  
     
# 优缺点
  优点:   
  - 树形结构的表示
  - 统一性
  - 扩展性：通过递归方式，容易为树形结构添加新的操作或新类型的对象，无需修改已有代码即可实现新功能。
  - 灵活性

  缺点：  
  - 过度泛化：组合模式可能会导致设计过于泛化，叶子节点和复合节点使用统一接口，可能会引起不必要的复杂性。
    如果不加区分，复合节点和叶子节点的功能可能会被过度简化，导致某些操作不符合实际需求。
  - 不适合复杂对象
  - 难以控制部分操作：当组合对象非常复杂时，处理某些特定的部分操作可能会变得困难，因为无法简单区分叶子节点和复合节点的行为。

# 应用场景
  - 文件系统管理
  - 企业组织结构
  - 菜单管理系统

# 开源框架中的应用
  1. Sprin‌g Web MVC  
     Sprin‌g Web MVC⁢ 中就大量使用了组‏合模式，其中几个非‍常典型的类包括：  
     - HandlerMethodArgumentResolverComposite
     - HandlerMethodReturnValueHandlerComposite
     - HandlerExceptionResolverComposite
     - ViewResolverComposite

     我们以 HandlerMethodArgumentResolverComposite 为例来分析，这个类是 Spring MVC 在方法参数解析时用的组合容器。  

     先看下这个类的部分源码结构：  
     ```java
      public class HandlerMethodArgumentResolverComposite implements HandlerMethodArgumentResolver {
          // 用于存储注册的参数解析器列表
          private final List<HandlerMethodArgumentResolver> argumentResolvers = new ArrayList<>();
      
          // 用于缓存已经解析过的参数对应的解析器，提高性能（此处未显示定义，实际源码中为 Map 缓存）
          private final Map<MethodParameter, HandlerMethodArgumentResolver> argumentResolverCache =
          new ConcurrentHashMap<>(256);
      
          //添加一个参数解析器到组合中
          public HandlerMethodArgumentResolverComposite addResolver(HandlerMethodArgumentResolver resolver) {
              this.argumentResolvers.add(resolver);
              return this;
          }
      
          // 判断是否支持解析某个方法参数
          @Override
          public boolean supportsParameter(MethodParameter parameter) {
              return getArgumentResolver(parameter) != null;
          }
      
          // 根据参数查找支持该参数的解析器，并使用缓存提升性能
          @Nullable
          private HandlerMethodArgumentResolver getArgumentResolver(MethodParameter parameter) {
              HandlerMethodArgumentResolver result = this.argumentResolverCache.get(parameter);
              if (result == null) {
                  for (HandlerMethodArgumentResolver resolver : this.argumentResolvers) {
                      if (resolver.supportsParameter(parameter)) {
                          result = resolver;
                          this.argumentResolverCache.put(parameter, result);
                          break;
                      }
                  }
              }
              return result;
          }
          // 调用支持该参数的解析器进行参数解析
          public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,
                                        NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {
      
              HandlerMethodArgumentResolver resolver = getArgumentResolver(parameter);
              if (resolver == null) {
                  throw new IllegalArgumentException("Unsupported parameter type [" +
                                                     parameter.getParameterType().getName() + "]. supportsParameter should be called first.");
              }
              return resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);
          }
      }
     ```
     可以看到，它本身实现了 HandlerMethodArgumentResolver 接口，但它内部是组合了一堆 HandlerMethodArgumentResolver 实例。  

     也就是说，‌从客户端的角度来看⁢，无论是使用一个解‏析器，还是一组解析‍器，使用方式完全一⁡样。这就是组合模式的精髓。  

     其他类似的组合器还有：  
     1. HandlerMethodReturnValueHandlerComposite  
     2. HandlerExceptionResolverComposite  
     3. ViewResolverComposite  
     这些类的结‌构和思路都很接近，⁢都是：自己实现接口‏，内部持有多个实现‍实例，统一代理⁡转发调用。  

  2. JDK 中的 java.awt.Component  
     其在 JDK 中，java.awt.Component 体系就是组合模式的体现。  

     在 AWT 的 UI 组件系统中，Component 是所有组件的父类，而 Container 是一种特殊的 Component，它可以嵌套别的 Component  
     ```java
      public abstract class Component implements ImageObserver, MenuContainer,
                                                 Serializable{
          // 所有 UI 组件的基类
      }
      
      public class Button extends Component implements Accessible {
          // 叶子节点，没有子组件
      }
      
      public class Panel extends Container implements Accessible {
          // 树枝节点，可以容纳别的 Component
      }
     ```
     而 Container 是可以添加子组件的：  
     ```java
      public class Container extends Component {
          private List<Component> componentList = new ArrayList<>();
      
           public Component add(Component comp) {
              addImpl(comp, null, -1);
              return comp;
          }
      }
     ```
     这就形成了一个组合结构，Component 是统一接口，Button 是叶子节点，Panel 是组合节点，可以包含多个 Component。可以看下类图：  
     <img width="964" height="1256" alt="image" src="https://github.com/user-attachments/assets/15f56b0f-3a28-445f-85b5-81fac7f0f0da" />
