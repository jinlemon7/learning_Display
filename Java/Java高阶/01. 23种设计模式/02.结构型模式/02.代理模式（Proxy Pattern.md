# 概念
  给某个对象提供一个代理对象，并由代理对象来控制对这个对象的访问。  
  为了让大家更好‌地感受到代理模式的作用，以图⁢片加载为例，我们需要在加载大‏图片时显示加载进度，并在图片‍加载完成后显示。  
  让我们来看看⁡使用和不使用代理模式的区别：  
  
  <img width="1906" height="1178" alt="image" src="https://github.com/user-attachments/assets/0b577336-73f4-4660-942e-91f90e0de77b" />

# 基本结构
  1. 抽象主‌题接口（Subje⁢ct）：定义了真实‏对象和代理对象都需‍要实现的方法。
  2. 真实主‌题类（RealSub⁢ject）：也就是‏目标对象，真正去执‍行核心业务逻辑的类⁡。
  3. 代理类（P‌roxy）：实现和目标对象⁢相同的接口，在内部维护一个‏真实对象的引用。代理类会控‍制对真实对象的访问，可能会⁡在调用前后加点特殊的处理逻辑。

  <img width="654" height="674" alt="image" src="https://github.com/user-attachments/assets/d67cff52-7706-4898-bc8a-3c0f2f804051" />

# 代码实现
  下面就以 ‌“网络图片懒加载”⁢ 为例，我们用代理‏模式实现一个简单的‍图片加载系统。  
  
  1. 抽象主‌题接口
     ```java
      public interface Image {
          void display();
      }
     ```
     这一步是代理‌模式中的统一接口，真实⁢图片和代理图片都实现这‏个接口，使得客户端可以‍通过接口编程，而不关心⁡底层是代理还是实际资源。  
  2. 真实主‌题类
     ```java
      public class RealImage implements Image {
          private String filename;
      
          public RealImage(String filename) {
              this.filename = filename;
              loadFromDisk();
          }
      
          private void loadFromDisk() {
              System.out.println("从磁盘加载图片：" + filename);
          }
      
          @Override
          public void display() {
              System.out.println("显示图片：" + filename);
          }
      }
     ```
     这一步是被‌代理的实际对象，负⁢责加载和显示图片，‏但加载过程比较重，‍所以我们希望尽量延⁡后执行它的创建逻辑。  
  3. 代理类
     ```java
      public class ProxyImage implements Image {
          private RealImage realImage;
          private String filename;
      
          public ProxyImage(String filename) {
              this.filename = filename;
          }
      
          @Override
          public void display() {
              if (realImage == null) {
                  realImage = new RealImage(filename);
              }
              realImage.display();
          }
      }
     ```
     这一步就是“代理类”的角色，它控制真实图片的访问逻辑：只有第一次调用 display() 时才真正创建 RealImage 并加载资源，  
     起到了“懒加载”的作用，节省资源。  
  4. 测试使用
     ```java
      public class Client {
          public static void main(String[] args) {
              Image image = new ProxyImage("图片.png");
      
              System.out.println("== 第一次显示图片 ==");
              image.display(); // 会触发加载和显示
      
              System.out.println("\n== 第二次显示图片 ==");
              image.display(); // 直接显示，不再加载
          }
      }
     ```
     输出结果：
     ```java
      == 第一次显示图片 ==
      从磁盘加载图片：图片.png
      显示图片：图片.png
      
      == 第二次显示图片 ==
      显示图片：图片.png
     ```
     客户端使用 Image 接口操作图片，底层是否加载了真实资源是由代理控制的。第一次显示会加载图片，第二次则直接复用。  
     
# 优缺点
  优点:
  - 控制对象访问
  - 增强目标对象功能
  - 隔离客户端与目标对象
  - 支持多种代理形式

  缺点:  
  - 增加系统复杂度
  - 可能引入性能开销
  - 不适用于频繁变更的接口

# 应用场景
  - 权限代理
  - 日志记录代理
  - 网络图片懒加载器

# 开源框架中的应用
  1. Spring 的 ‌AOP（面向切面编程）  
     Spring 在 ‌AOP（面向切面编程）中大量使用了代理模⁢式。默认情况下，如果目标类实现了‏接口，会使用 JDK 的动态代理。  
     如‍果目标类没有实现接口，就会使用 CG⁡LIB 来生成子类进行代理。  

     如果我们给某个 Bean 加了一个切面（比如加了 @Around 注解的方法），Spring 会在容器启动阶段，  
     用代理对象替换原始 Bean，所有方法调用都会被这个代理对象拦截，然后交给切面逻辑处理。  

     我们来看 Spring AOP 中核心的代理工厂类 ProxyFactory 和 AdvisedSupport：  
     ```java
      public class ProxyFactory extends ProxyCreatorSupport {
          public Object getProxy() {
              return createAopProxy().getProxy();
          }
      }
     ```
     ProxyFactory 会根据配置决定是否使用 JDK 代理或 CGLIB 代理：  
     ```java
      // 根据 AOP 配置生成合适的 AopProxy 实现（JDK 动态代理或 CGLIB 代理）。
      public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {
      		if (!NativeDetector.inNativeImage() &&
      				(config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config))) {
      			Class<?> targetClass = config.getTargetClass();
      			if (targetClass == null) {
      				throw new AopConfigException("TargetSource cannot determine target class: " +
      						"Either an interface or a target is required for proxy creation.");
      			}
      			if (targetClass.isInterface() || Proxy.isProxyClass(targetClass) || ClassUtils.isLambdaClass(targetClass)) {
      				return new JdkDynamicAopProxy(config);
      			}
      			return new ObjenesisCglibAopProxy(config);
      		}
      		else {
      			return new JdkDynamicAopProxy(config);
      		}
      	}
     ```
     我们来看下 Spring 中最关键的一个代理类 JdkDynamicAopProxy：  
     ```java
      class JdkDynamicAopProxy implements InvocationHandler {
       	private final AdvisedSupport advised;
      
          @Override
      	@Nullable
      	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {      // 省略部分代码
              // 省略代码...
          }
      }
     ```
     这个类其实就是 Spring 自己实现的 InvocationHandler，内部维护了一个叫 AdvisedSupport 的配置对象，里面包含了目标对象、切面列表、拦截器链等。  
     我们来看下类图结构：     
     <img width="1756" height="1312" alt="image" src="https://github.com/user-attachments/assets/dd6a1e8a-23d8-401f-a013-24413d57ee59" />

     这张类图中我们可以看到：  
     - AopProxy 是代理的统一接口；  
     - JdkDynamicAopProxy 和 CglibAopProxy 是两个具体的代理实现类；  
     - ProxyFactory 是创建代理对象的工厂，它依赖 AdvisedSupport 来传入配置信息。  
    
  2. JDK 自带的 java.lang.reflect.Proxy 类  
     我们知道，代理模式的主要作用是控制访问，也就是在不修改原始代码的前提下，增加一些额外逻辑。  
     JDK 自带的 java.lang.reflect.Proxy 类就是一个典型的代理模式实现，它可以在运行时，帮我们创建一个实现了某些接口的“代理对象”，  
     所有调用都会被转发到 InvocationHandler。这个设计对于很多基于接口的框架来说非常重要，   
     比如 JDK 自带的动态代理就被广泛应用在 AOP、RPC、事务管理等场景中。  

     我们可以从 Proxy 类的源码看出它的核心逻辑：    
     ```java
      public class Proxy implements java.io.Serializable {
          // 代理类的处理器
          protected InvocationHandler h;
      
          protected Proxy(InvocationHandler h) {
              this.h = h;
          }
      
          public static Object newProxyInstance(ClassLoader loader,
                                                Class<?>[] interfaces,
                                                InvocationHandler h) {
              // 动态生成代理类并返回实例
              ...
          }
      }
     ```
     而我们自定义的代理逻辑，都会通过 InvocationHandler 接口来处理：  
     ```java
      // 代理对象会将方法调用委托给该方法，执行自定义的逻辑
      public Object invoke(Object proxy, Method method, Object[] args)
              throws Throwable;
     ```
     这个接口就是代理的核心，每次代理对象调用方法，都会触发 invoke() 方法，我们可以在里面统一添加增强逻辑，比如日志、权限检查等等。  
