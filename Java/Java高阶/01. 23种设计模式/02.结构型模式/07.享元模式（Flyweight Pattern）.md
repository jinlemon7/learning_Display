# 概念
  通过共享对象，减少系统中对象的数量，从而节省内存，提高性能。  
  为了让大家更‌好地感受到享元模式的作用⁢，以字符缓存系统为例，我‏们需要高效地渲染大量重复‍的字符。让我们来看看使用⁡和不使用享元模式的区别：  

  <img width="1872" height="1208" alt="image" src="https://github.com/user-attachments/assets/ed5ee34e-94c5-45de-90a7-3132bb317d39" />

# 基本结构 
  1. 抽象享‌元（Flyweig⁢ht）：定义享元对‏象的接口，规定外部‍状态传入的标准方法⁡。             ——享元接口
  2. 具体享‌元（Concret⁢eFlyweigh‏t）：实现抽象享元‍接口，内部保存可以共⁡享的状态。           ——具体享元类
  3. 享元工‌厂（Flyweigh⁢tFactory）：‏负责创建和管理享元对‍象，确保相同的享元对⁡象只被创建一次，并进行共享。   ——享元工厂类
  4. 测试使用：⁢通过享元工厂获取享‏元对象，同时传入外‍部状态进行使用。

  <img width="538" height="638" alt="image" src="https://github.com/user-attachments/assets/049c5cbb-2d3b-4976-8ec1-8a6b1a51e6ef" />

# 代码实现
  下面就以 ‌“字符缓存系统” ⁢为例，我们用享元模‏式实现一个高效的字符渲‍染机制。    
  1. 享元接口
     ```java
      public interface Glyph {
          void render(int x, int y, String color);
      }
     ```
     这一步的目的是定义所有可共享字符的统一操作接口，比如字符的 render() 渲染方法，让我们可以统一管理各种字符。  
  2. 具体享元类
     ```java
      public class CharacterGlyph implements Glyph {
          private final char symbol; // 内部状态，不随使用变化
          private final String font; // 内部状态：字体
      
          public CharacterGlyph(char symbol, String font) {
              this.symbol = symbol;
              this.font = font;
          }
      
          @Override
          public void render(int x, int y, String color) {
              System.out.println("渲染字符 '" + symbol + "'，字体：" + font + "，颜色：" + color + "，位置：(" + x + "," + y + ")");
          }
      }
     ```
     这一步是享‌元模式的核心——把所⁢有字符都“标准化”，‏只保留不变的信息，比‍如字符本身和字体，这⁡些可以被多个对象共享。  
  3. 享元工厂类
     ```java
      import java.util.HashMap;
      import java.util.Map;
      
      public class GlyphFactory {
          private Map<String, Glyph> glyphPool = new HashMap<>();
      
          public Glyph getGlyph(char symbol, String font) {
              String key = symbol + ":" + font;
              if (!glyphPool.containsKey(key)) {
                  glyphPool.put(key, new CharacterGlyph(symbol, font));
              }
              return glyphPool.get(key);
          }
      }
     ```
     这一步提供‌了享元对象的集中管⁢理。无论创建多少次‏相同的字符，只要字‍体一样，就只会创建一个⁡共享实例。  
  4. 包含外部状态的字符视图类
     ```java
      public class CharacterView {
          private final Glyph glyph;
          private final int x;
          private final int y;
          private final String color;
      
          public CharacterView(Glyph glyph, int x, int y, String color) {
              this.glyph = glyph;
              this.x = x;
              this.y = y;
              this.color = color;
          }
      
          public void draw() {
              glyph.render(x, y, color);
          }
      }
     ```
     这一步把“‌变化的外部状态”提取⁢出来，像位置、颜色都‏不参与共享，这样不同‍位置的字符可以使用同⁡一个 Glyph 对象。  
  5. 测试使用
     ```java
      public class Client {
          public static void main(String[] args) {
              GlyphFactory factory = new GlyphFactory();
      
              CharacterView[] page = new CharacterView[] {
                  new CharacterView(factory.getGlyph('a', "Arial"), 10, 10, "black"),
                  new CharacterView(factory.getGlyph('b', "Arial"), 20, 10, "black"),
                  new CharacterView(factory.getGlyph('a', "Arial"), 30, 10, "red"),
                  new CharacterView(factory.getGlyph('a', "Arial"), 40, 10, "blue"),
                  new CharacterView(factory.getGlyph('b', "Arial"), 50, 10, "black"),
              };
      
              for (CharacterView cv : page) {
                  cv.draw();
              }
          }
      }
     ```
     输出结果：‌  
     ```java
      渲染字符 'a'，字体：Arial，颜色：black，位置：(10,10)
      渲染字符 'b'，字体：Arial，颜色：black，位置：(20,10)
      渲染字符 'a'，字体：Arial，颜色：red，位置：(30,10)
      渲染字符 'a'，字体：Arial，颜色：blue，位置：(40,10)
      渲染字符 'b'，字体：Arial，颜色：black，位置：(50,10)
     ```
     通过这种方式，多个相同字符共享了同一个 CharacterGlyph 实例，只在需要时添加变化的位置信息，大大减少内存开销。  

# 优缺点
  优点:  
  - 节省内存
  - 提高性能
  - 支持大规模对象管理

  缺点：  
  - 增加了复杂性：享元模式需要管理享元池（对象池）和分离内外部状态，设计和实现上可能比直接创建对象要复杂。
    需要仔细处理对象共享和状态管理，避免引入不必要的复杂性。
  - 对象状态管理困难：享元模式的共享对象往往是不可变的。若对象的状态是可变的，需要将内部状态和外部状态分开管理，
    这可能会增加代码的复杂度和维护难度。
  - 可能导致资源竞争:如果共享的对象没有正确同步，可能会导致资源竞争或线程安全问题。

# 应用场景
  - 文本编辑器中的字符缓存
  - 网页中的图标缓存

# 开源框架中的应用
  1. JDK 中的 Integer.valueOf()  
     这个方法在返回 Integer 对象的时候，并不会每次都 new 一个，而是对 -128 到 127 范围内的整数做了缓存，直接复用已经存在的对象。  
     源码在 Integer 类中有非常清晰的体现：  
     ```java
      public final class Integer extends Number implements Comparable<Integer> {
          /**
           * IntegerCache 是 Integer 类的静态内部类，用于缓存一部分 Integer 对象。
           * Java 为了节省内存并提高性能，会缓存一部分频繁使用的 int 值（默认是 -128 到 127）。
           */
          private static class IntegerCache {
              // 缓存下界，固定为 -128
              static final int low = -128;
              // 缓存上界，默认是 127，可以通过 JVM 参数调整
              static final int high;
              // 用于存放缓存的 Integer 实例数组
              static final Integer cache[];
      
              static {
                  // high value may be configured by property
                  int h = 127;
                  String integerCacheHighPropValue =
                  sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");
                  if (integerCacheHighPropValue != null) {
                      try {
                          int i = parseInt(integerCacheHighPropValue);
                          i = Math.max(i, 127);
                          // Maximum array size is Integer.MAX_VALUE
                          h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
                      } catch( NumberFormatException nfe) {
                          // If the property cannot be parsed into an int, ignore it.
                      }
                  }
                  high = h;
      
                  cache = new Integer[(high - low) + 1];
                  int j = low;
                  for(int k = 0; k < cache.length; k++)
                  cache[k] = new Integer(j++);
      
                  // range [-128, 127] must be interned (JLS7 5.1.7)
                  assert IntegerCache.high >= 127;
              }
      
              private IntegerCache() {}
          }
          /**
           * valueOf 方法是 Integer 类的工厂方法，用于获取一个 Integer 对象。
           * 对于常用的小整数（-128 到 127），会直接从缓存中取，避免重复创建对象。
           */
          public static Integer valueOf(int i) {
              // 如果 i 在缓存范围内，直接返回缓存对象
              if (i >= IntegerCache.low && i <= IntegerCache.high)
                  return IntegerCache.cache[i + (-IntegerCache.low)];
              // 超出缓存范围，创建新的 Integer 对象
              return new Integer(i);
          }
      }
     ```
     可以看到，Integer.valueOf() 本质就是一个享元工厂，它根据输入决定是否从缓存返回，最大程度地减少对象创建的成本。  

     我们用类图来简单表示下结构：  
     <img width="996" height="936" alt="image" src="https://github.com/user-attachments/assets/6643bac8-c931-4c09-ac54-f837f1bf5bfa" />
