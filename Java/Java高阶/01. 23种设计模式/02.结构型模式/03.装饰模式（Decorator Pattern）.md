# 概念
  动态地给对象添加额外的功能，而不会影响到其他对象。  
  为了让大家更好‌地感受到装饰模式的作用，以⁢文本渲染为例，我们需要为文‏本添加不同的样式（加粗、颜‍色等）。让我们来看看使用和⁡不使用装饰模式的区别：  
  
  <img width="1900" height="1394" alt="image" src="https://github.com/user-attachments/assets/aa2b5aa0-4fc5-48eb-961a-87e8b31e8e89" />

# 基本结构
  1. 组件接‌口（Compone⁢nt）：定义对象的‏接口，所有的具体组‍件和装饰器都实现⁡这个接口。       ——组件的接口
  2. 具体组‌件（Concret⁢eComponen‏t）：就是原始对象‍，定义了核心的⁡功能实现。               ——具体组件类
  3. 抽象装‌饰器（Decora⁢tor）：实现组件‏接口，内部持有一个‍组件对象（也就是被装饰⁡的对象）。  ——装饰器的抽象类
  4. 具体装‌饰器（Concre⁢teDecorat‏or）：继承抽象装‍饰器，负责给组件对⁡象添加新的功能。      ——具体装饰器类

  <img width="994" height="680" alt="image" src="https://github.com/user-attachments/assets/da7d3548-86ff-4dba-b374-2db5b9e75c8b" />

# 代码实现
  下面就以 ‌“文本渲染增强” ⁢为例，我们用装饰模‏式实现一个支持动态‍添加样式的文本⁡组件系统。  
  
  1. 组件的接口
     ```java
      public interface TextComponent {
          String render();
      }
     ```
     这一步定义‌了所有文本相关组件⁢的共同接口，保证后‏续的具体文本类和装‍饰器都遵循统一的⁡调用规范。  
  2. 具体组件类
     ```java
      public class PlainText implements TextComponent {
          private String content;
      
          public PlainText(String content) {
              this.content = content;
          }
      
          @Override
          public String render() {
              return content;
          }
      }
     ```
     这一步提供‌了一个最基础的文本⁢实现，它不包含任何‏格式，用来作为装饰链‍的起点。  
  3. 装饰器的抽象类
     ```java
      public abstract class TextDecorator implements TextComponent {
          protected TextComponent component;
      
          public TextDecorator(TextComponent component) {
              this.component = component;
          }
      }
     ```
     这是装饰器‌的通用抽象父类，它持⁢有一个 TextCo‏mponent 实例‍，允许我们在其基础上⁡扩展功能，同时保持统一接口。  
  4. 具体装饰器类
     ```java
      public class BoldDecorator extends TextDecorator {
          public BoldDecorator(TextComponent component) {
              super(component);
          }
      
          @Override
          public String render() {
              return "<b>" + component.render() + "</b>";
          }
      }
      
      public class ColorDecorator extends TextDecorator {
          private String color;
      
          public ColorDecorator(TextComponent component, String color) {
              super(component);
              this.color = color;
          }
      
          @Override
          public String render() {
              return "<span style='color:" + color + "'>" + component.render() + "</span>";
          }
      }
     ```
     这些是具体‌的功能增强类，用来给⁢文本添加 HTML ‏样式，比如加粗和着色‍。每个装饰器都只负责⁡一件事，职责单一，组合灵活。  
  5. 测试使用
     ```java
      public class Client {
          public static void main(String[] args) {
              TextComponent text = new PlainText("Hello, Decorator!");
      
              // 添加加粗
              text = new BoldDecorator(text);
      
              // 添加红色字体
              text = new ColorDecorator(text, "red");
      
              System.out.println("最终渲染结果：");
              System.out.println(text.render());
          }
      }
     ```
     输出结果：
     ```java
      最终渲染结果：
      <span style='color:red'><b>Hello, Decorator!</b></span>
     ```
     这端代码示例通过‌组合多个装饰器实现了“加粗+红色⁢”两个功能的叠加。原始组件未被修‏改，所有增强功能都是通过包裹实现‍的，  
     体现了装饰模式的核心思想：包⁡装而非继承，扩展而非修改。  

# 优缺点
  优点：  
  - 扩展功能更灵活
  - 避免类过多
  - 可以组合使用

  缺点： 
  - 调试比较麻烦
  - 增加了系统复杂度
  - 可能影响性能

# 应用场景
  - 动态增加功能或行为
  - 输入输出流处理
  - 日志系统功能增强
  - 文本渲染增强系统

# 开源框架中的应用
  1. Spring 框架中的 HttpServletRequestWrapper 和 HttpServletResponseWrapper  
     我们在开发 Web 应用时经常接触到 HttpServletRequest 和 HttpServletResponse，它们代表了请求和响应对象。  
     而 HttpServletRequestWrapper 和 HttpServletResponseWrapper 正是 Spring Web 模块中对这两个对象的装饰器实现。  
     这两个类的作用是作为一个“中间壳”，把原始的 HttpServletRequest 包装起来，默认是把所有方法都“原样转发”给原始的 request 对象。  

     比如ContentCachingRequestWrapper，这个类用来增强原始的 HttpServletRequest，让我们可以重复读取请求体。我们来看下源码：  
     ```java
      public class ContentCachingRequestWrapper extends HttpServletRequestWrapper {
          private final ByteArrayOutputStream cachedContent;
      
          public ContentCachingRequestWrapper(HttpServletRequest request) {
              super(request);
          }
      
          @Override
          public ServletInputStream getInputStream() throws IOException {
              if (this.inputStream == null) {
                  // 缓存请求体，方便后面重复读取
                  this.inputStream = new ContentCachingInputStream(this.getRequest().getInputStream());
              }
      
              return this.inputStream;
          }
      
          public byte[] getContentAsByteArray() {
              return this.cachedContent.toByteArray();
          }
      }
     ```
     它继承自 HttpServletRequestWrapper，后者本身就已经是对 HttpServletRequest 的包装。  
     Spring 的 ContentCachingRequestWrapper 再次装饰这个对象，增强了“请求体可重复读取”的能力，常用于日志记录、过滤器链等场景。  

     除了使用 Spring 已有的，我们还可以自定义请求包装器。举个场景，比如我们想在读取参数之前先统一打印日志，或者对请求中的某个参数做一下格式处理。  
     如果我们直接在业务代码里每次处理请求都手动加判断，那既重复又容易出错。   
     这时候我们可以自己继承HttpServletRequestWrapper类，实现一个自定义请求增强器    
     ```java
      public class LogRequestWrapper extends HttpServletRequestWrapper {
          public LogRequestWrapper(HttpServletRequest request) {
              super(request);
          }
      
          @Override
          public String getParameter(String name) {
              String value = super.getParameter(name);
              System.out.println("参数名：" + name + "，值：" + value);
              return value;
          }
      }
     ``` 
     然后在过滤器或拦截器中替换原始请求：    
     ```java
      chain.doFilter(new LogRequestWrapper(request), response);
     ```
     这种“增强不‌侵入”的方式，就是典型的⁢装饰模式应用。Sprin‏g 本身很多地方都是通过‍这种“包装器 + 委托”⁡结构来实现灵活扩展的。    

  2. JDK 中的 BufferedReader、BufferedInputStream  
     我们先看 JDK 里面最典型的装饰模式实现，就是在 IO 流这一块，比如我们经常用到的 BufferedReader、BufferedInputStream。  

     它们并不是‌直接读取数据，而是⁢包装了底层的原始输‏入流，通过加一层缓‍冲机制来提升读取效⁡率。我们看下实际的类结构：  
     ```java
      public class BufferedReader extends Reader {
          private Reader in; // 被包装的 Reader
      
          public BufferedReader(Reader in) {
              this(in, defaultCharBufferSize);
          }
      
          public String readLine() throws IOException {
              // 加缓冲逻辑读取一整行
          }
      }
     ```
     ```java
      // 使用方式
      Reader reader = new FileReader("test.txt");
      BufferedReader bufferedReader = new BufferedReader(reader);
      String line = bufferedReader.readLine();
     ```
     可以看到，我们通过 BufferedReader 对 FileReader 做了包装，但并没有去动原始的 FileReader 类逻辑，这就符合了装饰模式的基本结构  
     我们看下类图:  
     <img width="1204" height="996" alt="image" src="https://github.com/user-attachments/assets/a8d86fb1-a241-4a05-9049-01701ab8fc23" />

     从类图能看出来，BufferedReader 和 FileReader 都继承自同一个抽象类 Reader，  
     然后通过组合的方式包装了一个 Reader 类型的对象，实现了增强功能但不破坏结构的目的。  
