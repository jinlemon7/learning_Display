# 设计模式核心思想对应体现在哪些Java定义中
  | Java定义 | 设计原则 |  
  | :---: | --- |  
  | 继承和多态 | 开闭原则<br/> 里式替换原则 |  
  | 面向抽象编程 | 依赖倒置原则<br/> 接口隔离原则 |  
  | 封装 | 单一职责原则<br/> 迪米特法则 |  

# 设计模式主要体现了哪些Java定义
  | Java定义 | 设计模式 |  
  | :---: | --- |  
  | 继承和多态 | 1.工厂方法模式<br/> 2.抽象工厂模式<br/> 3.装饰模式<br/> 4.外观模式<br/> 5.桥接模式<br/> 6.策略模式<br/> 7.中介者模式<br/> 8.模板方法模式<br/> 9.状态模式<br/> 10.责任链模式<br/> 11.解释器模式<br/> 12.访问者模式 |  
  | 面向抽象编程 | 1.建造者模式<br/> 2.原型模式<br/> 3.适配器模式<br/> 4.代理模式<br/> 5.组合模式<br/> 6.享元模式<br/> 7.观察者模式<br/> 8.命令模式<br/> 9.迭代器模式<br/> |   
  | 封装 | 1.单例模式<br/> 2.备忘录模式 |  

# 设计模式的定义和基本组成(按Java定义排序)
## 继承和多态
  1. 工厂方法模式（Factory Method Pattern）  
     旨在定义一个用于创建对象的接口（工厂的接口）， 通过具体工厂类决定实例化哪个具体类。  

     <img width="1112" height="646" alt="image" src="https://github.com/user-attachments/assets/3251604c-8f6d-4982-a3af-874ca80bf0d5" />

  2. 抽象工厂模式（Abstract Factory Pattern）   
     一个“超级工厂”的接口，专门用来创建一整组互相关联的产品对象。 ——产品族（一系列产品）。  
     
     <img width="1434" height="612" alt="image" src="https://github.com/user-attachments/assets/5ac7cafc-f875-41fb-8cbe-b98376b4b9d9" />

  3. 装饰模式（Decorator Pattern）  
     动态地给对象添加额外的功能，而不会影响到其他对象。  

     <img width="994" height="680" alt="image" src="https://github.com/user-attachments/assets/533bd619-5530-465e-b9cb-2988941d2d7a" />

  4. 外观模式（Facade pattern）  
     为复杂的子系统提供一个统一的对外接口，不需要关心它们内部的复杂逻辑。  

     <img width="844" height="614" alt="image" src="https://github.com/user-attachments/assets/b3cadf24-a7fb-40a6-a839-21c01e29d457" />

  5. 桥接模式（Bridge Pattern）  
     把 可扩展的抽象上层（包含实现下层的引用） 和 实现下层 分离开来的方法，让它们可以各自独立变化。  

     <img width="1088" height="728" alt="image" src="https://github.com/user-attachments/assets/39c8c87a-8df7-4648-a6eb-87cdcd6f4adb" />

  6. 策略模式（Strategy Pattern）  
     定义一系列算法，把它们一个个封装起来，并且让它们可以互相替换。  

     <img width="714" height="708" alt="image" src="https://github.com/user-attachments/assets/2cb68c18-0684-43fd-8ba5-c494b360db78" />

  7. 中介者模式（Mediator Pattern）  
     通过引入一个中介对象，来封装对象之间复杂的交互关系。  

     <img width="1224" height="816" alt="image" src="https://github.com/user-attachments/assets/ef5e2609-7571-4f43-b46b-ab91be875de9" />、

  8. 模板方法模式（Template Method Pattern）  
     在一个方法中定义好算法的整体流程结构，把一些具体的步骤延迟到子类中去实现。  

     <img width="776" height="500" alt="image" src="https://github.com/user-attachments/assets/57e17a04-ce56-4e6b-8e2b-e2ebbd336843" />

  9. 状态模式（State Pattern）  
     允许对象在内部状态变化时，改变它的行为，看起来就像是对象本身发生了变化一样。  

     <img width="852" height="712" alt="image" src="https://github.com/user-attachments/assets/342769c7-239a-4d19-a1d4-2b186a5a01d8" />

  10. 责任链模式（Chain of Responsibility Pattern）  
      将多个处理请求的对象连接成一条链，每个对象在链上依次处理请求，直到有对象处理完请求为止。  

      <img width="1030" height="650" alt="image" src="https://github.com/user-attachments/assets/a0fb6d37-4195-4386-ab2a-64a06f6109a2" />

  11. 解释器模式（Interpreter Pattern）  
      为特定类型的语言提供解释执行的方法。  

      <img width="1106" height="706" alt="image" src="https://github.com/user-attachments/assets/a3b14dcf-d93c-40fd-8ce4-b6823e05dcb8" />

  12. 访问者模式（Visitor Pattern）  
      将数据结构和作用于数据结构上的操作分离开来，让新的操作可以在不改变数据结构的前提下添加进来。  

      <img width="1668" height="770" alt="image" src="https://github.com/user-attachments/assets/76d15ea5-9a1f-44a9-9979-b11aa9798152" />

## 面向抽象编程
  1. 建造者模式（Builder Pattern）  
     把一个复杂对象的创建过程拆解成多个步骤单元，逐步构建。  

     <img width="638" height="712" alt="image" src="https://github.com/user-attachments/assets/ecd72c06-8216-4d44-9046-f715944ead32" />

  2. 原型模式（Prototype Pattern）  
     通过复制现有的对象来创建新对象，而不是通过“new”关键字来直接实例化,从而减少了重复构建相同对象的成本。  

     <img width="556" height="748" alt="image" src="https://github.com/user-attachments/assets/c4b374c2-b560-4267-af40-6610bb2b7bbd" />

  3. 适配器模式（Adapter pattern）  
     通过创建一个适配器类，将一个接口转换成业务端所期望的另一个接口。  

     <img width="400" height="930" alt="image" src="https://github.com/user-attachments/assets/0153ea7b-9727-4d4b-8066-790d1d367f30" />

  4. 代理模式（Proxy Pattern）  
     给某个对象提供一个代理对象，并由代理对象来控制对这个对象的访问。  

     <img width="654" height="674" alt="image" src="https://github.com/user-attachments/assets/8a4bcbf3-ab71-4fa0-b19b-c46fab0bf9bf" />

  5. 组合模式（Composite Pattern）  
     用统一的方式来处理单个对象和一组对象。  

     <img width="848" height="518" alt="image" src="https://github.com/user-attachments/assets/f06b7a0f-6af7-43a1-a6ac-874c6213dd4c" />

  6. 享元模式（Flyweight Pattern）  
     通过共享对象，减少系统中对象的数量，从而节省内存，提高性能。  

     <img width="538" height="638" alt="image" src="https://github.com/user-attachments/assets/0832bb56-8883-425e-a82a-8bd8034f52d2" />

  7. 观察者模式（Observer Pattern）  
     当一个对象状态发生变化时，自动通知所有依赖于它的对象，并自动更新它们。  

     <img width="468" height="1098" alt="image" src="https://github.com/user-attachments/assets/b36d4ff8-5652-4bdc-b44e-f5edeefb2396" />

  8. 命令模式（Command Pattern）  
     把请求封装成一个对象，这样我们就能用不同的请求、队列或者日志来参数化其他对象，同时也支持可撤销操作。  

     <img width="582" height="1024" alt="image" src="https://github.com/user-attachments/assets/bad8b8e0-b995-4a06-a75f-2669ad10a608" />\

  9. 迭代器模式（Iterator Pattern）  
      提供一种方法，顺序访问一个集合对象内部的元素，而又不暴露集合的内部结构。  

      <img width="764" height="778" alt="image" src="https://github.com/user-attachments/assets/47f42204-0890-4e37-9560-8ee8c6509337" />

## 封装
  1. 单例模式（Singleton Pattern）  
     全局只能有一个对象，而且这个对象谁都能随时找到。  

     <img width="634" height="209" alt="image" src="https://github.com/user-attachments/assets/cc2aee09-fdb9-4cef-8ba0-408fa62c1ccb" />

  2. 备忘录模式（Memento Pattern）  
     在不破坏对象封装性的前提下，捕获一个对象的内部状态，并在将来需要的时候能够恢复这个状态。  

     <img width="1208" height="630" alt="image" src="https://github.com/user-attachments/assets/8dc8aeeb-677d-4c17-a855-4426aa6b0a82" />


# 通用多设计模式组合
  1. 外观 + 模版方法 + 工厂方法 + 策略 + （代理/装饰/责任链/状态 等） + 观察者
     ```mermaid
      graph TD;
        外观-->模版方法;
        模版方法-->工厂方法;
        工厂方法-->策略;
     
        代理-->策略;
        装饰-->策略;
        责任链-->策略;
        状态-->策略;

        状态-->观察者;
        策略-->观察者;
     ```
