# 概念
  当一个对象状态发生变化时，自动通知所有依赖于它的对象，并自动更新它们。  
  为了让大家更好‌地感受到观察者模式的作用，以⁢社交媒体通知系统为例，我们需‏要实现用户发布动态后自动通知‍所有关注者的功能。  
  让我们来看⁡看使用和不使用观察者模式的区别：  

  <img width="1878" height="1140" alt="image" src="https://github.com/user-attachments/assets/c1ae5254-2662-4965-87e0-f6eb3886c7cc" />

# 基本结构
  1. 主题（‌Subject）：⁢定义了观察者注册、‏移除和通知的接口，‍同时维护观察者列表⁡。                     ——主题的接口
  2. 具体主题（C‌oncreteSubject）：⁢实现主题接口，并在自己的状态发生‏变化时，通知所有注册的观察者。 ‍   ——具体主题类
  3. 观察者‌（Observer⁢）：定义了响应主题‏通知的更新接口。                                          ——观察者的接口
  4. 具体观‌察者（Concre⁢teObserve‏r）：实现观察者接‍口，接收到通知后，⁡根据需要做出具体处理。          ——具体观察者类
  <img width="468" height="1098" alt="image" src="https://github.com/user-attachments/assets/5df4b743-8035-4d3d-80d2-12382f18d1c4" />

# 代码实现
  下面就以 ‌“社交媒体通知系统⁢” 为例，我们用观‏察者模式实现一个简‍单的用户-粉丝关系的⁡通知机制。    
  1. 观察者的接口
     ```java
      public interface Follower {
          void update(String userName, String postContent);
      }
     ```
     这一步定义了观察者的标准接口。所有“粉丝”类只要实现 update 方法，就能接收动态通知，实现订阅功能。  
  2. 主题的接口
     ```java
      public interface User {
          void addFollower(Follower follower);
          void removeFollower(Follower follower);
          void notifyFollowers(String postContent);
      }
     ```
     这一步定义‌了“被关注者”的行⁢为，也就是谁发动态‏、怎么通知所有关注‍他的人，这样粉丝系⁡统就可以被统一管理。  
  3. 具‌体观察者类
     ```java
      public class ConcreteFollower implements Follower {
          private String name;
      
          public ConcreteFollower(String name) {
              this.name = name;
          }
      
          @Override
          public void update(String userName, String postContent) {
              System.out.println(name + " 收到通知：@" + userName + " 发了一条新动态：" + postContent);
          }
      }
     ```
     这一步定义‌了真正的“观察者”—⁢—每个粉丝都是一个实‏现类，收到通知就打‍印提示。你也可以扩展为⁡推送消息、存入消息中心等。  
  4. 具体主题类
     ```java
      import java.util.ArrayList;
      import java.util.List;
      
      public class ConcreteUser implements User {
          private String userName;
          private List<Follower> followers;
      
          public ConcreteUser(String userName) {
              this.userName = userName;
              this.followers = new ArrayList<>();
          }
      
          @Override
          public void addFollower(Follower follower) {
              followers.add(follower);
          }
      
          @Override
          public void removeFollower(Follower follower) {
              followers.remove(follower);
          }
      
          @Override
          public void notifyFollowers(String postContent) {
              for (Follower f : followers) {
                  f.update(userName, postContent);
              }
          }
      
          public void post(String content) {
              System.out.println(userName + " 发布动态：" + content);
              notifyFollowers(content);
          }
      }
     ```
     这一步实现了一个“发动态的用户”类。他有一个粉丝列表，一旦调用 post()，就能自动通知所有粉丝。这个类是观察者模式的“核心控制中心”。  
  5. 测试使用
     ```java
      public class Client {
          public static void main(String[] args) {
              ConcreteUser star = new ConcreteUser("鱼皮");
      
              Follower f1 = new ConcreteFollower("张三");
              Follower f2 = new ConcreteFollower("李四");
              Follower f3 = new ConcreteFollower("王五");
      
              star.addFollower(f1);
              star.addFollower(f2);
              star.addFollower(f3);
      
              star.post("今天阳光真好，适合写代码！");
          }
      }
     ```
     输出结果：  
     ```java
      鱼皮 发布动态：今天阳光真好，适合写代码！
      张三 收到通知：@鱼皮 发了一条新动态：今天阳光真好，适合写代码！
      李四 收到通知：@鱼皮 发了一条新动态：今天阳光真好，适合写代码！
      王五 收到通知：@鱼皮 发了一条新动态：今天阳光真好，适合写代码！
     ```
     通过这种方式，我们只需要让粉丝实现 Follower 接口，再注册到某个用户，用户一发动态，所有关注者自动收到消息。  
     这就是观察者模式的优势：发布者和订阅者完全解耦，只需定义好接口，通知链条自动生效。    
     
# 优缺点
  优点:  
  - 解耦观察者和被观察者
  - 支持动态改变
  - 多对多关系

  缺点：
  - 可能会导致通知过多：如果观察者数量非常多或主题状态更新频繁，每次状态变化都会通知所有观察者，这可能导致性能问题，
    特别是在观察者数量较大的情况下，通知的开销也会增加。
  - 依赖链复杂
  - 不适用于双向通知

# 应用场景
  - 社交媒体通知系统
  - 帖子订阅系统
  - 电商网站的订单状态变化通知

# 开源框架中的应用
  1. Spring 的 事件发布机制  
     Spring 的 事件发布机制，本质上就是观察者模式的变体。我们可以通过事件发布器 ApplicationEventPublisher 发布一个事件，  
     系统中所有监听该事件的监听器都会收到通知。  

     先看核心接口和类的关系：  
     - ApplicationEvent：事件对象（被观察者发布的内容）  
     - ApplicationListener：监听器（观察者）  
     - ApplicationEventPublisher：事件发布器（发布通知）  

     来看下 Spring 的使用代码：  
     ```java
      // 自定义事件
      public class UserRegisterEvent extends ApplicationEvent {
          private final String username;
      
          public UserRegisterEvent(Object source, String username) {
              super(source);
              this.username = username;
          }
      
          public String getUsername() {
              return username;
          }
      }
      
      // 发布事件
      @Component
      public class UserService {
          @Autowired
          private ApplicationEventPublisher publisher;
      
          public void register(String username) {
              // 注册逻辑...
              publisher.publishEvent(new UserRegisterEvent(this, username));
          }
      }
      
      // 监听事件
      @Component
      public class WelcomeEmailListener implements ApplicationListener<UserRegisterEvent> {
          @Override
          public void onApplicationEvent(UserRegisterEvent event) {
              System.out.println("发送邮件给: " + event.getUsername());
          }
      }
     ```
     整个流程就‌是：注册完成后发布⁢事件，监听器自动接‏收到这个事件并执行对应‍的操作。  

  2. JDK‌ 中的 java.util.Observable 和 java.util.Observer  
     在 JDK‌ 中，其实很早就提⁢供了对观察者模式的‏支持，主要是这两个‍类：  
     - java.util.Observable：被观察者（Subject）  
     - java.util.Observer：观察者（Observer）  

     虽然从 J‌DK 9 开始，这两⁢个类被标记为“过时”‏，但它们依然是观察者‍模式最经典的实现方式⁡，仍然可以学习一下。  

     我们看下使用场景：  
     ```java
      // 被观察者（发布者）
      public class PostAgency extends Observable {
          private String post;
      
          public void setPost(String post) {
              this.post = post;
              setChanged();         // 标记数据发生了变化
              notifyObservers(post); // 通知所有观察者
          }
      }
      
      // 观察者（订阅者）
      public class PostChannel implements Observer {
          @Override
          public void update(Observable o, Object arg) {
              System.out.println("收到帖子更新: " + arg);
          }
      }
     ```
     使用方式也很简单:  
     ```java
      PostAgency agency = new PostAgency();
      PostChannel channel = new PostChannel();
      
      agency.addObserver(channel); // 注册观察者
      agency.setNews("鱼皮发布了帖子"); // 发布通知
     ```
     这个结构非常清晰：  
     - 发布者：Observable，负责注册/管理观察者、发布通知；   
     - 观察者：Observer，只需实现 update() 方法即可接收通知  
