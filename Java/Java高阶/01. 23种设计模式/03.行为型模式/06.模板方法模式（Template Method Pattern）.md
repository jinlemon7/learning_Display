# 概念
  在一个方法中定义好算法的整体流程结构，把一些具体的步骤延迟到子类中去实现。  
  为了让大家更好‌地感受到模板方法模式的作用，⁢以订单处理流程为例，我们需要‏实现一个支持不同类型订单处理‍的系统。  
  让我们来看看使用和不⁡使用模板方法模式的区别：  

  <img width="1888" height="1186" alt="image" src="https://github.com/user-attachments/assets/156afba9-50b6-4904-95c2-d3bdbf7e7520" />

# 基本结构
  1. 抽象类‌（Abstract⁢Class）：定义‏模板方法和基本流程‍骨架，声明一些抽象⁡操作让子类实现。      
  2. 具体子‌类（Concret⁢eClass）：实‏现父类定义的抽象步‍骤，完成特定子类自⁡己的逻辑。          

  <img width="776" height="500" alt="image" src="https://github.com/user-attachments/assets/c3b94f3b-9c26-4d59-b820-19784ea154d4" />

# 代码实现
  下面就以 ‌“订单处理流程” ⁢为例，我们用模板方‏法模式实现一个简单‍的订单处理流程。  

  1. 抽象类‌
     ```java
      abstract class OrderProcessTemplate {
          // 模板方法，定义了订单处理的固定步骤
          public final void processOrder() {
              checkStock();
              pay();
              deliver();
              notifyCustomer();
          }
      
          // 校验库存的步骤，所有订单都需要
          protected void checkStock() {
              System.out.println("检查库存");
          }
      
          // 支付步骤，交由具体子类实现
          protected abstract void pay();
      
          // 发货步骤，交由具体子类实现
          protected abstract void deliver();
      
          // 通知客户的步骤，所有订单都需要
          protected void notifyCustomer() {
              System.out.println("通知客户订单处理完成");
          }
      }
     ```
     在这段代码中，我们定义了一个 OrderProcessTemplate 类，其中的 processOrder 方法是模板方法，包含了订单处理的公共步骤。  
     checkStock 和 notifyCustomer 是所有订单都必须进行的步骤，所以它们在父类中实现了。  
     而 pay 和 deliver 这些具体的步骤则被声明为抽象方法，由具体的子类实现。  
  2. 具体子类
     ```java
      class PhysicalProductOrder extends OrderProcessTemplate {
          @Override
          protected void pay() {
              System.out.println("支付实物商品的订单");
          }
      
          @Override
          protected void deliver() {
              System.out.println("发货实物商品");
          }
      }
     ```
     具体子类 PhysicalProductOrder 实现了支付和发货的具体逻辑，对于实物商品的订单，支付方式和发货方式可能与虚拟商品不同。  
     ```java
      class VirtualProductOrder extends OrderProcessTemplate {
          @Override
          protected void pay() {
              System.out.println("支付虚拟商品的订单");
          }
      
          @Override
          protected void deliver() {
              System.out.println("通过邮件发送虚拟商品");
          }
      }
     ```
     VirtualProductOrder 继承了模板类，并实现了虚拟商品的支付和发货逻辑。对于虚拟商品，支付和发货的流程与实物商品不同。  
  3. 测试使用
     ```java
      public class Client {
          public static void main(String[] args) {
              System.out.println("处理实物商品订单：");
              OrderProcessTemplate physicalOrder = new PhysicalProductOrder();
              physicalOrder.processOrder(); // 调用模板方法
      
              System.out.println("\n处理虚拟商品订单：");
              OrderProcessTemplate virtualOrder = new VirtualProductOrder();
              virtualOrder.processOrder(); // 调用模板方法
          }
      }
     ```
     输出结果：‌  
     ```java
      处理实物商品订单：
      检查库存
      支付实物商品的订单
      发货实物商品
      通知客户订单处理完成
      
      处理虚拟商品订单：
      检查库存
      支付虚拟商品的订单
      通过邮件发送虚拟商品
      通知客户订单处理完成
     ```
     在这个下单的例子中，使用模‌板方法模式可以帮助我们抽象出公共的处理流程（如检查⁢库存和通知客户），并允许具体的子类去定制化支付和发‏货的实现细节。  
     这样一来，系统能够处理不同类型的订单‍，但流程依然保持一致，同时又能根据具体的订单类型（⁡如实物商品和虚拟商品）来定制具体步骤。  

# 优缺点
  优点:  
  - 代码复用性高
  - 控制流程
  - 提高扩展性

  缺点：  
  - 父类过于庞大
  - 不够灵活
  - 过多的继承关系

# 应用场景
  - 爬虫系统中的通用抓取流程：在开发爬虫时，不同网站的页面结构不同，但抓取流程往往类似（如：建立连接 → 下载页面 → 解析内容 → 保存数据）。
    可以使用模板方法模式定义抽象的抓取流程，将每一步封装成钩子方法，让子类实现特定网站的解析逻辑。
  - 活动营销系统中的通用促销流程
  - 订单处理流程标准化

# 开源框架中的应用
  1. Spring 中的 JdbcTemplate  
     在 Spring 中，JdbcTemplate 是一个非常典型的模板方法模式的应用。  
     我们在平时写数据库代码的时候，只需要传入 SQL 和参数，甚至只实现一个回调接口，就能完成复杂的操作，比如查询、更新、事务控制等等。  

     它的核心思路是：先定义好数据库操作的整体流程，包括：  
     1. 获取连接
     2. 执行 SQL
     3. 处理结果集
     4. 关闭连接

     这里我们只关心传入SQL语句，以及怎么把查询结果的数据映射成对象，其他像连接的获取、语句的执行、结果的处理、资源的释放，  
     全部由 JdbcTemplate 处理好。我们来看下源码：  
     ```java
      public class JdbcTemplate extends JdbcAccessor implements JdbcOperations {
      
          public <T> T query(String sql, ResultSetExtractor<T> rse) throws DataAccessException {
              // 省略其他代码...
              return execute(new QueryStatementCallback(sql, rse));
          }
      
          private <T> T execute(StatementCallback<T> action, boolean closeResources) throws DataAccessException {
              Assert.notNull(action, "Callback object must not be null");
              // 从数据源中获取一个数据库连接
              Connection con = DataSourceUtils.getConnection(obtainDataSource());
              Statement stmt = null;
              try {
                  // 创建一个 Statement 对象用于执行 SQL
                  stmt = con.createStatement();
                  // 应用配置，比如设置超时时间、fetch size 等
                  applyStatementSettings(stmt);
                  // 执行回调中的数据库逻辑，回调交给使用者处理
                  T result = action.doInStatement(stmt);
                  handleWarnings(stmt);
                  return result;
              }
              catch (SQLException ex) {
                  // 省略其他代码...
              }
              finally {
                  if (closeResources) {
                      JdbcUtils.closeStatement(stmt);
                      DataSourceUtils.releaseConnection(con, getDataSource());
                  }
              }
          }
      }
     ```
     这个 execute 方法就像模板一样，定义了整体数据库访问的步骤，而具体逻辑由回调类 QueryStatementCallback去实现。  

  2. JDK 的集合框架中的 AbstractList、AbstractSet、AbstractMap  
     在 JDK 的集合框架里，其实模板方法模式的用法特别常见。我们可以看到 AbstractList、AbstractSet、AbstractMap 这些抽象类里，  
     都提前定义好了集合的整体操作逻辑，而把具体行为留给子类去实现。我们拿 AbstractList 这个类来举个例子。  

     比如 addAll(Collection<? extends E> c) 这个方法，它的整体流程是已经写死的：  
     先做参数检查、然后遍历集合调用 add() 方法、再根据添加结果返回布尔值。但是这个 add() 方法本身是抽象的，交给子类来实现。  
     ```
      public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> {
      
          // 模板方法，添加所有元素
          public boolean addAll(int index, Collection<? extends E> c) {
              rangeCheckForAdd(index);
              boolean modified = false;
              for (E e : c) {
                  // 调用子类的 add 方法，模板方法的核心体现
                  add(index++, e);
                  modified = true;
              }
              return modified;
          }
      
          abstract E get(int index);
      
          abstract E set(int index, E element);
      }
     ```
     在这个过程中，addAll() 是一个模板方法，规定好了执行流程，而把核心操作 add() 抽象出来。  
     这样不同的集合子类可以自定义 add() 的实现，但整个流程逻辑是不变的。  

     我们可以通过类图来表示下结构：  
     <img width="1100" height="1176" alt="image" src="https://github.com/user-attachments/assets/5298a945-af42-453f-9761-cb04440bdfc3" />
