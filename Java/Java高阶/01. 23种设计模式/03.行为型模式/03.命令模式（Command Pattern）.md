# 概念
  把请求封装成一个对象，这样我们就能用不同的请求、队列或者日志来参数化其他对象，同时也支持可撤销操作。  
  为了让大家更好‌地感受到命令模式的作用，以任⁢务调度系统为例，我们需要实现‏一个灵活的任务执行平台，支持‍多种类型的任务调度。  
  让我们来⁡看看使用和不使用命令模式的区别：  

  <img width="1884" height="1036" alt="image" src="https://github.com/user-attachments/assets/6db56212-e766-43a6-a3a2-6677e3a136c6" />

# 基本结构
  1. 命令接口（Command）：声明执行操作的方法，比如execute()。                             ——命令的接口
  2. 具体命‌令（Concret⁢eCommand）‏：实现命令接口，负‍责调用接收者（Re⁡ceiver）去完成请求。      ——具体命令类
  3. 接收者‌（Receiver⁢）：真正执行具体业‏务逻辑的人（类）。                                  ——接收者类
  4. 请求者（Invoker）：负责调用命令对象来执行请求                                        ——请求者类
  5. 业务端：⁢创建具体命令对象并‏设置好接收者，最后‍把命令交给请求者执⁡行。                     ——业务端类

  <img width="582" height="1024" alt="image" src="https://github.com/user-attachments/assets/34415ebb-bb62-4f59-be3f-68fe6be0dc56" />

# 代码实现
  下面就以“‌任务调度系统”为例⁢，我们用命令模式来‏构建一个可扩展的任务执‍行平台。  

  1. 命令的接口
     ```java
      public interface Task {
          void execute();
      }
     ```
     命令接口 Task 代表所有可执行的调度任务，比如发邮件、备份、报表等，调用方式统一。  
  2. 具体命令类
     ```java
      public class EmailTask implements Task {
          @Override
          public void execute() {
              System.out.println("发送通知邮件...");
              // 实际的发邮件逻辑
          }
      }
      
      public class BackupTask implements Task {
          @Override
          public void execute() {
              System.out.println("正在备份数据库...");
              // 实际的备份逻辑
          }
      }
      
      public class ReportTask implements Task {
          @Override
          public void execute() {
              System.out.println("生成业务报表...");
              // 实际的报表生成逻辑
          }
      }
     ```
     每个具体命令类‌代表一个可执行的命⁢令对象，内部封装具‏体的业务逻辑，便于‍独立管理和扩展。  
  3. 请求者类
     ```java
      import java.util.LinkedList;
      import java.util.Queue;
      
      public class TaskScheduler {
          private Queue<Task> taskQueue = new LinkedList<>();
      
          public void addTask(Task task) {
              taskQueue.offer(task);
          }
      
          public void run() {
              while (!taskQueue.isEmpty()) {
                  Task task = taskQueue.poll();
                  try {
                      task.execute();
                      System.out.println("任务执行成功！");
                  } catch (Exception e) {
                      System.out.println("任务执行失败，记录日志以供重试...");
                  }
              }
          }
      }
     ```
     调度器负责‌统一管理所有任务对⁢象，可以实现任务队‏列、任务执行、异常‍捕获等一整套执行流⁡程。  
  4. 测试使用
     ```java
      public class SchedulerClient {
          public static void main(String[] args) {
              TaskScheduler scheduler = new TaskScheduler();
      
              scheduler.addTask(new EmailTask());
              scheduler.addTask(new BackupTask());
              scheduler.addTask(new ReportTask());
      
              scheduler.run();
          }
      }
     ```
     输出结果：  
     ```java
      发送通知邮件...
      任务执行成功！
      正在备份数据库...
      任务执行成功！
      生成业务报表...
      任务执行成功！
     ```
     命令模式的核心价值就在这里：我们将“做什么任务”抽象成一个命令对象，统一交由调度器来“何时执行”和“如何调度”，两者完全解耦。  
     增加一个新任务，只需新建一个 Task 实现类，无需改动调度器。  
     
# 优缺点
  优点:  
  - 解耦请求者和执行者
  - 支持撤销/恢复操作：命令模式能够方便地实现操作的撤销和恢复。通过保存命令对象和其执行状态，可以在需要时撤销已执行的命令或恢复到之前的状态。
  - 增加新的命令很方便
  - 支持宏命令：命令模式可以通过将多个命令组合成一个宏命令来实现批量操作，方便了复杂操作的组织和管理。

  缺点：  
  - 类的数量增加
  - 命令的管理和维护
  - 不适合简单的场景

# 应用场景
  - 任务调度系统中的任务封装
  - 界面操作的撤销与重做功能
  - 消息中间件中的指令执行模型：在基于MQ的系统中，不同类型的消息可以对应不同的业务指令，如订单处理、用户注册、支付完成等。

# 开源框架中的应用
  1. 在 JDK 中线程池里的 Runnable 和 Executor  
     在 JDK 里，命令模式最典型的应用就是线程池里的 Runnable 和 Executor。  

     我们可以这样理解：  
     - Runnable 相当于一个“命令对象”，里面封装了具体要执行的业务逻辑。  
     - Executor 是一个“命令的调用者”，负责接收并触发这些命令。  

     ```java
      // 命令接口，相当于 Command
      @FunctionalInterface
      public interface Runnable {
          public abstract void run();
      }
      
      // 命令接收者，可以执行命令
      public class Thread {
          public Thread(Runnable target) {
              init(null, target, "Thread-" + nextThreadNum(), 0);
          }
      
          @Override
          public void run() {
              if (target != null) {
                  target.run();
              }
          }
      }
      
      // 命令调用者，相当于 Invoker
      public interface Executor {
          void execute(Runnable command);
      }
     ```
     在我们使用线程池时，会这么写：  
     ```java
      Executor executor = Executors.newFixedThreadPool(2);
      executor.execute(() -> {
          System.out.println("处理一段业务逻辑");
      });
     ```
     这就是命令模式的使用场景：我们把具体要做的事封装成一个 Runnable，然后丢给 Executor 来执行。  
