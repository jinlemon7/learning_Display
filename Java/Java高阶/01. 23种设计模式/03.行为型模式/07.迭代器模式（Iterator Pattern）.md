# 概念
  提供一种方法，顺序访问一个集合对象内部的元素，而又不暴露集合的内部结构。  
  为了让大家更好地感受‌到迭代器模式的作用，以流程节点遍历为例⁢，我们需要实现一个支持遍历流程节点的‏系统。  
  让我们来看看使用和不使用迭代器模式‍的区别：  

  <img width="1884" height="1254" alt="image" src="https://github.com/user-attachments/assets/76b61d53-e155-420e-b68e-c88680871c47" />

# 基本结构
  1. 迭代器‌接口（Iterat⁢or）：定义访问和‏遍历元素的方法。                           ——迭代器的接口
  2. 具体迭‌代器（Concre⁢teIterato‏r）：实现迭代器接‍口，负责具体遍历逻⁡.              ——具体迭代器类
  3. 聚合接‌口（Aggrega⁢te）：定义创建迭‏代器对象的方法。                            ——聚合的接口
  4. 具体聚‌合（Concret⁢eAggregat‏e）：实现聚合接口‍，创建对应的迭⁡代器实例。          ——具体聚合类

  <img width="764" height="778" alt="image" src="https://github.com/user-attachments/assets/c45361e0-521d-434b-9e91-8bcba55f816b" />

# 代码实现
  下面就以 ‌“流程引擎中的节点⁢遍历” 为例，我们‏用迭代器模式实现一‍个简单的流程节点⁡遍历系统。   

  1. 节点类
     ```java
      class ProcessNode {
          private String name;
      
          public ProcessNode(String name) {
              this.name = name;
          }
      
          public String getName() {
              return name;
          }
      
          @Override
          public String toString() {
              return "ProcessNode{name='" + name + "'}";
          }
      }
     ```
     在这段代码中，我们定义了一个 ProcessNode 类，表示流程中的一个节点。每个节点有一个名称，表示这个节点的类型（如“审批节点”，“通知节点”等）。  
     我们实现了 toString 方法，方便在遍历时输出节点信息。  
  2. 迭代器的接口
     ```java
      interface Iterator {
          boolean hasNext();  // 判断是否还有下一个元素
          Object next();      // 获取下一个元素
      }
     ```
     在这里，我们定义了一个 Iterator 接口，它包含 hasNext() 和 next() 方法。hasNext() 判断是否还有下一个节点，next() 返回下一个节点。  
  3. 具体聚合类
     ```java
      class Workflow {
          private ProcessNode[] nodes;
          private int size;
      
          public Workflow(int capacity) {
              nodes = new ProcessNode[capacity];
              size = 0;
          }
      
          // 添加节点到流程中
          public void addNode(ProcessNode node) {
              if (size < nodes.length) {
                  nodes[size++] = node;
              }
          }
      
          // 返回流程的迭代器
          public Iterator iterator() {
              return new WorkflowIterator();
          }
      
          // 具体的迭代器实现类
          private class WorkflowIterator implements Iterator {
              private int index;
      
              public WorkflowIterator() {
                  index = 0;
              }
      
              @Override
              public boolean hasNext() {
                  return index < size;
              }
      
              @Override
              public Object next() {
                  if (hasNext()) {
                      return nodes[index++];
                  }
                  return null;
              }
          }
      }
     ```
     在这里，我们定义了一个 Workflow 类，表示流程。Workflow 内部保存了一个节点数组，并提供了 addNode() 方法来添加节点。  
     iterator() 方法返回一个 Iterator 对象，用于遍历流程中的节点。  
     我们实现了一个 WorkflowIterator 内部类，它实现了 Iterator 接口，提供了节点的遍历逻辑。  
  4. 测试使用
     ```java
      public class Client {
          public static void main(String[] args) {
              Workflow workflow = new Workflow(5);
              workflow.addNode(new ProcessNode("开始"));
              workflow.addNode(new ProcessNode("审批"));
              workflow.addNode(new ProcessNode("通知"));
              workflow.addNode(new ProcessNode("结束"));
      
              // 获取迭代器进行遍历
              Iterator iterator = workflow.iterator();
              while (iterator.hasNext()) {
                  ProcessNode node = (ProcessNode) iterator.next();
                  System.out.println("Executing node: " + node);
              }
          }
      }
     ```
     输出结果：  
     ```java
      Executing node: ProcessNode{name='开始'}
      Executing node: ProcessNode{name='审批'}
      Executing node: ProcessNode{name='通知'}
      Executing node: ProcessNode{name='结束'}
     ```
     在客户端测试代码中，我们首先创建了一个 Workflow 对象并添加了几个节点。  
     然后，通过 iterator() 方法获取迭代器，使用 hasNext() 和 next() 方法遍历流程中的节点并执行相关操作。  
     每次调用 next() 都返回一个节点对象，并打印节点的执行信息。    

# 优缺点
  优点：  
  - 简化遍历操作
  - 支持多种遍历方式：通过迭代器，集合的遍历方式可以灵活调整，比如可以用不同的顺序遍历集合，  
    甚至在一些情况下，可以实现反向遍历等功能，增强了系统的灵活性。
  - 避免暴露集合的内部结构

  缺点：  
  - 增加了复杂性
  - 不适合小型集合
  - 只能一次遍历：标准的迭代器模式通常只支持单一方向的遍历，并且在遍历过程中无法回溯。  
    如果需要多次遍历或在遍历过程中进行复杂的状态修改，可能需要额外的管理或更复杂的设计。

# 应用场景
  - 自定义分页组件的数据遍历
  - 流程引擎中的节点遍历 

# 开源框架中的应用
  1. Java  集合框架  
     Java 集合框架对迭代器模式的应用特别典型。我们可以随便打开一个集合类，比如 ArrayList，  
     会发现它实现了 Iterable 接口，里面有个iterator()方法，我们来看下实现的源码：  
     ```java
      public class ArrayList<E> extends AbstractList<E>
              implements List<E>, RandomAccess, Cloneable, java.io.Serializable
            public Iterator<E> iterator() {
              return new Itr();
          }
      
            private class Itr implements Iterator<E> {
              int cursor;       // index of next element to return
              int lastRet = -1; // index of last element returned; -1 if no such
              int expectedModCount = modCount;
      
              Itr() {}
      
              // 负责遍历逻辑
              public boolean hasNext() {
                  // 判断是否还有元素
              }
      
              public E next() {
                  // 返回当前元素，并指向下一个
              }
      
              public void remove() {
                  // 可选操作，移除当前元素
              }
          }
      }
     ```
     这里的iterator()方法返回了一个Itr内部类的实例，它实现了Iterator接口。通过hasNext()和next()我们就可以一步步安全地遍历ArrayList。  

     也就是说，我们不需要知道 ArrayList 是基于数组还是链表，它都提供了统一的遍历方式。HashSet、LinkedList 也是一样的处理逻辑。  
     
