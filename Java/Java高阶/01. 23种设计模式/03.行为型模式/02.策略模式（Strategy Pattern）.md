# 概念
  定义一系列算法，把它们一个个封装起来，并且让它们可以互相替换。  
  为了让大家更好‌地感受到策略模式的作用，以⁢电商折扣计算为例，我们需要‏实现一个灵活的促销系统，支‍持多种折扣方式。  
  让我们来看⁡看使用和不使用策略模式的区别：  

  <img width="1872" height="942" alt="image" src="https://github.com/user-attachments/assets/61e457f2-2c8d-484b-8b67-069f20659400" />

# 基本结构
  1. 策略接‌口（Strateg⁢y）：定义所有支持‏的算法（策略）必须实现‍的方法。                    ——策略的接口
  2. 具体策‌略（Concret⁢eStrategy‏）：实现策略接口，‍封装具体的算法实现⁡。                   ——具体策略类
  3. 上下文‌（Context）⁢：持有一个策略接口‏的引用，负责在业务端选择并执行具⁡体的策略。        ——上下文类
 
  <img width="714" height="708" alt="image" src="https://github.com/user-attachments/assets/cf0b10b3-628f-4a7b-9709-2f95a6236c30" />

# 代码实现
  下面就以 ‌“电商折扣计算” ⁢为例，我们用策略模‏式实现一个灵活的促‍销系统。  

  1. 策略的接口
     ```java
      public interface DiscountStrategy {
          double calculate(double originalPrice);
      }
     ```
     这一步是策‌略模式的核心接口，⁢抽象了“折扣”‏行为。所有促销方式只要‍实现这个接口，就能⁡被系统自由替换调用。  
  2. 具体策略类
     ```java
      public class FullReductionStrategy implements DiscountStrategy {
          @Override
          public double calculate(double originalPrice) {
              if (originalPrice >= 100) {
                  return originalPrice - 20; // 满减
              }
              return originalPrice;
          }
      }
      
      public class PercentageDiscountStrategy implements DiscountStrategy {
          @Override
          public double calculate(double originalPrice) {
              return originalPrice * 0.9; // 打九折
          }
      }
      
      public class VipDiscountStrategy implements DiscountStrategy {
          @Override
          public double calculate(double originalPrice) {
              return originalPrice * 0.8; // VIP 打八折
          }
      }
     ```
     这些类就是‌“策略族”的具体实⁢现，分别封装了不同‏的折扣规则。每种规‍则彼此独立，互不影⁡响。  
  3. 上下文类
     ```java
      public class PriceCalculator {
          private DiscountStrategy strategy;
      
          public void setStrategy(DiscountStrategy strategy) {
              this.strategy = strategy;
          }
      
          public double calculatePrice(double originalPrice) {
              if (strategy == null) {
                  throw new IllegalStateException("未设置折扣策略");
              }
              return strategy.calculate(originalPrice);
          }
      }
     ```
     上下文类 PriceCalculator 用于管理和执行折扣策略的调用逻辑。通过 setStrategy() 注入不同的策略对象，达到行为灵活切换的效果。  
  4. 测试使用
     ```java
      public class Client {
          public static void main(String[] args) {
              PriceCalculator calculator = new PriceCalculator();
              double originalPrice = 120.0;
      
              // 使用满减策略
              calculator.setStrategy(new FullReductionStrategy());
              System.out.println("【满减策略】最终价格：" + calculator.calculatePrice(originalPrice));
      
              // 使用打折策略
              calculator.setStrategy(new PercentageDiscountStrategy());
              System.out.println("【打折策略】最终价格：" + calculator.calculatePrice(originalPrice));
      
              // 使用 VIP 策略
              calculator.setStrategy(new VipDiscountStrategy());
              System.out.println("【VIP策略】最终价格：" + calculator.calculatePrice(originalPrice));
          }
      }
     ```
     输出结果：‌  
     ```java
      【满减策略】最终价格：100.0
      【打折策略】最终价格：108.0
      【VIP策略】最终价格：96.0
     ```
     通过策略模式，PriceCalculator 并不关心折扣如何计算，只关心“调用策略”。  
     这让我们在新增“新人专属满200减50”这类促销时，只需要实现一个新策略类，而无需改动旧逻辑。  

# 优缺点
  优点:  
  - 算法封装
  - 符合开闭原则
  - 避免了多重条件判断

  缺点：
  - 策略类过多
  - 客户端必须了解策略
  - 增加了对象之间的协作

# 应用场景
  - 支付系统中的支付方式选择
  - 折扣计算策略
  - 路线规划算法
  - 日志记录方式选择

# 开源框架中的应用
  1. Spring 框架  
     Spring‌ 里对策略模式的应用非常⁢广泛，尤其是在处理一些“‏多种行为可选”的场景时，‍几乎都可以看到策略模⁡式的场景。我们来看几个例子：  

     org.springframework.beans.factory.support.InstantiationStrategy：  
     这个接口定‌义了 Bean 的⁢实例化策略，不同策‏略实现了不同的实例‍化方式。  
     ```java
      public interface InstantiationStrategy {
          // 实例化指定的 Bean
         	Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner)
      			throws BeansException;
      }
     ```
     Spring 默认提供了两种实现：  
     - CglibSubclassingInstantiationStrategy：使用 CGLIB 动态生成子类进行实例化
     - SimpleInstantiationStrategy：使用默认构造函数或反射直接实例化

     具体调用是在 AbstractAutowireCapableBeanFactory 中进行的：  
     ```java
      Object bean = getInstantiationStrategy().instantiate(bd, null, this);
     ```
     我们可以根据配置或者条件，动态切换不同的实例化策略
     
     org.springframework.core.annotation.MergedAnnotations.SearchStrategy：  
     这个枚举类定义了查找注解时的不同策略，比如：  
     - DIRECT：只查找当前元素上的注解
     - INHERITED_ANNOTATIONS：包括继承的注解
     - SUPERCLASS：在父类中继续查找
     - TYPE_HIERARCHY：在整个类型体系中查找

     这些枚举值就‌代表了不同的“搜索策略⁢”，最终在 Merge‏dAnnotation‍s 的查找逻辑中，会根⁡据这个策略来决定怎么找注解。  

     org.springframework.boot.autoconfigure.condition.SearchStrategy：  
     在 Spr‌ing Boot ⁢的条件装配机制中，‏也定义了一套策略枚‍举，用于控制 Be⁡an 的搜索范围，比如：  
     - ALL：在全局范围查找
     - CURRENT：只在当前上下文中查找
     这些也是典‌型的策略枚举，允许⁢我们根据场景动态控‏制 Bean 的获‍取逻辑  
