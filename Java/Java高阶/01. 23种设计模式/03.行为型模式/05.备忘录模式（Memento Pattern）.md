# 概念
  在不破坏对象封装性的前提下，捕获一个对象的内部状态，并在将来需要的时候能够恢复这个状态。  
  为了让大家更好‌地感受到备忘录模式的作用，⁢以文档编辑器为例，我们需要‏实现一个支持撤销/重做功能‍的文本编辑器。  
  让我们来看看⁡使用和不使用备忘录模式的区别：  

  <img width="1884" height="1388" alt="image" src="https://github.com/user-attachments/assets/55d725cb-9bf8-4f1d-a217-3a7c4ca5209d" />

# 基本结构
  1. 发起人‌（Originat⁢or）：需要保存状‏态的对象，负责创建‍和恢复备忘录。          ——发起人类
  2. 备忘录‌（Memento）⁢：存储发起人的内部‏状态，是一个纯数‍据对象。               ——备忘录类
  3. 管理者（C‌aretaker）：负责保⁢存备忘录对象，但不直接操作‏备忘录的内容。       ——管理者类

  <img width="1208" height="630" alt="image" src="https://github.com/user-attachments/assets/30ae3540-7eeb-4e89-889a-431a28f917c9" />

# 代码实现
  下面就以 ‌“文档编辑器撤销/⁢重做” 功能为例，‏我们用 备忘录模式‍ 实现一个简单的文⁡本编辑器。  
  
  1. 备忘录类
     ```java
      public class DocumentMemento {
          private String content;
      
          public DocumentMemento(String content) {
              this.content = content;
          }
      
          public String getContent() {
              return content;
          }
      }
     ```
     备忘录类（DocumentMemento）保存了文档的内容，它只提供读取的功能，不允许外部修改，确保了封装性。  
  2. 发起人类
     ```java
      public class Document {
          private String content;
      
          public Document(String content) {
              this.content = content;
          }
      
          public void setContent(String content) {
              this.content = content;
          }
      
          public String getContent() {
              return content;
          }
      
          public DocumentMemento save() {
              return new DocumentMemento(this.content);
          }
      
          public void restore(DocumentMemento memento) {
              this.content = memento.getContent();
          }
      }
     ```
     文档类（Document）拥有 save 和 restore 方法，用来创建和恢复文档的状态。  
     每次编辑文档后，可以保存当前状态，若需要撤销，则通过 restore 方法恢复到之前的状态。  
  3. 管理者类
     ```java
      public class History {
          private Stack<DocumentMemento> history = new Stack<>();
          private Stack<DocumentMemento> redoStack = new Stack<>();
      
          public void pushMemento(DocumentMemento memento) {
              history.push(memento);
              redoStack.clear(); // 每次新操作时清空重做栈
          }
      
          public DocumentMemento popMemento() {
              if (!history.isEmpty()) {
                  DocumentMemento memento = history.pop();
                  redoStack.push(memento);
                  return memento;
              }
              return null;
          }
      
          public DocumentMemento popRedoMemento() {
              if (!redoStack.isEmpty()) {
                  DocumentMemento memento = redoStack.pop();
                  history.push(memento);
                  return memento;
              }
              return null;
          }
      }
     ```
     History 类负责管理所有文档的历史状态。它保存了撤销操作和重做操作的栈，并通过 pushMemento 和 popMemento 方法来管理文档的历史记录。  
  4. 测试使用
     ```java
      public class Client {
          public static void main(String[] args) {
              Document document = new Document("初始内容");
              History history = new History();
      
              // 保存初始状态
              history.pushMemento(document.save());
              System.out.println("文档内容: " + document.getContent());
      
              // 修改文档内容
              document.setContent("第一次编辑");
              history.pushMemento(document.save());
              System.out.println("文档内容: " + document.getContent());
      
              // 修改文档内容
              document.setContent("第二次编辑");
              history.pushMemento(document.save());
              System.out.println("文档内容: " + document.getContent());
      
              // 撤销
              document.restore(history.popMemento());
              System.out.println("撤销后文档内容: " + document.getContent());
      
              // 再次撤销
              document.restore(history.popMemento());
              System.out.println("再次撤销后文档内容: " + document.getContent());
      
              // 重做
              document.restore(history.popRedoMemento());
              System.out.println("重做后文档内容: " + document.getContent());
          }
      }
     ```
     输出结果：  
     ```java
      文档内容: 初始内容
      文档内容: 第一次编辑
      文档内容: 第二次编辑
      撤销后文档内容: 第一次编辑
      再次撤销后文档内容: 初始内容
      重做后文档内容: 第一次编辑
     ```
     这个例子就是使用备忘录模式来简单实现文档的撤销和重做功能。每次编辑都生成一个新的状态快照，并通过 History 类管理这些状态。    
     用户可以在编辑过程中随时撤销或重做，方便地回到历史状态.    
      
# 优缺点
  优点: 
  - 支持撤销操作
  - 实现回退操作
  - 封装性强

  缺点：  
  - 内存开销大
  - 增加了系统复杂度
  - 恢复状态时有限制

# 应用场景
  - 文档编辑器的撤销/重做功能
  - 游戏存档功能
  - 图形绘图软件的操作记录

# 开源框架中的应用
  1. JDK 的 Swing 框架中 javax.swing.undo.UndoManager。  
     在 Java 的 Swing 框架中，有一个非常典型的备忘录模式实现，就是 javax.swing.undo.UndoManager。  

     我们先看下这个类的主要‌作用——它用于管理一系列可撤销的编辑操作。  
     每⁢当我们对文档进行一次修改（比如输入文字、删除‏、粘贴等），这个类就会自动创建一个“备忘录”‍来保存当前的状态。  
     这样后续就可以支持 Und⁡o（撤销） 和 Redo（重做） 操作。  

     我们看下源码：  
     ```java
      public class UndoManager extends CompoundEdit implements UndoableEditListener {
      
      
      
          // 执行撤销操作
          public synchronized void undo() throws CannotUndoException {
              if (inProgress) {
                  UndoableEdit edit = editToBeUndone();
                  if (edit == null) {
                      throw new CannotUndoException();
                  }
                  undoTo(edit);
              } else {
                  super.undo();
              }
          }
          // 执行重做操作
          public synchronized void redo() throws CannotRedoException {
              if (inProgress) {
                  UndoableEdit edit = editToBeRedone();
                  if (edit == null) {
                      throw new CannotRedoException();
                  }
                  redoTo(edit);
              } else {
                  super.redo();
              }
          }
      }
      // CompoundEdit 表示一组编辑操作的组合，它自身也可以作为一个编辑操作
      public class CompoundEdit extends AbstractUndoableEdit {
          // 用于保存所有的子编辑操作（每次用户编辑都会作为一个 UndoableEdit 加入这个列表）
          protected Vector<UndoableEdit> edits;
      
          public CompoundEdit() {
              super();
              inProgress = true;
              edits = new Vector<UndoableEdit>();
          }
      }
     ```
     这个结构其‌实就很符合备忘录模⁢式：  
     - UndoableEdit 相当于备忘录，封装了某一时刻的状态变化；
     - UndoManager 是管理者，负责保存和恢复备忘录；
     - 客户端（比如文本编辑器）是发起人，只要把操作提交给 UndoManager，它来负责存档和回退。

     我们可以用一张类图来表示下结构：  
     <img width="996" height="1552" alt="image" src="https://github.com/user-attachments/assets/e5f3d824-c92b-4ea5-94f5-a2baaa6e7098" />
