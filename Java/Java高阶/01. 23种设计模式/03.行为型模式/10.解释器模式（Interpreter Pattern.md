# 概念
  为特定类型的语言提供解释执行的方法。  
  为了让大家更好‌地感受到解释器模式的作用，⁢以规则引擎为例，我们需要实‏现一个能够解析和执行自定义规则‍的系统。  
  让我们来看看使⁡用和不使用解释器模式的区别：  

  <img width="1894" height="952" alt="image" src="https://github.com/user-attachments/assets/23b0b48b-bc4b-48d3-b883-9335831351f8" />

# 基本结构
  1. 抽象表达式（AbstractExpression）：定义所有解释器的通用接口，通常包含一个interpret()方法，负责解释和计算表达式。  ——表达式的接口
  2. 终结符表达式（TerminalExpression）：实现interpret()方法的具体类，表示具体的语法元素。这些元素是无法再分解的最小单位。  ——具体终结符表达式类
  3. 非终结符表‌达式（NonTerminal⁢Expression）：与终‏结符表达式不同，它们用于表示‍语言中的组合元素，可以包含其⁡他表达式作为其子表达式。  ——具体非终结符表达式类
  4. 上下文‌（Context）⁢：包含了解释过程中‏所需要的数据，例如‍变量的值或当前的环⁡境。           ——上下文类
  5. 业务端‌：⁢业务端负责构建并初‏始化解释器中的表达‍式，给定输入后，启动⁡解释过程。

  <img width="1106" height="706" alt="image" src="https://github.com/user-attachments/assets/84a86808-6e07-4d3e-9526-4822e608c202" />

# 代码实现
  下面就以 “自定义规则引擎” 为例，我们用解释器模式实现一个简单的规则引擎，能够动态解析并执行类似 age > 18 && score < 500 这样的规则表达式。    

  1. 表达式的接口
     ```java
      interface Expression {
          boolean interpret(Context context);  // 解释表达式，返回布尔值
      }
     ```
     先定义一个 Expression 接口，其中的 interpret() 方法用来解释规则表达式并返回布尔值结果。  
     interpret() 接受 Context 作为参数，Context 中保存了规则的上下文信息（如 age 和 score）。  
  2. 上下文类
     ```java
      class Context {
          private int age;
          private int score;
      
          public Context(int age, int score) {
              this.age = age;
              this.score = score;
          }
      
          public int getAge() {
              return age;
          }
      
          public int getScore() {
              return score;
          }
      }
     ```
     Context 类用于保存规则所需的上下文信息，像 age 和 score 这样的变量可以动态传递给规则引擎。  
  3. 具体终结符表达式类
     ```java
      class GreaterThanExpression implements Expression {
          private String field;
          private int value;
      
          public GreaterThanExpression(String field, int value) {
              this.field = field;
              this.value = value;
          }
      
          @Override
          public boolean interpret(Context context) {
              if ("age".equals(field)) {
                  return context.getAge() > value;
              } else if ("score".equals(field)) {
                  return context.getScore() > value;
              }
              return false;
          }
      }
      
      class LessThanExpression implements Expression {
          private String field;
          private int value;
      
          public LessThanExpression(String field, int value) {
              this.field = field;
              this.value = value;
          }
      
          @Override
          public boolean interpret(Context context) {
              if ("age".equals(field)) {
                  return context.getAge() < value;
              } else if ("score".equals(field)) {
                  return context.getScore() < value;
              }
              return false;
          }
      }
     ```
     GreaterThanExpression 和 LessThanExpression 类是具体的规则表达式，分别判断某个字段（如 age 或 score）是否大于或小于某个值。  
  4. 具体非终结符表达式类
     ```java
      class AndExpression implements Expression {
          private Expression expr1;
          private Expression expr2;
      
          public AndExpression(Expression expr1, Expression expr2) {
              this.expr1 = expr1;
              this.expr2 = expr2;
          }
      
          @Override
          public boolean interpret(Context context) {
              return expr1.interpret(context) && expr2.interpret(context);
          }
      }
     ```
     AndExpression 用来组合两个表达式，表示逻辑“与”操作。  
  5. 解析动态输入的规则表达式类
     ```java
      class RuleParser {
          public static Expression parse(String rule) {
              String[] tokens = rule.split("&&");  // 按“&&”分割表达式
              Expression left = null;
              Expression right = null;
      
              for (String token : tokens) {
                  token = token.trim();
                  if (token.contains(">")) {
                      String[] parts = token.split(">");
                      String field = parts[0].trim();
                      int value = Integer.parseInt(parts[1].trim());
                      left = new GreaterThanExpression(field, value);
                  } else if (token.contains("<")) {
                      String[] parts = token.split("<");
                      String field = parts[0].trim();
                      int value = Integer.parseInt(parts[1].trim());
                      right = new LessThanExpression(field, value);
                  }
              }
              return new AndExpression(left, right);  // 合并左右表达式
          }
      }
     ```
     RuleParser 类实现了规则字符串的解析。它能够灵活地解析动态输入的规则表达式（例如 "age > 18 && score < 600"），  
     通过拆分符号来确定每个表达式的类型（如大于、小于等）。  
  6. 测试使用
     ```java
      public class Client {
          public static void main(String[] args) {
              // 用户输入的动态规则
              String rule = "age > 18 && score < 500";
      
              // 创建上下文对象
              Context context = new Context(20, 450);  // 假设 age = 20, score = 450
      
              // 解析规则表达式
              Expression expression = RuleParser.parse(rule);
      
              // 判断规则是否成立
              boolean result = expression.interpret(context);
              System.out.println("表达式结果: " + result);  // 输出结果
          }
      }
     ```
     输出结果：  
     ```java
      表达式结果: true
     ```
     使用解释器模式，我们可以动态解析并执行业务规则表达式。  
     用户输入的规则（如 age > 18 && score < 500）会被解析为一棵语法树，规则引擎会逐个判断每个表达式，最终得出一个布尔结果。  

# 优缺点
  优点:
  - 容易扩展：解释器模式通过使用递归结构，能够方便地扩展新的语法规则。只要有新的语法需求，就可以在原有基础上添加新的解释器类，保持系统的扩展性。
  - 清晰的结构：这种模式将不同的语法规则（>, < 等）和解释逻辑分开，使得整个解析过程非常清晰易懂。
  - 灵活性高

  缺点：
  - 类的数量过多
  - 性能问题
  - 不适合简单场景

# 应用场景
  - 自定义规则引擎
  - DSL（领域特定语言）解析
  - 表达式解析：在实现计算器、权限表达式（如 hasRole('admin') && isAuthenticated()）、公式引擎等场景中，经常需要解析并计算一类语法表达式。
    解释器模式通过构建抽象语法树（AST），递归地解释每个节点，从而支持灵活的表达式解析与扩展，便于后续添加新运算符或函数，保持系统的可维护性与可扩展性。

# 开源框架中的应用
  1. Spring 框架中  SpEL（Spring Expression Language）  
     Spring 框架中用得比较明显的是 SpEL（Spring Expression Language），也就是 Spring 自己的一套表达式语言系统。这个东西哪里有用到呢？  
     比如 @Value 注解里动态注入值，或者是 Spring Security 的访问权限判断逻辑，都可以通过 SpEL 表达式来动态控制。  

     我们写个例子看下：  
     ```java
      ExpressionParser parser = new SpelExpressionParser();
      Expression expression = parser.parseExpression("1 + 2 * 3");
      Integer result = expression.getValue(Integer.class); // 输出：7
     ```
     这里的 SpelExpressionParser 就相当于解析器，它把字符串 "1 + 2 * 3" 解析成一棵内部的语法树，然后 getValue 方法就是解释并执行这棵树。  

     我们来看下‌源码：  
     ```java
      /**
      * 表达式解析器接口，负责将原始的表达式字符串解析为可执行的 Expression 对象
      */
      public interface ExpressionParser {
      
          /**
      	 * 解析表达式字符串，返回一个可用于计算的 Expression 对象。
      	 */
          Expression parseExpression(String expressionString) throws ParseException;
      
          /**
      	 * 解析表达式字符串，允许指定解析上下文（ParserContext）。
      	 */
          Expression parseExpression(String expressionString, ParserContext context) throws ParseException;
      
      }
     ```
     ```java
      /**
       * 表达式接口，表示一个已经解析好的、可以被执行的表达式。
       * 
       * 通常由 ExpressionParser 解析得到，调用 getValue 方法可以计算表达式的结果。
       */
      public interface Expression {
      
          /**
          * 在指定的上下文中执行表达式，并将结果转换为指定类型
          */
          <T> T getValue(EvaluationContext context, @Nullable Class<T> desiredResultType) throws EvaluationException;
      }
     ```
     SpEL 的解释流程，大概可以分为三步:  
     1. 解析表‌达式（语法分析）
     2. 生成表达式‏树（语义分析）
     3. 解释表达式（⁡求值）
    
     我们来看下主要的结构类图：  
     <img width="3060" height="1372" alt="image" src="https://github.com/user-attachments/assets/106a3bdb-3194-498c-a2dd-8404a1cb9e95" />

     其中：  
     - SpelExpressionParser 就是我们平时用来构造表达式的；
     - SpelExpression 是表达式对象，封装了抽象语法树（AST）；
     - SpelNodeImpl 是具体的 AST 节点，负责解释每一个子表达式。
    
     整个结构就‌非常符合解释器模式⁢的典型架构：一个表‏达式对象 + 一棵‍语法树 + 一个解释执⁡行的过程。  

  2. JDK 中 java.util.regex 包  
     解释器模式在 JDK 中最经典的应用就是正则表达式，也就是 java.util.regex 包。  

     我们平时写的正则‌表达式，其实背后就是在定义一套⁢“语法规则”，然后通过某些类来‏“解释”这个规则，并应用到具体的字‍符串上。  
     整个流程就和解释器⁡模式的结构非常吻合：  
     我们先定义一个文法（比如 [a-z]{3}\d+），再用一个解释器来解析它、执行它。  

     JDK 中主要有两个类：  
     - Pattern：表示正则表达式，是对文法规则的封装；
     - Matcher：负责将表达式应用到某个目标字符串上，判断是否匹配、提取子串等。
    
     我们来看段例子：  
     ```java
      // 编译阶段：将表达式转成内部表示结构
      Pattern pattern = Pattern.compile("[a-z]{3}\\d+");
       // 解释阶段：应用规则进行匹配
      Matcher matcher = pattern.matcher("abc123");      
      
      if (matcher.matches()) {
          System.out.println("匹配成功");
      }
     ```
     这里 Pattern.compile() 其实是在“解释”正则字符串，构建对应的表达式结构。而 matcher.matches() 则是在用这个结构对输入字符串进行解释、匹配。  

     再来看下 Pattern 的部分源码：  
     ```java
      /**
       * Java 中正则表达式的核心类，表示一个编译后的正则表达式模式。
       */
      public final class Pattern implements java.io.Serializable {
      
          // 正则表达式编译后形成的状态机结构的起始节点
          // Node 是内部使用的抽象语法树结构，用于表示正则表达式的执行逻辑
          transient Node root;
      
          // 其他字段（如 pattern、flags、matchRoot、capturingGroupCount、localCount 等）省略...
      
          /**
           * 编译给定的正则表达式为 Pattern 对象。
           */
          public static Pattern compile(String regex) {
              return new Pattern(regex, 0);
          }
      
          /**
           * 构造函数，执行正则表达式的编译过程。
           */
          private Pattern(String p, int f) {
              pattern = p;
              flags = f;
              // 省略部分代码...
              if (pattern.length() > 0) {
                  try {
                      // 正则编译的核心逻辑，会构建 Node 状态机
                      compile();
                  } catch (StackOverflowError soe) {
                      throw error("Stack overflow during pattern compilation");
                  }
              } else {
                  // 空字符串时，构造一个直接可接受的起始节点
                  root = new Start(lastAccept);
                  matchRoot = lastAccept;
              }
          }
      }
     ```
     内部用 Node 节点构建出一颗表达式语法树，每个节点代表一种语法规则，比如字符匹配、数量重复、分组等等。我们来看下类图结构：  
     <img width="1444" height="1932" alt="image" src="https://github.com/user-attachments/assets/a9bf6cd8-128f-41f2-894a-fdd4b442bb65" />
