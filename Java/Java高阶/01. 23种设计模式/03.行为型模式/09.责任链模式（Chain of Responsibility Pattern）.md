# 概念
  将多个处理请求的对象连接成一条链，每个对象在链上依次处理请求，直到有对象处理完请求为止。  
  为了让大家更好‌地感受到责任链模式的作用，⁢以订单优惠处理为例，我们需‏要实现一个支持多种优惠策略‍的系统。  
  让我们来看看使用和⁡不使用责任链模式的区别：  

  <img width="1892" height="1124" alt="image" src="https://github.com/user-attachments/assets/4f21cc8a-75fa-4543-959b-05314d796859" />

# 基本结构
  1. 抽象处理者（Handler）：声明一个处理请求的接口，通常包括一个方法handleRequest()，并且持有对下一个处理者的引用。    ——处理者的接口
  2. 具体处理者‌（ConcreteHand⁢ler）：实现抽象处理者的‏处理方法，如果当前对象能够‍处理请求，就处理它；否则，⁡将请求转发给链上的下一个对象   ——具体处理者类
  3. 业务端‌：业务端负责构造责任链并‏发送请求，它不需要关‍心请求如何被处理，只⁡需要向责任链传递请求即可。  

  <img width="1030" height="650" alt="image" src="https://github.com/user-attachments/assets/7e7f1477-bb1f-4a84-a6a8-96b6a931158e" />

# 代码实现
  下面就以 ‌“订单优惠处理” ⁢为例，我们用责任链‏模式实现一个简单的‍订单优惠系统。    

  1. 处理者的接口
     ```java
      interface DiscountHandler {
          void setNextHandler(DiscountHandler handler);  // 设置下一个处理器
          void applyDiscount(Order order); // 应用优惠策略
      }
     ```
     在这段代码中，我们定义了一个 DiscountHandler 接口，表示优惠处理的抽象类。  
     每个优惠处理器需要实现 applyDiscount() 方法来处理订单优惠，同时通过 setNextHandler() 方法设置责任链中的下一个处理节点。  
  2. 具体处理者类
     ```java
      class FullReductionDiscountHandler implements DiscountHandler {
          private DiscountHandler nextHandler;  // 下一个处理器
      
          @Override
          public void setNextHandler(DiscountHandler handler) {
              this.nextHandler = handler;
          }
      
          @Override
          public void applyDiscount(Order order) {
              if (order.getAmount() > 200) {
                  System.out.println("满减折扣: -50");
                  order.setAmount(order.getAmount() - 50);
              }
              if (nextHandler != null) {
                  nextHandler.applyDiscount(order);  // 继续传递给下一个处理器
              }
          }
      }
      
      class CouponDiscountHandler implements DiscountHandler {
          private DiscountHandler nextHandler;
      
          @Override
          public void setNextHandler(DiscountHandler handler) {
              this.nextHandler = handler;
          }
      
          @Override
          public void applyDiscount(Order order) {
              if (order.hasCoupon()) {
                  System.out.println("优惠券折扣: -30");
                  order.setAmount(order.getAmount() - 30);
              }
              if (nextHandler != null) {
                  nextHandler.applyDiscount(order);
              }
          }
      }
      
      class MemberDiscountHandler implements DiscountHandler {
          private DiscountHandler nextHandler;
      
          @Override
          public void setNextHandler(DiscountHandler handler) {
              this.nextHandler = handler;
          }
      
          @Override
          public void applyDiscount(Order order) {
              if (order.isMember()) {
                  System.out.println("会员折扣: -20");
                  order.setAmount(order.getAmount() - 20);
              }
              if (nextHandler != null) {
                  nextHandler.applyDiscount(order);
              }
          }
      }
     ```
     在这段代码中，我们实现了三个具体的优惠处理类：FullReductionDiscountHandler（满减优惠）、CouponDiscountHandler（优惠券优惠）  
     和 MemberDiscountHandler（会员优惠）。每个类都有 applyDiscount() 方法来执行相应的优惠逻辑，并通过责任链将处理过程传递下去。  
  3. 业务端
     ```java
      class Order {
          private double amount;  // 订单金额
          private boolean hasCoupon;  // 是否使用了优惠券
          private boolean isMember;  // 是否为会员
      
          public Order(double amount, boolean hasCoupon, boolean isMember) {
              this.amount = amount;
              this.hasCoupon = hasCoupon;
              this.isMember = isMember;
          }
      
          public double getAmount() {
              return amount;
          }
      
          public void setAmount(double amount) {
              this.amount = amount;
          }
      
          public boolean hasCoupon() {
              return hasCoupon;
          }
      
          public boolean isMember() {
              return isMember;
          }
      }
     ```
     在这段代码中，我们定义了一个 Order 类，包含订单的金额、是否使用了优惠券以及是否是会员的标志。  
     通过这些字段，优惠处理类可以判断是否应用相应的优惠  
  4. 测试使用
     ```java
      public class Client {
          public static void main(String[] args) {
              Order order = new Order(250, true, true);  // 创建订单
      
              // 创建各个优惠处理器
              DiscountHandler fullReductionHandler = new FullReductionDiscountHandler();
              DiscountHandler couponHandler = new CouponDiscountHandler();
              DiscountHandler memberHandler = new MemberDiscountHandler();
      
              // 设置责任链：优惠处理器依次连接
              fullReductionHandler.setNextHandler(couponHandler);
              couponHandler.setNextHandler(memberHandler);
      
              // 开始应用优惠
              fullReductionHandler.applyDiscount(order);  // 从满减开始处理
              System.out.println("最终订单金额: " + order.getAmount());
          }
      }
     ```
     输出结果：  
     ```java
      满减折扣: -50
      优惠券折扣: -30
      会员折扣: -20
      最终订单金额: 150.0
     ```
     在客户端测试中，首先创建一个订单对象，并依次创建了满减、优惠券、会员优惠处理器。通过 setNextHandler() 方法将它们链接成一个责任链。  
     最后，通过调用 applyDiscount() 方法开始依次处理订单的各项优惠，最终得到处理后的订单金额。  
     
# 优缺点
  优点:  
  - 减少了耦合性
  - 灵活的请求处理方式
  - 可扩展性强

  缺点：  
  - 不容易调试
  - 可能造成性能问题
  - 责任链的管理复杂性

# 应用场景
  - 用户请求的权限校验流程
  - 电商系统的订单优惠处理
  - 内容审核系统中的多级规则过滤

# 开源框架中的应用
  1. Spring 框架中 HandlerInterceptor 的链式执行  
     在 Spring 中，HandlerInterceptor 的链式执行也是责任链模式的体现。  

     Intercept‌or 拦截器其实跟 Filter ⁢有点像，它们都可以在请求前后做一些‏操作。  
     但是 Interceptor‍ 是更靠近 Spring MVC ⁡的，它作用于控制器的调用过程。  

     我们可以看下 HandlerExecutionChain 是怎么实现责任链的：  
     ```java
      /**
       * 表示一个处理器执行链，包含实际的处理器对象（如 Controller 方法）和一组拦截器。
       * 每个请求会对应一个 HandlerExecutionChain。
       */
      public class HandlerExecutionChain {
      
          // 实际执行的处理器对象，比如某个 Controller 方法
          private final Object handler;
      
          // 拦截器列表，用于在 handler 执行前后进行拦截处理
          private final List<HandlerInterceptor> interceptors = new ArrayList<>();
      
          // 记录已成功执行 preHandle 的拦截器索引，用于 afterCompletion 回调时回退调用
          private int interceptorIndex = -1;
      
          /**
           * 执行所有拦截器的 preHandle 方法（按顺序）。
           * 如果有一个返回 false，表示请求被拦截，中断后续流程。
           * 
           * @return true 表示继续处理请求；false 表示中断处理流程
           */
          boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception {
              for (int i = 0; i < this.interceptors.size(); i++) {
                  HandlerInterceptor interceptor = this.interceptors.get(i);
                  // 如果拦截器返回 false，触发 afterCompletion 回调，并中止处理
                  if (!interceptor.preHandle(request, response, this.handler)) {
                      triggerAfterCompletion(request, response, null);
                      return false;
                  }
                  // 记录已成功执行的拦截器索引
                  this.interceptorIndex = i;
              }
              return true;
          }
      
          /**
           * 在 handler 执行完之后，调用所有拦截器的 postHandle 方法（按倒序）。
           */
          void applyPostHandle(HttpServletRequest request, HttpServletResponse response, @Nullable ModelAndView mv)
                  throws Exception {
              for (int i = this.interceptors.size() - 1; i >= 0; i--) {
                  HandlerInterceptor interceptor = this.interceptors.get(i);
                  interceptor.postHandle(request, response, this.handler, mv);
              }
          }
      
          // 假设还有一个 triggerAfterCompletion 方法，负责触发所有拦截器的 afterCompletion 回调（按倒序）
      }
     ```
     每个 Interceptor 可以在控制器执行前进行预处理（preHandle），也可以在控制器执行后进行后置处理（postHandle）。  
     如果有一个 Interceptor 决定不放行，整个链条就会被中断。  

     我们通过类图来简单看下结构：  
     <img width="1696" height="1668" alt="image" src="https://github.com/user-attachments/assets/9239d47b-51ee-4733-9d03-fcce93c460a8" />

  2. JDK 中 Servlet 规范里的 Filter 链（FilterChain）  
     在 JDK 中，Servlet 规范里的 Filter 链（FilterChain）就是责任链模式的一个经典实现场景。  

     我们可以简单回顾一下 Se‌rvlet 中请求是怎么被处理的：请求到达服务器之后⁢，首先会经过我们配置的一系列过滤器，  
     每个过滤器都可以‏决定是否继续往下传递请求，或者中断整个链条。这就是责‍任链的核心思想 —— 一条链条上挂着多个处理节点，  
     每⁡个节点都有“放行”或“拦截”的能力。  

     我们看下源码：  
     ```java
      /**
       * ApplicationFilterChain 是 Servlet 规范中的过滤器链实现类。
       * 它负责按顺序调用多个 Filter，然后最终调用目标 Servlet。
       */
      public final class ApplicationFilterChain implements FilterChain {
      
          // 存储过滤器配置的数组，每个元素对应一个 Filter
          private ApplicationFilterConfig[] filters = new ApplicationFilterConfig[0];
      
          // 当前正在执行的过滤器索引（指针）
          private int pos = 0;
      
          // 实际过滤器数量
          private int n = 0;
      
          /**
           * 过滤器链的核心执行方法。
           * 会依次调用链中的每个 Filter 的 doFilter 方法，
           * 最后调用目标 Servlet 的 service 方法。
           */
          @Override
          public void doFilter(ServletRequest request, ServletResponse response)
              throws IOException, ServletException {
      
              // 如果启用了 Java 安全管理器（SecurityManager），则以特权操作执行过滤器链
              if (Globals.IS_SECURITY_ENABLED) {
                  final ServletRequest req = request;
                  final ServletResponse res = response;
                  try {
                      // 使用 AccessController 执行受限操作
                      java.security.AccessController.doPrivileged(
                          (java.security.PrivilegedExceptionAction<Void>) () -> {
                              // 实际执行过滤器链逻辑
                              internalDoFilter(req, res);
                              return null;
                          }
                      );
                  } catch (PrivilegedActionException pe) {
                    // 省略代码...
                  }
              } else {
                  // 没有启用安全机制时，直接执行过滤器链
                  internalDoFilter(request, response);
              }
          }
      
          // 省略 internalDoFilter 方法（通常用于实际按顺序调用过滤器和 Servlet）
      }
     ```
     每个过滤器内部的 doFilter 方法都有一个 FilterChain 参数，这个参数的作用就是让过滤器有能力“放行”到下一个过滤器。  

     也就是说，‌责任链模式在这里的实⁢现是通过递归或者迭代‏的方式，把请求逐步传‍递给下一个责任节点（⁡过滤器），每个节点各司其职。  

     我们可以用一张类图来简化这个结构  
     <img width="2892" height="1980" alt="image" src="https://github.com/user-attachments/assets/63700698-0b41-438b-9849-1896381ded81" />
