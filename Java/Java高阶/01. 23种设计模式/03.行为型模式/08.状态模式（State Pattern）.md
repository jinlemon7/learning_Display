# 概念
  允许对象在内部状态变化时，改变它的行为，看起来就像是对象本身发生了变化一样。  
  为了让大家更好‌地感受到状态模式的作用，以⁢订单状态流转管理为例，我们‏需要实现一个支持订单状态转换‍的系统。  
  让我们来看看使用⁡和不使用状态模式的区别：  

  <img width="1882" height="1152" alt="image" src="https://github.com/user-attachments/assets/4b74c7aa-0e85-4f78-8f6b-dc9e87a016d4" />

# 基本结构
  1. 环境类‌（Context）⁢：持有当前状态对象‏，负责状态的切换，‍同时对外暴露统一的⁡行为接口。          ——环境类
  2. 抽象状‌态类（State）⁢：定义所有具体状态‏需要实现的接口或者‍抽象类。                          ——状态的抽象
  3. 具体状态‌类（ConcreteSt⁢ate）：实现抽象状态定‏义的行为，每个具体状态类‍封装了对应的操作逻辑，并⁡且可以决定是否切换到其他状态。   ——具体状态类

  <img width="852" height="712" alt="image" src="https://github.com/user-attachments/assets/979cdd8b-7ccc-4e58-88f1-c42aaed496e3" />

# 代码实现
  下面就以 ‌“订单状态流转管理⁢” 为例，我们用状‏态模式实现一个简单‍的订单管理系统。  

  1. 状态的抽象
     ```java
      interface OrderState {
          void handleRequest(Order order); // 处理订单请求，根据不同状态执行不同操作
      }
     ```
     在这段代码中，我们定义了一个 OrderState 接口，表示订单的不同状态。  
     该接口有一个 handleRequest() 方法，负责处理订单的不同操作，不同的状态类会提供不同的实现。  
  2. 具体状态类
     ```java
      class PendingState implements OrderState {
          @Override
          public void handleRequest(Order order) {
              System.out.println("订单处于待支付状态，请支付。");
              order.setState(new PaidState()); // 支付完成后，改变订单状态为已支付
          }
      }
      
      class PaidState implements OrderState {
          @Override
          public void handleRequest(Order order) {
              System.out.println("订单已支付，请发货。");
              order.setState(new ShippedState()); // 发货后，改变订单状态为已发货
          }
      }
      
      class ShippedState implements OrderState {
          @Override
          public void handleRequest(Order order) {
              System.out.println("订单已发货，请等待接收。");
              order.setState(new CompletedState()); // 完成后，改变订单状态为已完成
          }
      }
      
      class CompletedState implements OrderState {
          @Override
          public void handleRequest(Order order) {
              System.out.println("订单已完成。");
          }
      }
     ```
     在这里，我们为每种订单状态实现了一个具体的状态类。  
     每个状态类都实现了 OrderState 接口的 handleRequest() 方法，具体的操作会根据当前状态执行相应的逻辑。  
  3. 环境类
     ```java
      class Order {
          private OrderState state;
      
          public Order() {
              this.state = new PendingState(); // 初始状态为“待支付”
          }
      
          public void setState(OrderState state) {
              this.state = state;
          }
      
          public void request() {
              state.handleRequest(this); // 调用当前状态的处理方法
          }
      }
     ```
     在这段代码中，我们定义了一个 Order 类，它包含了一个 OrderState 类型的成员变量 state，表示当前订单的状态。  
     setState() 方法用于改变订单状态，request() 方法用于调用当前状态的处理方法。  
  4. 测试使用
     ```java
      public class Client {
          public static void main(String[] args) {
              Order order = new Order();  // 创建一个订单
      
              // 客户端操作：订单请求
              order.request();  // 初始状态是“待支付”
      
              // 模拟状态流转
              order.request();  // 订单支付后，进入“已支付”状态
              order.request();  // 订单发货后，进入“已发货”状态
              order.request();  // 订单完成后，进入“已完成”状态
          }
      }
     ```
     输出结果：  
     ```java
      订单处于待支付状态，请支付。
      订单已支付，请发货。
      订单已发货，请等待接收。
      订单已完成。
     ```
     在客户端测试代码中，我们首先创建了一个 Order 对象，该对象初始状态为“待支付”。  
     然后通过调用 request() 方法，模拟订单状态的流转。每次调用 request() 方法时，都会根据当前的状态执行相应的操作，并转到下一个状态。  

# 优缺点
  优点：  
  - 简化复杂条件语句
  - 易于扩展
  - 行为的局部化

  缺点：
  - 类的数量增加
  - 状态之间的转换复杂
  - 容易过度设计

# 应用场景
  - 订单状态流转管理
  - 流程审批系统中的节点控制
  - 用户账号的权限控制

# 开源框架中的应用
  1. Spring 框架中  Spring State Machine（SSM）  
     Spring 里比较典型的状态模式应用是 Spring State Machine（SSM）。  
     这个组件专门为状态驱动型的业务设计，比如订单从“待支付”到“已支付”，再到“已发货”、“已收货”，中间可能还有“退款”、“关闭”等状态，  
     每种状态之间的切换都会触发不同的行为。  

     在 Spring State Machine 中，主要的核心接口是 StateMachine<S, E>，S 表示状态类型，E 表示事件类型。  
     整个框架围绕“状态 + 事件 + 转换”三大块展开。  

     我们来看一下源码的核心类：  
     ```java
      /**
       * 状态机接口，定义了状态机的基本操作。
       * 
       */
      public interface StateMachine<S, E> {
      
          /**
           * 获取当前状态机所处的状态。
           */
          State<S, E> getState();
      
          /**
           * 向状态机发送一个事件，用于触发状态转换。
           * 
           */
          void sendEvent(E event);
      
          /**
           * 启动状态机，进入初始状态。
           */
          void start();
      
          /**
           * 停止状态机，通常用于清理资源或退出状态控制流程。
           */
          void stop();
      }
     ```
     每个状态的行为通过实现 State<S, E> 接口来定义，比如进入状态、退出状态时要做什么事情:   
     ```java
      /**
       * 表示状态机中的一个具体状态。
       *
       */
      public interface State<S, E> {
      
          /**
           * 获取当前状态的唯一标识。
           */
          S getId();
      
          /**
           * 进入该状态时执行的逻辑，通常用于初始化、打印日志或发出通知等操作。
           */
          void onEntry();
      
          /**
           * 退出该状态时执行的逻辑，通常用于清理资源或记录状态变化等操作。
           */
          void onExit();

      }
     ```
     而状态之间的切换是由 Transition<S, E> 管理的：  
     ```java
      /**
       * 表示状态机中的一次状态迁移（Transition），
       * 包含源状态、目标状态和触发此次迁移的事件。
       */
      public interface Transition<S, E> {
      
          /**
           * 获取迁移的起始状态（源状态）。
           */
          State<S, E> getSource();
      
          /**
           * 获取迁移的目标状态。
           */
          State<S, E> getTarget();
      
          /**
           * 获取触发此次状态迁移的事件。
           */
          E getTriggerEvent();
      }
     ```
     我们可以通过一张类图来看下这个结构：  
     <img width="1232" height="1908" alt="image" src="https://github.com/user-attachments/assets/7d7c8b9b-cf26-490c-a864-37082df2ef0d" />

     可以看到，Spri‌ng State Machine ⁢的设计非常符合状态模式的核心思想：‏将状态封装成对象，  
     每个状态之间的转‍换由 Transition 管理，⁡每种状态的行为独立开来，互不干扰。  
