# 概念
  通过复制现有的对象来创建新对象，而不是通过“new”关键字来直接实例化,从而减少了重复构建相同对象的成本。  
  为了让大家更好地‌感受到原型模式的作用，以文档编⁢辑系统为例，我们需要创建文档的‏副本，并允许用户对副本进行修改‍而不影响原文档。  
  让我们来看看使⁡用和不使用原型模式的区别：  
  
  <img width="1930" height="746" alt="image" src="https://github.com/user-attachments/assets/446093fe-9d89-44ef-84ac-25d3318be2eb" />

# 基本结构
  1. 原型接口（Prototype）：声明一个克隆自身的接口，所有具体原型类都需要实现这个接口。      ——原型的接口
  2. 具体原‌型类（Concre⁢tePrototy‏pe）：实现原型接‍口，定义如何复制自⁡身的对象。              ——具体原‌型类, 实现克隆自身接口
  3. 测试端（Client）：通过调用原型对象的克隆方法，来获取新的对象实例。

  <img width="556" height="748" alt="image" src="https://github.com/user-attachments/assets/7d8d3315-d3a6-44ec-8993-b6d874e32877" />

# 代码实现
  下面就以 ‌“文档克隆” 为例⁢，我们用原型模式实‏现文档复制功能。  
  
  1. 原型接口
     ```java
      public interface DocumentPrototype extends Cloneable {
          DocumentPrototype cloneDocument();
      }
     ```
     这一步是原型模式的基础，定义一个统一的克隆方法 cloneDocument()，表示所有可复制的文档都应该实现这个接口，具备自我复制的能力。
  2. 具体原型类
     ```java
      public class WordDocument implements DocumentPrototype {
          private String title;
          private String content;
          private List<String> images;
      
          public WordDocument(String title, String content, List<String> images) {
              this.title = title;
              this.content = content;
              this.images = new ArrayList<>(images);
          }
      
          @Override
          public DocumentPrototype cloneDocument() {
              try {
                  WordDocument copy = (WordDocument) super.clone();
                  copy.images = new ArrayList<>(this.images); // 深拷贝，避免共享引用
                  return copy;
              } catch (CloneNotSupportedException e) {
                  throw new RuntimeException("Clone failed", e);
              }
          }
      
          public void show() {
              System.out.println("Title: " + title);
              System.out.println("Content: " + content);
              System.out.println("Images: " + images);
          }
      
          public void setTitle(String title) {
              this.title = title;
          }
      
          public void setContent(String content) {
              this.content = content;
          }
      
          public void addImage(String image) {
              this.images.add(image);
          }
      }
     ```
     这段代码是原型模式的核心实现。通过 clone() 方法创建副本，同时对 images 列表做深拷贝，防止多个副本之间互相影响。
  3. 测试使用
     ```java
      public class Client {
          public static void main(String[] args) {
              List<String> images = new ArrayList<>();
              images.add("cover.png");
      
              WordDocument template = new WordDocument("招聘简历模板", "请填写个人信息", images);
              System.out.println("== 原始模板 ==");
              template.show();
      
              WordDocument doc1 = (WordDocument) template.cloneDocument();
              doc1.setTitle("鱼皮的简历");
              doc1.setContent("鱼皮，5年的全栈开发经验");
              doc1.addImage("yupi_avatar.png");
      
              WordDocument doc2 = (WordDocument) template.cloneDocument();
              doc2.setTitle("yes的简历");
              doc2.setContent("yes，8年的Java开发经验");
              doc2.addImage("yes_avatar.png");
      
              System.out.println("\n== 克隆出的鱼皮的简历 ==");
              doc1.show();
      
              System.out.println("\n== 克隆出的yes的简历 ==");
              doc2.show();
          }
      }
     ```
     输出结果：
     ```java
      plain
      复制代码
      == 原始模板 ==
      Title: 招聘简历模板
      Content: 请填写个人信息
      Images: [cover.png]
      
      == 克隆出的鱼皮的简历 ==
      Title: 鱼皮的简历
      Content: 鱼皮，5年的全栈开发经验
      Images: [cover.png, yupi_avatar.png]
      
      == 克隆出的yes的简历 ==
      Title: yes的简历
      Content: yes，8年的Java开发经验
      Images: [cover.png, yes_avatar.png]
     ```
     客户端通过调用 cloneDocument() 方法，快速创建多个互不干扰的文档副本，避免重复构造和字段复制，提高开发效率，这也正是原型模式的精髓所在。

# 优缺点
  优点:  
  - 对象创建效率高
  - 简化对象创建逻辑
  - 便于动态创建新对象

  缺点：
  - 深拷贝比较麻烦
  - 对克隆的依赖性强
  - 可能违反封装性：为了实现克隆，有时候需要暴露一些本来不应该开放的字段或方法，这可能会破坏类本身的封装性，降低系统的健壮性

# 应用场景
  - 图形编辑软件中的形状复制
  - 配置对象复制
  - 缓存对象克隆
  - 文档复制功能

# 开源框架中的应用
  1. Spring 框架中 Bean 的作用域  
     在 Spring 框架中，原型模式体现在 Bean 的作用域上。默认情况下，Spring 中的 Bean 是单例的，即容器中只存在一个实例。  
     如果我们希望每次获取 Bean 时都创建一个新的实例，可以将 Bean 的作用域设置为 prototype，容器就会每次 getBean 的时候都会克隆一个新的实例。  
     这个“克隆”的行为并不依赖 Java 的 clone() 方法，而是 Spring 自己通过反射机制，结合依赖注入，完成了类似原型模式的复制。  

     可以通过注解的方式定义一个原型作用域的 Bean  
     ```java
      @Component
      @Scope("prototype")
      public class PrototypeBean {
          // Bean 的定义
      }
     ```
     这样每次通过 ApplicationContext.getBean("prototypeBean") 获取 Bean 时，Spring 都会创建一个新的实例。  
     这种方法适用于需要频繁创建新对象的场景，比如处理用户请求的对象等  
 
     来看下 AbstractBeanFactory 中核心的逻辑  
     ```java
      // 根据bean名称获取bean
      @Override
      public Object getBean(String name) throws BeansException {
          return doGetBean(name, null, null, false);
      }
     ```
     进入 doGetBean 方法后，Spring 会根据 BeanDefinition 的 scope 字段判断是单例还是原型：  
     ```java
      if (mbd.isSingleton()) {
       // 单例
      } else if (mbd.isPrototype()) {
          // 如果是原型，就创建一个新的实例
          Object prototypeInstance = null;
          try {
              beforePrototypeCreation(beanName);
              prototypeInstance = createBean(beanName, mbd, args);
          }
          finally {
              afterPrototypeCreation(beanName);
          }
          beanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
      }
     ```
     而 createBean 会触发完整的 Bean 实例化流程，调用构造器、注入依赖、应用后置处理器，这一套操作每次调用都是“全新”的。  
     Spring 中的 prototype bean 并不是字节级的 clone，而是行为级的 clone —— 每次都创建一个新的对象实例，保留原有定义和配置。  

  2. Java 中的 Cloneable 接口和 Object 类的 clone() 方法  
     在 Java 中，原型模式主要通过 Cloneable 接口和 Object 类的 clone() 方法实现。  
     我们可以通过实现 Cloneable接口并重写 clone() 方法，来创建对象的副本。这个机制在一些标准类中得到了应用，比如 ArrayList。  

     以 ArrayList 为例，它实现了 Cloneable 接口，并重写了 clone() 方法：  
     ```java
      public class ArrayList<E> extends AbstractList<E>
              implements List<E>, RandomAccess, Cloneable, java.io.Serializable {
          // ...
      
          // 克隆方法
          public Object clone() {
              try {
                  ArrayList<?> v = (ArrayList<?>) super.clone();
                  v.elementData = Arrays.copyOf(elementData, size);
                  v.modCount = 0;
                  return v;
              } catch (CloneNotSupportedException e) {
                  // this shouldn't happen, since we are Cloneable
                  throw new InternalError(e);
              }
          }
      }
     ```
     在ArrayList中，clone() 方法首先调用 super.clone() 创建一个浅拷贝，然后使用 Arrays.copyOf 方法复制内部数组 elementData，  
     从而实现了深拷贝。这种方式避免了重新创建和初始化对象，提高了性能。
