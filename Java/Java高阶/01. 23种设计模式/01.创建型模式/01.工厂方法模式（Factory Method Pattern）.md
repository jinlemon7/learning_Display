# 定义
  旨在定义一个用于创建对象的接口（工厂接口）， 通过工厂子类决定实例化哪个具体类。  

  为了让大家更好地‌感受到工厂方法模式的作用，以日志⁢记录系统为例，我们需要支持多种日‏志记录方式（文件日志、数据库日志‍、控制台日志等）。  
  让我们来看看使⁡用和不使用工厂方法模式的区别：  
  
  <img width="1894" height="754" alt="image" src="https://github.com/user-attachments/assets/3634bf5e-98c4-46fe-aea5-c129b08599e0" />

# 基本结构  
  1. 抽象产‌品（Product⁢）：定义产品的公共‏接口，是所有具体产品‍的父类。                     ——产品类的接口
  2. 具体产‌品（Concret⁢eProduct）‏：实现了抽象产品接‍口，表示某种具⁡体的产品。               ——具体产品类
  3. 抽象工‌厂（Factory⁢）：定义了一个返回‏产品对象的方法（一‍般是一个抽象方法）⁡。            ——工厂接口
  4. 具体工厂（C‌oncreteFactory）⁢：实现了抽象工厂中的创建产品的‏方法，生成具体的产品实例。  ——具体工厂类

  <img width="1112" height="646" alt="image" src="https://github.com/user-attachments/assets/cb23b803-504c-429a-af15-ae2c5f205e9f" />

# 代码实现
  我们以 “‌消息通知系统” 为⁢例来实现抽象工厂模‏式，可以快速创建消‍息对象，整个流程如⁡下：  

  1. 产品类的接口
     ```java
      public interface Message {
          void send(String to, String content);
      }
     ```
     这个接口是所有“消息产品”的统一标准，无论是短信、邮件还是站内信，都必须实现 send 方法。
  2. 多个具体产品类
     ```java
      public class SmsMessage implements Message {
          @Override
          public void send(String to, String content) {
              System.out.println("发送短信给 " + to + "，内容：" + content);
          }
      }
      
      public class EmailMessage implements Message {
          @Override
          public void send(String to, String content) {
              System.out.println("发送邮件给 " + to + "，内容：" + content);
          }
      }
      
      public class InAppMessage implements Message {
          @Override
          public void send(String to, String content) {
              System.out.println("发送站内信给 " + to + "，内容：" + content);
          }
      }
     ```
     每个类都实现了 Message 接口，表示各自的发送方式。
  3. 工厂接口
     ```java
      // 抽象工厂接口：负责生产消息对象
      public interface MessageFactory {
          Message createMessage();
      }
     ```
     这是抽象工‌厂的核心部分，它规⁢定了工厂要提供的“‏产品生产线”接口。
  4. 多个具体工厂类
     ```java
      public class SmsMessageFactory implements MessageFactory {
          @Override
          public Message createMessage() {
              return new SmsMessage();
          }
      }
      
      public class EmailMessageFactory implements MessageFactory {
          @Override
          public Message createMessage() {
              return new EmailMessage();
          }
      }
      
      public class InAppMessageFactory implements MessageFactory {
          @Override
          public Message createMessage() {
              return new InAppMessage();
          }
      }
     ```
     每个工厂只负‌责创建一种消息对象，具⁢体怎么创建，它自己说‏了算。
  5. 业务调用
     ```java
      public class NotificationService {
          private final MessageFactory messageFactory;
      
          public NotificationService(MessageFactory factory) {
              this.messageFactory = factory;
          }
      
          public void notifyUser(String to, String content) {
              Message message = messageFactory.createMessage();
              message.send(to, content);
          }
      }
     ```
     业务完全‌不需要关心到底是邮⁢件、短信还是站内信‏，只需要注入一个“‍消息工厂”，然后就⁡可以调用。
  6. 测试使用
     ```java
        public class Main {
          public static void main(String[] args) {
              MessageFactory factory = new SmsMessageFactory(); // 切换只需换这里
              NotificationService service = new NotificationService(factory);
              service.notifyUser("13812345678", "您的验证码是 123456");
          }
      }
     ```
     输出结果：
     ```java
      plain
      复制代码
      发送短信给 13812345678，内容：您的验证码是 123456
     ```
     当我们要切换成邮件通知，只需要把 SmsMessageFactory 替换成 EmailMessageFactory，完全不需要改 NotificationService 的任何代码。

# 优缺点
  优点：  
  - 解耦了对象创建和使用
  - 符合开闭原则，易于扩展
  - 提高了代码的复用性和可维护性

  缺点：  
  - 类的数量会增多
  - 增加了系统复杂度
  - 有时候可能出现过度设计

# 应用场景
  - 消息通知系统：系统支持短信、邮件、站内信等不同通知方式时，可通过工厂方法屏蔽创建细节，让调用方只负责发消息。
  - 支付系统：用户可能选择支付宝、微信、银行卡等支付方式，工厂方法可以根据用户选择生成对应的支付通道对象，方便扩展新方式。
  - 文件解析模块：上传的文件可能是 Excel、CSV、JSON、XML 等不同格式，工厂方法可以根据文件类型创建对应的解析器实例，统一解析入口。
  - 业务规则引擎：当一个系统支持多个业务规则版本（如不同行业、不同客户），可以通过工厂方法创建对应的规则计算器，灵活支持定制化逻辑。

# 开源框架中的应用
  1. Spring 框架的核心接口BeanFactory  
     Spring 的核心接口 BeanFactory 提供了一个 getBean() 方法，用来获取容器中的 Bean 实例。  
     它的核心功能是根据传入的 Bean 名称（或者类型）来创建或返回一个已经存在的 Bean 实例。  

     BeanFactory 接口的定义：   
     ```java
      public interface BeanFactory {
          Object getBean(String name) throws BeansException;
      }
     ```
     Spring 的 AbstractBeanFactory 类实现了 BeanFactory 接口，负责管理 Bean 的创建和缓存。看看这个类里的一部分实现：  
     ```java
      public abstract class AbstractBeanFactory implements BeanFactory {
          // 根据名称获取 bean
          public Object getBean(String name) throws BeansException {
              return doGetBean(name, null, null, false);
          }
      
          protected <T> T doGetBean(String name, Class<T> requiredType, Object[] args, boolean typeCheckOnly) {
              // Create bean instance.
               // 省略代码...
              return createBean(beanName, mbd, args);
              // 省略代码...
          }
          // 创建指定名称的 Bean 实例，交由子类实现。
          // 抽象出具体 Bean 创建逻辑，便于子类定义不同的创建策略（如单例、原型、懒加载）；
          protected abstract Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
          throws BeanCreationException;
      }
     ```
     在这个例子中，getBean() 方法首先会检查是否有已经存在的单例 Bean。如果没有，它会调用 createBean() 方法来创建一个新的 Bean。  
     createBean() 方法的实现可以根据不同的条件（比如 Bean 的作用域、生命周期等）来决定具体的创建方式。这就是典型的工厂方法模式，  
     它将对象的创建逻辑封装在一个方法里，客户端只需要通过 getBean() 来获取对象，而不需要关心 Bean 是如何被实例化的。  

     类图如下：  
     <img width="1060" height="1432" alt="image" src="https://github.com/user-attachments/assets/ce3fa51e-11d9-428f-bee0-b95779b34e51" />

     从类图可以看出，BeanFactory 提供了一个统一的接口 getBean()，而 AbstractBeanFactory 则是实现具体的创建逻辑，  
     像 DefaultListableBeanFactory 就是它的一个具体实现。在这个结构中，createBean() 方法就是工厂方法，它负责具体 Bean 的实例化。  

  2. 在 JDK 中的 Calendar.getInstance() 方法  
     我们平时获取 Calendar 实例时，通常会这样做：  
     ```java
     Calendar calendar = Calendar.getInstance();
     ```  
     从表面上看，我们‌只是简单地调用了一个静态方⁢法。实际上，这个方法内部实现了工厂‏方法的逻辑。  
     它会根据当前系统的‍默认时区和语言环境，返回不同子⁡类的实例。我们来看一下源码：  
     ```java
      public static Calendar getInstance()
          {
              return createCalendar(TimeZone.getDefault(), Locale.getDefault(Locale.Category.FORMAT));
          }
     ```
     ```java
      private static Calendar createCalendar(TimeZone zone, Locale aLocale)
          {
              CalendarProvider provider =
                  LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale)
                                       .getCalendarProvider();
              // 省略代码...
      
              Calendar cal = null;
              // 根据不同的语言环境获取Calendar子类实例
              if (aLocale.hasExtensions()) {
                  String caltype = aLocale.getUnicodeLocaleType("ca");
                  if (caltype != null) {
                      switch (caltype) {
                      case "buddhist":
                      cal = new BuddhistCalendar(zone, aLocale);
                          break;
                      case "japanese":
                          cal = new JapaneseImperialCalendar(zone, aLocale);
                          break;
                      case "gregory":
                          cal = new GregorianCalendar(zone, aLocale);
                          break;
                      }
                  }
              }
              if (cal == null) {
                  if (aLocale.getLanguage() == "th" && aLocale.getCountry() == "TH") {
                      cal = new BuddhistCalendar(zone, aLocale);
                  } else if (aLocale.getVariant() == "JP" && aLocale.getLanguage() == "ja"
                             && aLocale.getCountry() == "JP") {
                      cal = new JapaneseImperialCalendar(zone, aLocale);
                  } else {
                      cal = new GregorianCalendar(zone, aLocale);
                  }
              }
              return cal;
          }
      ```
     在这里，Calendar.getInstance() 方法调用了 createCalendar() 方法，它根据不同的语言环境（Locale）和时区（TimeZone）  
     来决定返回哪个具体的 Calendar 子类（例如，GregorianCalendar 或 JapaneseImperialCalendar）。  
     这就是工厂方法模式的核心：将对象的创建过程交给工厂方法，客户端不需要知道具体的实现细节。  
     
     类图如下：
     <img width="5096" height="996" alt="image" src="https://github.com/user-attachments/assets/7a0d7c12-d577-4c89-b867-72222ede8cf0" />
     
