# 概念
  把一个复杂对象的创建过程拆解成多个步骤单元，逐步构建。  
  为了让大家更好地感受‌到建造者模式的作用，以电脑组装为例，我们⁢需要创建不同配置的电脑（游戏电脑、办公电脑‏等）。  
  让我们来看看使用和不使用建造者模‍式的区别：   
  <img width="1500" height="819" alt="image" src="https://github.com/user-attachments/assets/9e00b85c-85ec-48de-bd3e-4d7db25add93" />

# 基本结构
  1. 产品类‌（Product）⁢：要构建的复杂对象‏，包含多个组成部分‍
  2. 抽象建‌造者类（Build⁢er）：定义构建产‏品各个部分的抽象方‍法，以及返回最终产⁡品的方法。            ——抽象建造者类
  3. 具体建造‌者类（Concrete⁢Builder）：实现‏Builder接口，具‍体负责各个部分的构建细⁡节，并最终组装出完整产品。   ——具体建造者类
  4. 指挥者‌类（Directo⁢r）：统一指挥建造‏者按照一定步骤来构‍建产品，屏蔽了构建过⁡程的细节。                   ——调用具体建造者类的方法
  5. 业务端‌类（Client）⁢：发起建造请求，选‏择具体的建造者并使‍用指挥者来完成产⁡品的创建。

  <img width="638" height="712" alt="image" src="https://github.com/user-attachments/assets/460383cc-8850-40c1-8626-d0d0e3dd5787" />

# 代码实现
  1. 产品类
     ```java
      public class Computer {
          private String cpu;
          private String memory;
          private String hardDisk;
          private String gpu;
      
          public void setCpu(String cpu) {
              this.cpu = cpu;
          }
      
          public void setMemory(String memory) {
              this.memory = memory;
          }
      
          public void setHardDisk(String hardDisk) {
              this.hardDisk = hardDisk;
          }
      
          public void setGpu(String gpu) {
              this.gpu = gpu;
          }
      
          @Override
          public String toString() {
              return "Computer{" +
                     "cpu='" + cpu + '\'' +
                     ", memory='" + memory + '\'' +
                     ", hardDisk='" + hardDisk + '\'' +
                     ", gpu='" + gpu + '\'' +
                     '}';
          }
      }
     ```
  2. 建造者抽象类
     ```java
      public abstract class ComputerBuilder {
          protected Computer computer = new Computer();
      
          public abstract void buildCpu();
          public abstract void buildMemory();
          public abstract void buildHardDisk();
          public abstract void buildGpu();
      
          public Computer getResult() {
              return computer;
          }
      }
     ```
  3. 建造者具体类
     ```java
      public class GamingComputerBuilder extends ComputerBuilder {
          @Override
          public void buildCpu() {
              computer.setCpu("Intel i9");
          }
      
          @Override
          public void buildMemory() {
              computer.setMemory("32GB DDR5");
          }
      
          @Override
          public void buildHardDisk() {
              computer.setHardDisk("1TB NVMe SSD");
          }
      
          @Override
          public void buildGpu() {
              computer.setGpu("NVIDIA RTX 4090");
          }
      }
     ```
  4. 指挥者类
     ```java
      public class Director {
          private ComputerBuilder builder;
      
          public Director(ComputerBuilder builder) {
              this.builder = builder;
          }
      
          public Computer construct() {
              builder.buildCpu();
              builder.buildMemory();
              builder.buildHardDisk();
              builder.buildGpu();
              return builder.getResult();
          }
      }
     ```
  5. 测试使用
     ```java
      public class Main {
          public static void main(String[] args) {
              ComputerBuilder builder = new GamingComputerBuilder();
              Director director = new Director(builder);
              Computer gamingPc = director.construct();
              System.out.println(gamingPc);
          }
      }
     ```

# 优缺点
  优点：  
  - 结构清晰、过程可控
  - 便于构建“不同版本”的对象
  - 代码更易维护和扩展
   缺点：
  - 增加了类的数量
  - 不适合构建过程差异太大的对象

# 应用场景
  - 复杂表单或请求对象的构建
  - 导出文件内容构建
  - 业务流水记录对象创建
  - 消息推送内容构建器

# 开源框架中的应用
  1. Spring 框架中的BeanDefinitionBuilder  
     在 Spring 框架中，BeanDefinitionBuilder 是建造者模式的典型应用。它用于以编程方式构建 BeanDefinition 对象，  
     允许我们逐步设置 Bean 的各种属性，如类名、作用域、构造函数参数等。通过这种方式，我们可以灵活地定义和注册 Bean，  
     而无需直接操作底层的 BeanDefinition 接口    

     以下是一个使用 BeanDefinitionBuilder 构建 Bean 的示例：  
     ```java
      // 创建 AnnotationConfigApplicationContext，这是一个可配置的应用上下文  
      AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();  
      // 获取 BeanDefinitionRegistry，用于注册新的 Bean 定义  
      BeanDefinitionRegistry registry = (BeanDefinitionRegistry) context.getBeanFactory();  
      // 使用 BeanDefinitionBuilder 创建一个新的 Bean 定义  
      BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(UserService.class);
      // 为新的 Bean 定义设置属性  
      builder.addPropertyValue("property", "value");
      // 为新的 Bean 设置作用域
      builder.setScope(BeanDefinition.SCOPE_SINGLETON);
      // 构建并获取 GenericBeanDefinition 对象 
      BeanDefinition beanDefinition = builder.getBeanDefinition();
      // 注册新的 Bean 定义到容器中，使用 "userService" 作为 Bean 的名称  
      registry.registerBeanDefinition("userService", beanDefinition);  
      // 刷新上下文，以便应用新的 Bean 定义  
      context.refresh();
     ```
     这个示例中，我们通过 BeanDefinitionBuilder 构建了一个 UserService 的 BeanDefinition，  
     并设置了属性和作用域，最后获取了构建好的 BeanDefinition 对象。  

     我们可以通过一张类图，来展示建造者模式的简单结构：  
     <img width="2428" height="1672" alt="image" src="https://github.com/user-attachments/assets/c2c50a4f-921d-4f0c-8baa-6d3879d1fa97" />

     这个类图展示了 BeanDefinitionBuilder 如何构建不同类型的 BeanDefinition，以及它们之间的继承关系。  

  2. JDK 中的StringBuilder
     在 JDK 中，StringBuilder 是建造者模式的一个经典例子。    
     我们可以通过连续调用 append 方法，逐步构建一个字符串对象，最后通过 toString 方法获取最终的字符串。  
     这种方式避免了创建多个临时字符串对象，提高了性能  
     ```java
      StringBuilder sb = new StringBuilder();
      sb.append("我是");
      sb.append("鱼皮");
      String result = sb.toString();
     ```
     在这个过程中，StringBuilder 充当了建造者的角色，append 方法是构建过程中的各个步骤，toString 方法则是获取最终产品的方式。
     
