# 概念
  一个“超级工厂”的接口，专门用来创建一整组互相关联的产品对象。      ——产品族（一系列产品）  

# 基本结构
  - 抽象工厂（AbstractFact‌ory）：声明一组创建产品的方法。                     ——产品族工厂接口
  - 具体工厂（ConcreteFac⁢tory）：实现创建具体产品对象的方法。                 ——产品族具体工厂类
  - 抽象产品（Abstract‏Product）：定义每个产品的公共接口。                     ——产品接口
  - 具体产品（Concret‍eProduct）：实现具体的产品对象。                        ——具体产品类
  - 业务端（Client）：只⁡依赖抽象工厂和抽象产品，负责调用工厂去生产对象。
  <img width="1434" height="612" alt="image" src="https://github.com/user-attachments/assets/021b4bb1-2df8-4c9b-8ba8-2ff86ba3a02a" />


# 代码实现
  1. 定义产品接口  
     ```java
      public interface Button {
          void render();
      }
      
      public interface TextBox {
          void render();
      }
      
      public interface Image {
          void render();
      }
     ```
     这一步的目的是统一各个产品的对外接口，比如所有平台的按钮都有 render() 方法，这样我们就能做到“面向接口编程”，平台实现细节被隐藏起来。  
  2.  定义产品族工厂接口
     ```java
      public interface UIFactory {
          Button createButton();
          TextBox createTextBox();
          Image createImage();
      }
     ```
  3. 定义产品具体类
     ```java
      public class WebButton implements Button {
          @Override
          public void render() {
              System.out.println("渲染 Web 风格按钮");
          }
      }
      
      public class WebTextBox implements TextBox {
          @Override
          public void render() {
              System.out.println("渲染 Web 风格文本框");
          }
      }
      
      public class WebImage implements Image {
          @Override
          public void render() {
              System.out.println("渲染 Web 风格图片组件");
          }
      }
     ```
     每个产品都有对应平台的实现类，比如 Web 平台的 WebButton、WebTextBox 等，分别去实现各自的接口。  
  4. 定义产品族具体工厂
     ```java
      public class WebUIFactory implements UIFactory {
          @Override
          public Button createButton() {
              return new WebButton();
          }
      
          @Override
          public TextBox createTextBox() {
              return new WebTextBox();
          }
      
          @Override
          public Image createImage() {
              return new WebImage();
          }
      }
     ```
     ```java
      public class AndroidButton implements Button {
          @Override
          public void render() {
              System.out.println("渲染 Android 原生按钮");
          }
      }
      
      public class AndroidTextBox implements TextBox {
          @Override
          public void render() {
              System.out.println("渲染 Android 原生文本框");
          }
      }
      
      public class AndroidImage implements Image {
          @Override
          public void render() {
              System.out.println("渲染 Android 原生图片组件");
          }
      }
      
      public class AndroidUIFactory implements UIFactory {
          @Override
          public Button createButton() {
              return new AndroidButton();
          }
      
          @Override
          public TextBox createTextBox() {
              return new AndroidTextBox();
          }
      
          @Override
          public Image createImage() {
              return new AndroidImage();
          }
      }
     ```
     我们在这里‌复用了同一套接口，把⁢ Android 平‏台的产品实现了出来，‍然后交给 Andro⁡id 平台的工厂统一创建。  
  5. 测试使用
     ```java
      public class Client {
          public static void main(String[] args) {
              // 假设当前运行环境为 Web
              UIFactory factory = new WebUIFactory();
      
              Button button = factory.createButton();
              TextBox textBox = factory.createTextBox();
              Image image = factory.createImage();
      
              button.render();
              textBox.render();
              image.render();
          }
      }
     ```
     输出结果：
     ```java
      plain
      复制代码
      渲染 Web 风格按钮
      渲染 Web 风格文本框
      渲染 Web 风格图片组件
     ```
     业务端只需要和 UIFactory 打交道，不关心具体创建的是 Web 组件还是 Android 组件，完全通过接口访问。  
     这就是抽象工厂的优势——屏蔽创建细节，统一调用方式。  
     
# 优缺点  
  优点：    
  - 产品族的一致性
  - 便于切换产品系列
  - 封装了对象的创建逻辑
  缺点：
  - 扩展产品族比较困难
  - 一旦产品族的结构确定下来，比如工厂里要创建哪些产品是固定的，后期要再加一个新产品（比如再加一个新控件），就得改所有的工厂实现类，  
    违反了开闭原则。
  - 类的数量会变多
  - 增加了系统的抽象层级

# 应用场景
  - 多平台 UI 渲染引擎
  - 多数据库适配场景
  - 多种导出格式支持系统
  - 多语言/多地区内容适配

# 开源框架中的应用
  1. Spring 框架中的ApplicationContext  
     Spring 对抽象工厂模式的使用非常广泛，最核心的地方就是我们平时使用的 ApplicationContext。  
     尤其是 AbstractApplicationContext 和它内部对 BeanFactory 的创建逻辑，本质上就是在用抽象工厂模式  

     我们来看下 Spring 启动时创建 Bean 工厂的过程。以 AbstractApplicationContext 为例，它内部定义了这样一个抽象方法：  
     ```java
      // 刷新当前 ApplicationContext 使用的 BeanFactory 实例。
      protected abstract void refreshBeanFactory() throws BeansException, IllegalStateException;
     ```
     这个方法由子类去具体实现，比如 GenericApplicationContext 或 AbstractRefreshableApplicationContext。  
     这个方法最终的职责是：构建出一个 BeanFactory 实例（比如 DefaultListableBeanFactory），并在其中加载 Bean 定义。
     
     下面是AbstractRefreshableApplicationContext里的实现：
      这个方法由子类去具体实现，比如 GenericApplicationContext 或 AbstractRefreshableApplicationContext。
 
     我们来看下AbstractRefreshableApplicationContext里的实现：
     ```java
      @Override
      protected final void refreshBeanFactory() throws BeansException {
      // 如果已有 BeanFactory，销毁其中所有 Bean 并关闭
      if (hasBeanFactory()) {
          destroyBeans();
          closeBeanFactory();
      }
      // 创建新的 BeanFactory（默认 DefaultListableBeanFactory）
      DefaultListableBeanFactory beanFactory = createBeanFactory();
      this.beanFactory = beanFactory;
      // 允许子类定制 BeanFactory 设置（如是否允许覆盖、循环依赖等）
      customizeBeanFactory(beanFactory);
      // 加载 Bean 定义（如从 XML、注解、配置类中）
      loadBeanDefinitions(beanFactory);
      }
      // 创建BeanFactory
      protected DefaultListableBeanFactory createBeanFactory() {
          return new DefaultListableBeanFactory(getInternalParentBeanFactory());
      }
      // 加载 Bean 定义到指定的 BeanFactory 中
      protected abstract void loadBeanDefinitions(DefaultListableBeanFactory beanFactory)
      throws BeansException, IOException;
     ```
     这个方法里通过 createBeanFactory() 创建了一个 DefaultListableBeanFactory，然后加载了 XML 或注解配置的 Bean 定义。  
     这就体现了抽象工厂的特点：根据环境或配置，创建出一组相互关联的对象（即多个 Bean 实例），这些对象由统一的工厂进行管理。  

  3. JDK中的DocumentBuilderFactory  
     我们平时解析 XML 文件时，可能会这么写：  
     ```java
      DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
      DocumentBuilder builder = factory.newDocumentBuilder();
      Document document = builder.parse(new File("test.xml"));
     ```
     这段代码的背后，其实就隐藏着抽象工厂的逻辑。  
     我们来分析‌一下：  
     - DocumentBuilderFactory 是一个抽象类，定义了创建产品的方法，比如 newDocumentBuilder()。  
     - 不同的厂商可以实现自己的工厂类，比如内部可能是 com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl。  
     - 每个具体工厂都能生产一组“配套”的产品：DocumentBuilder 就是其中之一，背后还可能关联解析器、验证器等。  
     
     源码里我们可以看到这个关键方法：  
     ```java
      public abstract class DocumentBuilderFactory {
          // 静态工厂方法，用于获取 DocumentBuilderFactory 的具体实现类实例。
          public static DocumentBuilderFactory newInstance() {
              return FactoryFinder.find(
                  /* The default property name according to the JAXP spec */
                  DocumentBuilderFactory.class, // "javax.xml.parsers.DocumentBuilderFactory"
                  /* The fallback implementation class name */
                  "com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl");
          }
      
      
          // 抽象工厂方法，用于创建新的 DocumentBuilder 实例。
          public abstract DocumentBuilder newDocumentBuilder()
          throws ParserConfigurationException;
      }
     ```
     这里的 FactoryFinder 会根据系统属性、配置文件、SPI 等机制返回不同实现的工厂类，实现了运行时灵活扩展的能力。
