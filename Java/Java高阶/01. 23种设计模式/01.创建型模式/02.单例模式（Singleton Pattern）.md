# 概念
  全局只能有一个对象，而且这个对象谁都能随时找到。  
  为了让大家更好地‌感受到单例模式的作用，以数据库连⁢接管理器为例，我们需要确保整个应‏用程序中只有一个数据库连接实例，‍以避免资源浪费和连接冲突。  
  让我们⁡来看看使用和不使用单例模式的区别：  
  <img width="1906" height="1046" alt="image" src="https://github.com/user-attachments/assets/f4c5eba1-0ac1-4046-9470-cef30c26222b" />

# 基本结构
  <img width="634" height="209" alt="image" src="https://github.com/user-attachments/assets/421a0a1e-d614-4494-8860-3db4862cc8ce" />

  在这个类图中：  
  - Singleton() 是私有构造方法，防止外部实例化
  - instance是私有的静态实例变量
  - getInstance() 是对外暴露的获取实例的静态方法

# 单例设计模式的基本要求
  1. 私有化构造器：禁止外部直接 new，这样才能确保外部拿不到新对象。
  2. 持有唯一实例的静态变量：通常写成 private static Singleton instance;，程序启动或首次访问时再创建。
  3. 全局访问点：提供一个 public static getInstance() 方法，外部就通过这个方法拿到唯一实例。
  4. 线程安‌全：在多线程场景下⁢，还得保证并发时也‏只有一份，常见做法‍有加锁、双检锁、静⁡态内部类、或者直接用枚举。

# 代码实现
  1. 饿汉式（Eager Initialization）
     饿汉式是在类‌加载阶段就完成实例化，保⁢证从第一次访问该类到程序‏结束，全局只有这一个实例‍。它依赖 JVM 的类加⁡载机制来确保线程安全。
     ```java
      public class Singleton {
          private static final Singleton INSTANCE = new Singleton();   //Singleton作为字段在类加载时被实例化，类加载机制强制初始化时线程唯一
          private Singleton() { }
          public static Singleton getInstance() {
              return INSTANCE;
          }
      }
     ```
  2. 懒汉式（Synchronized Lazy）
     懒汉式在第一次调用 getInstance() 时才创建实例，通过对该方法加锁来保证线程安全，适合对启动性能有要求且实例不一定马上需要的场景。
     ```java
      public class Singleton {
          private static Singleton instance;                          
          private Singleton() { }
          public static synchronized Singleton getInstance() {    //jvm默认懒式解析和初始化，只有第一次调用getInstance时才创建实例
              if (instance == null) {                             //对方法加锁保证线程安全
                  instance = new Singleton();
              }
              return instance;
          }
      }
     ```
  3. 双重检‌查锁定（Doubl⁢e-Checked‏ Locking）
     双重检查锁‌定结合了懒汉式的延⁢迟加载和饿汉式的高‏性能，首次创建时加‍锁，后续访问则跳过⁡同步块，从而减少锁开销。
     ```java
      public class Singleton {
          private static volatile Singleton instance;     //volatile：轻量级同步机制，主要用于 多线程环境下的变量可见性 和 禁止指令重排序
          private Singleton() { }
          public static Singleton getInstance() {
              if (instance == null) {                               // 第一次检查
                  synchronized (Singleton.class) {
                      if (instance == null) {                       // 第二次检查
                          instance = new Singleton();               // 禁止重排序保证安全:new Singleton() 不是原子操作，可能被重排序
                      } 
                  }
              }
              return instance;
          }
      }
     ```
  4. 静态内‌部类（Initia⁢lization-‏on-demand‍ Holder）
     利用 JVM‌ 在加载外部类时并不立即⁢加载内部类的特性，将实例‏的创建延迟到真正访问内‍部类时。既能延迟加载，又能⁡借助类加载的线程安全特性。
     ```java
      public class Singleton {
          private Singleton() { }
          private static class Holder {
              private static final Singleton INSTANCE = new Singleton();
          }
          public static Singleton getInstance() {
              return Holder.INSTANCE;
          }
      }
     ```
  5. 枚举式（Enum Singleton）
     利用 Java‌ 枚举类型的特性，枚举值在⁢类加载时就创建，JVM 保‏证枚举实例的线程安全和‍唯一性。同时，枚举对序列化和反⁡射攻击具有天然防护能力。
     ```java
      public enum Singleton {
          INSTANCE;
      }
     ```
     
# 优缺点
  优点：  
  - 全局唯一，资源可控
  - 提供统一访问点
  - 便于扩展为多线程安全版本
  缺点:
  - 不利于测试和扩展：单例一旦写死了，很难在单元测试时替换成 mock 对象，也不容易在运行时切换成别的实现，不利于灵活扩展和测试隔离。
  - 可能引发隐藏的状态问题
  - 生命周期不可控：单例通常在 JVM 生命周期内都存在，不容易销毁，容易导致资源无法及时释放

# 应用场景
  - 全局唯一ID生成器
  - 系统配置管理类
  - 应用级缓存组件

# 开源框架中的应用
  1. Spring 框架中的自定义bean（未指定scope）  
     在 Spri‌ng 框架里，单例模式⁢简直是无处不在。默认情‏况下，我们自己写的 B‍ean，如果没有额外指⁡定 scope，都是单例的。  
     举个例子，我们有这样一个配置类：  
     ```java
      @Configuration
      public class AppConfig {
          @Bean
          public UserService userService() {
              return new UserService();
          }
      }
     ```
     只要这个配置类被 Spring 扫描到，Spring 就会在容器初始化时创建一个 UserService 实例，放进它的 Bean 容器里。  
     之后我们每次调用 getBean(UserService.class)，拿到的都是同一个对象。  

     我们来看下底层 Spring 是怎么实现这个单例逻辑的。  
     Spring 的 Bean 创建流程大致是  
     ```java
      getBean(name) →
          doGetBean(name) →
              getSingleton(name) →
                  singletonObjects.get(name)
     ```
     其中 singletonObjects 是一个 ConcurrentHashMap，保存着所有单例 Bean。  
     ```java
      // org.springframework.beans.factory.support.DefaultSingletonBeanRegistry
      public class DefaultSingletonBeanRegistry {
         	private final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);
      
          // 从单例对象集合里获取bean
          protected Object getSingleton(String beanName) {
              Object singletonObject = this.singletonObjects.get(beanName);
              // 其他逻辑
              return singletonObject;
          }
      
          protected void addSingleton(String beanName, Object singletonObject) {
             synchronized (this.singletonObjects) {
      			this.singletonObjects.put(beanName, singletonObject);
      			// 其他逻辑 
      		}
          }
      }
     ```
     也就是说，S‌pring 把所有单例⁢ Bean 放在一个 ‏Map 中，初始化时创‍建一次，之后每次从这个⁡ Map 里直接拿。  
     
     我们可以用‌一张类图，来梳理下⁢ Spring 单‏例实现相关的几个核‍心类：  
     <img width="1528" height="2048" alt="image" src="https://github.com/user-attachments/assets/950c63d4-a224-4797-873a-71954ad420d1" />

     从类图上我们可以看出：  
     - DefaultSingletonBeanRegistry 是负责缓存和管理单例的核心类；
     - DefaultListableBeanFactory 通过继承 AbstractBeanFactory 来实现 Bean 获取逻辑；
     - 所有获取单例的操作，最终都会走到 getSingleton() 方法。

  2. JDK中的java.lang.Runtime.getRuntime()  
     java.lang.Runtime 类就是一个标准的单例，它通过 getRuntime() 方法返回唯一实例。  
     平时我们要执行一些本地命令，比如启动外部程序或者获取系统环境信息，都会用到 Runtime.getRuntime()：  
     ```java
      Runtime runtime = Runtime.getRuntime();
      runtime.exec("ls");
     ```
     从外部来看，这个类就是通过一个 getRuntime() 方法来获取实例，那内部是怎么保证只返回一个实例的呢？我们来看看源码：
     ```java
      public class Runtime {
          private static final Runtime currentRuntime = new Runtime();
      
          public static Runtime getRuntime() {
              return currentRuntime;
          }
      
          private Runtime() {}  // 构造方法私有化
      }
     ```
     这个写法其实就是我们最常说的 饿汉式单例模式，线程安全，而且写法简单。  
